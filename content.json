{"meta":{"title":"linkfqy","subtitle":"A link to the past.","description":null,"author":"linkfqy","url":"http://oi.linkfqy.top"},"pages":[{"title":"分类","date":"2021-08-01T12:44:16.018Z","updated":"2018-02-25T01:09:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://oi.linkfqy.top/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2021-03-27T03:01:56.752Z","updated":"2021-03-27T03:01:56.752Z","comments":false,"path":"about/index.html","permalink":"http://oi.linkfqy.top/about/index.html","excerpt":"","text":"前OIer，现摸鱼大学狗一枚 对人类的知识怀有好奇，理工文史哲均有涉猎（全凭兴趣，杂而不精） 2018.2.24将博客从CSDN迁移至此。"},{"title":"友情链接","date":"2020-11-12T16:15:20.324Z","updated":"2018-02-25T01:08:04.000Z","comments":true,"path":"links/index.html","permalink":"http://oi.linkfqy.top/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-11-12T16:15:20.324Z","updated":"2018-02-25T01:09:10.000Z","comments":false,"path":"tags/index.html","permalink":"http://oi.linkfqy.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-11-12T16:15:20.220Z","updated":"2018-05-27T21:52:30.000Z","comments":true,"path":"documents/emacs-keybindings table.html","permalink":"http://oi.linkfqy.top/documents/emacs-keybindings table.html","excerpt":"","text":"Table�1.�emacs-keybindings table.Table�1.�emacs-keybindings table.FunctionnameKeysbindingFunctionnameKeysbindingFunctionnameKeysbindingControl-X-prefixC-xInfo-goto-emacs-command-nodeC-hC-fInfo-goto-emacs-key-command-nodeC-hC-kabbrev-prefix-markM-'abort-recursive-editC-]add-change-log-entry-other-windowC-x4aadd-global-abbrevC-xagadd-mode-abbrevC-xa+add-mode-abbrevC-xaC-aadd-mode-abbrevC-xaladvertised-undoC-xuappend-next-killM-C-wapropos-commandC-haback-to-indentationM-mbackward-char-mark&lt;S-left&gt;backward-char-nomark&lt;left&gt;backward-charC-bbackward-kill-sentenceC-xDELbackward-kill-sexp&lt;C-M-backspace&gt;backward-kill-sexpM-&lt;C-backspace&gt;backward-kill-sexpM-&lt;C-delete&gt;backward-kill-word&lt;C-backspace&gt;backward-line-mark&lt;M-S-up&gt;backward-listM-C-pbackward-pageC-x[backward-paragraph-mark&lt;C-S-up&gt;backward-paragraph-nomark&lt;C-up&gt;backward-paragraphM-{backward-sexpM-C-bbackward-up-listM-C-ubackward-word-mark&lt;C-S-left&gt;backward-word-mark&lt;M-S-left&gt;backward-word-nomark&lt;C-left&gt;backward-word-nomark&lt;M-left&gt;backward-wordM-bbalance-windowsC-x+beginning-of-buffer-mark&lt;C-S-home&gt;beginning-of-buffer-mark&lt;M-S-home&gt;beginning-of-buffer-nomark&lt;M-home&gt;beginning-of-buffer-other-window&lt;M-begin&gt;beginning-of-buffer&lt;C-home&gt;beginning-of-bufferM-&lt;beginning-of-defunM-C-abeginning-of-line-mark&lt;S-home&gt;beginning-of-line&lt;home&gt;beginning-of-lineC-abookmark-bmenu-listC-xrlbookmark-jumpC-xrbbookmark-setC-xrmbs-cycle-next&lt;C-tab&gt;bs-cycle-previous&lt;S-tab&gt;buffer-menu&lt;f6&gt;call-last-kbd-macroC-xecapitalize-wordM-cclear-rectangleC-xrcclipboard-kill-region&lt;cut&gt;clipboard-kill-ring-save&lt;copy&gt;clipboard-yank&lt;paste&gt;clone-indirect-buffer-other-windowC-x4ccomment-dwimM-;comment-regionC-cccomment-set-columnC-x;complete-symbolM-TABcompose-mail-other-frameC-x5mcompose-mail-other-windowC-x4mcompose-mailC-xmcopy-rectangle-to-registerC-xrrcopy-region-as-kill-nomarkM-wcopy-region-as-kill&lt;C-insert&gt;copy-to-register-compatibility-bindingC-xxcopy-to-registerC-xrscopy-to-registerC-xrxcount-lines-pageC-xlcount-lines-regionM-=ctl-x-4-prefixC-x4ctl-x-5-prefixC-x5dabbrev-completionM-C-/dabbrev-expandM-/delete-blank-linesC-xC-odelete-frameC-x50delete-horizontal-spaceM-\\delete-indentationM-^delete-other-framesC-x51delete-other-windowsC-x1delete-rectangleC-xrddelete-windowC-x0describe-bindingsC-hbdescribe-classC-hCdescribe-copyingC-hC-cdescribe-distributionC-hC-ddescribe-functionC-hddescribe-functionC-hfdescribe-genericC-hgdescribe-input-methodC-hC-\\describe-input-methodC-hIdescribe-key-brieflyC-hcdescribe-keyC-hkdescribe-language-environmentC-hC-ldescribe-language-environmentC-hLdescribe-modeC-hmdescribe-no-warrantyC-hC-wdescribe-projectC-hC-pdescribe-syntaxC-hsdescribe-variableC-hvdigit-argumentC-0digit-argumentC-1digit-argumentC-2digit-argumentC-3digit-argumentC-4digit-argumentC-5digit-argumentC-6digit-argumentC-7digit-argumentC-8digit-argumentC-9digit-argumentM-0..M-9digit-argumentM-C-0digit-argumentM-C-1digit-argumentM-C-2digit-argumentM-C-3digit-argumentM-C-4digit-argumentM-C-5digit-argumentM-C-6digit-argumentM-C-7digit-argumentM-C-8digit-argumentM-C-9dired-other-frameC-x5ddired-other-windowC-x4ddiredC-xddisplay-bufferC-x4C-odown-listM-C-ddowncase-regionC-xC-ldowncase-wordM-ledit-kbd-macroC-xC-kend-kbd-macroC-x)end-of-buffer-mark&lt;C-S-end&gt;end-of-buffer-mark&lt;M-S-end&gt;end-of-buffer-nomark&lt;M-end&gt;end-of-buffer&lt;C-end&gt;end-of-bufferM-&gt;end-of-defunM-C-eend-of-line-mark&lt;S-end&gt;end-of-line&lt;end&gt;end-of-lineC-eenlarge-window-horizontallyC-x}enlarge-windowC-x^erc-track-switch-bufferC-cC-@erc-track-switch-bufferC-cC-SPCeval-expressionM-:eval-expressionM-M-:eval-last-sexpC-xC-eevent-apply-alt-modifierC-x@aevent-apply-control-modifierC-x@cevent-apply-hyper-modifierC-x@hevent-apply-meta-modifierC-x@mevent-apply-shift-modifierC-x@Sevent-apply-super-modifierC-x@sexchange-point-and-mark-nomarkC-xC-xexecute-extended-commandM-xexit-recursive-editM-C-cexpand-abbrev&lt;M-return&gt;expand-abbrevC-x'expand-abbrevC-xa'expand-abbrevC-xaeexpand-jump-to-next-slotC-xanexpand-jump-to-previous-slotC-xapfacemenu-keymapM-gfind-alternate-fileC-xC-vfind-file-other-frameC-x5C-ffind-file-other-frameC-x5ffind-file-other-windowC-x4C-ffind-file-other-windowC-x4ffind-file-read-only-other-frameC-x5rfind-file-read-only-other-windowC-x4rfind-file-read-onlyC-xC-rfind-fileC-xC-ffind-tag-other-frameC-x5.find-tag-other-windowC-x4.find-tag-regexpM-C-.find-tagM-.finder-by-keywordC-hpfont-lock-fontify-blockM-gM-gforward-char-mark&lt;S-right&gt;forward-char-nomark&lt;right&gt;forward-charC-fforward-line-mark&lt;M-S-down&gt;forward-listM-C-nforward-pageC-x]forward-paragraph-mark&lt;C-S-down&gt;forward-paragraph-nomark&lt;C-down&gt;forward-paragraphM-}forward-sexpM-C-fforward-word-mark&lt;C-S-right&gt;forward-word-mark&lt;M-S-right&gt;forward-word-nomark&lt;C-right&gt;forward-word-nomark&lt;M-right&gt;forward-wordM-fframe-configuration-to-registerC-xrfhelp-command&lt;help&gt;help-commandC-hhelp-for-helpC-h&lt;f1&gt;help-for-helpC-h&lt;help&gt;help-for-helpC-h?help-for-helpC-hC-hhelp-quitC-hqhelp-with-tutorialC-hticonify-or-deiconify-frameC-xC-ziconify-or-deiconify-frameC-zincrement-registerC-xr+indent-regionM-C-\\indent-rigidlyC-xTABinfo-lookup-symbolC-hTABinfo-other-windowC-h4iinfoC-hiinsert-fileC-xiinsert-parenthesesM-(insert-register-compatibility-bindingC-xginsert-registerC-xrginsert-registerC-xriinverse-add-global-abbrevC-xa-inverse-add-global-abbrevC-xai ginverse-add-mode-abbrevC-xai lisearch-backward-regexpM-C-risearch-backwardC-risearch-forward-regexpM-C-sisearch-forwardC-sispell-wordM-$jump-to-register-compatibility-bindingC-xjjump-to-registerC-xrjjust-one-spaceM-SPCkbd-macro-queryC-xqkeyboard-escape-quitM-M-ESCkeyboard-quitC-gkill-buffer-and-windowC-x40kill-bufferC-xkkill-rectangleC-xrkkill-region&lt;S-delete&gt;kill-regionC-wkill-sentenceM-kkill-sexp&lt;C-M-delete&gt;kill-sexpM-C-kkill-whole-lineC-kkill-word&lt;C-delete&gt;kill-wordM-dlist-buffersC-xC-blist-directoryC-xC-dmake-frame-commandC-x52man-follow&lt;f1&gt;mark-pageC-xC-pmark-paragraphM-hmark-sexpM-C-@mark-sexpM-C-SPCmark-whole-bufferC-xhmark-wordM-@move-past-close-and-reindentM-)move-to-window-lineM-rnarrow-to-defunC-xndnarrow-to-pageC-xnpnarrow-to-regionC-xnnnegative-argumentC--negative-argumentM--negative-argumentM-C--newline-and-indentC-jnext-errorC-x`next-line-mark&lt;S-down&gt;next-line-nomark&lt;down&gt;next-lineC-nnot-modifiedM-~number-to-registerC-xrnopen-lineC-oopen-rectangleC-xroother-frameC-x5oother-windowC-xooverwrite-mode&lt;insert&gt;pager-page-down&lt;next&gt;pager-page-up&lt;prior&gt;pager-row-down&lt;M-down&gt;pager-row-up&lt;M-up&gt;point-to-register-compatibility-bindingC-x/point-to-registerC-xrC-@point-to-registerC-xrC-SPCpoint-to-registerC-xrSPCpop-global-markC-xC-@pop-global-markC-xC-SPCpop-tag-markM-*previous-line-mark&lt;S-up&gt;previous-line-nomark&lt;up&gt;previous-lineC-pquery-replace-regexpM-C-%query-replaceM-%quoted-insertC-qrecenterC-lrepeat-complex-commandC-xM-:repeatC-xzreposition-windowM-C-lsave-bufferC-xC-ssave-buffers-kill-emacsC-xC-csave-some-buffersC-xsscroll-down-mark&lt;S-prior&gt;scroll-downM-vscroll-left&lt;C-next&gt;scroll-leftC-x&lt;scroll-other-window-down&lt;M-prior&gt;scroll-other-window-downM-C-S-vscroll-other-window&lt;M-next&gt;scroll-other-windowM-C-vscroll-right&lt;C-prior&gt;scroll-rightC-x&gt;scroll-up-mark&lt;S-next&gt;scroll-upC-vset-buffer-file-coding-systemC-xRETfset-buffer-process-coding-systemC-xRETpset-fill-columnC-xfset-fill-prefixC-x.set-goal-columnC-xC-nset-input-methodC-xRETC-\\set-keyboard-coding-systemC-xRETkset-language-environmentC-xRETlset-mark-commandC-@set-mark-commandC-SPCset-next-selection-coding-systemC-xRETXset-selection-coding-systemC-xRETxset-selective-displayC-x$set-terminal-coding-systemC-xRETtshell-command-on-regionM-|shell-commandM-!shrink-window-horizontallyC-x{shrink-window-if-larger-than-bufferC-x-speedbar-get-focus&lt;f4&gt;split-lineM-C-osplit-window-horizontallyC-x3split-window-verticallyC-x2start-kbd-macroC-x(string-rectangleC-xrtswitch-to-buffer-other-frameC-x5bswitch-to-buffer-other-windowC-x4bswitch-to-bufferC-xbtab-to-tab-stopM-itags-loop-continueM-,tmm-menubarM-`toggle-input-methodC-\\transpose-charsC-ttranspose-linesC-xC-ttranspose-sexpsM-C-ttranspose-wordsM-tundo&lt;M-backspace&gt;undoC-/undoC-_undoM-DELuniversal-argumentC-uuniversal-coding-system-argumentC-xRETcupcase-regionC-xC-uupcase-wordM-uvc-annotateC-xvgvc-cancel-versionC-xvcvc-create-snapshotC-xvsvc-diffC-xv=vc-directoryC-xvdvc-insert-headersC-xvhvc-mergeC-xvmvc-next-actionC-xvvvc-prefix-mapC-xvvc-print-logC-xvlvc-registerC-xvivc-retrieve-snapshotC-xvrvc-revert-bufferC-xvuvc-switch-backendC-xvbvc-toggle-read-onlyC-xC-qvc-update-change-logC-xvavc-version-other-windowC-xv~view-emacs-FAQC-hFview-emacs-newsC-hC-nview-emacs-newsC-hnview-emacs-problemsC-hPview-hello-fileC-hhview-lossageC-hlview-order-manualsC-hRETwhat-cursor-positionC-x=where-isC-hwwidenC-xnwwindow-configuration-to-registerC-xrwwrite-fileC-xC-wyank-popM-yyank-rectangleC-xryyank&lt;S-insert&gt;yankC-yzap-to-charM-z��"}],"posts":[{"title":"Python使用Matplotlib作图","slug":"Python使用Matplotlib作图","date":"2021-08-01T12:43:30.000Z","updated":"2021-08-02T02:39:03.443Z","comments":true,"path":"posts/Python使用Matplotlib作图/","link":"","permalink":"http://oi.linkfqy.top/posts/Python使用Matplotlib作图/","excerpt":"","text":"Matplotlib.pyplot将原本面向对象的作图操作封装成函数，使之更近似于MATLAB的交互式命令 只要有离散的数据，就可以做出柱状、散点、饼状、折线、3D图形等可视化图表 柱状图（bar） pyplot.bar()只需提供两个数组作为各数据的横纵坐标，即可生成柱状图 12345678910111213from matplotlib import rcParamsfrom matplotlib.pyplot import *import numpy as npy = np.array((2100, 3000, 4000))x = np.array([1, 2, 3])width = 0.2rc('font', size=16)bar(x, y, width) # 指定柱宽ylabel(\"消费数据\")xticks(x, [\"用户A\", \"用户B\", \"用户C\"], rotation=20) # 将x标签改为用户名，并旋转20度显示rcParams['font.sans-serif'] = ['SimHei'] # 设置中文字体，否则会乱码savefig('bar.png', dpi=500)show() # 显示在屏幕 效果图： 若要显示负号，需rcParams['axes.unicode_minus']=False 散点图（scatter） 与bar类似 123456789from numpy.linalg.linalg import _eigvalsh_dispatcherfrom pylab import * # pylab=pyplot+部分numpy函数x = array(range(1, 8))y = \"27.0 26.5 26.3 26.1 25.7 25.3 24.8\"y = \",\".join(y.split())y = array(eval(y))scatter(x, y, marker='*') # 用星形显示散点savefig(\"scatter.png\", dpi=500)show() 折线图（plot） 基本用法为plot(x,y,s)，前两个参数为数据点的横纵坐标，s为指定线条颜色、线条样式和数据点形状的字符串 也可在同一个坐标内显示多个折线 123456789101112131415import numpy as npfrom matplotlib.pyplot import *x = np.linspace(0, 2*np.pi, 200)y1 = np.sin(x)y2 = np.cos(pow(x, 2))rc('font', size=16)# rc('text', usetex=True) # 可以用LaTeX字体显示plot(x, y1, 'r-', label='$sin(x)$', linewidth=2) # 红色实线plot(x, y2, 'b--', label='$cos(x^2)$') # 蓝色虚线xlabel('$x$')ylabel('$y$', rotation=0) # y标签默认旋转90度rc('legend', loc='lower left') # 图例在左下显示legend()savefig('plot.png', dpi=500)show() 饼状图（pie） 只需一维数组 123456789from matplotlib import rcParamsimport numpy as npfrom matplotlib.pyplot import *a = np.array([124, 45, 72, 87, 11])pie(a, labels=[\"A产品\", \"B产品\", \"C产品\", \"D产品\", \"E产品\"])title(\"销售额分析\")rcParams['font.sans-serif'] = ['SimHei']savefig(\"pie.png\", dpi=500)show() 子窗口（subplot） subplot(nrows, ncols, index) 前两个参数将整个窗口分为nrows*ncols的区域 函数返回从上到下，从左到右的第index个区域（从1开始） 1234567891011121314151617181920import numpy as npfrom matplotlib.pyplot import *x = np.linspace(0, 2*np.pi, 200)y1 = np.sin(x)y2 = np.cos(x)y3 = np.sin(x*x)rc('font', size=16)ax1 = subplot(2, 2, 1) # 创建左上窗口ax1.plot(x, y1, 'r', label='$sin(x)$')legend()ax2 = subplot(2, 2, 2) # 创建右上窗口ax2.plot(x, y2, 'b--', label='$cos(x)$')legend()ax3 = subplot(2, 1, 2) # 创建下方窗口ax3.plot(x, y3, 'k--', label='$sin(x^2)$')legend()savefig('subplot.png', dpi=500)show() 上方的两个窗口分别占据了2*2划分的前两个区域 下方窗口占据了2*1划分的第二个区域 三维曲线（plot3D） 以下代码画出\\(x=t\\sin t,y=t\\cos t,z=t\\)的图形 123456789from matplotlib.pyplot import *import numpy as npax = axes(projection='3d') # 先设置三维模式z = np.linspace(0, 100, 1000)x = np.sin(z)*zy = np.cos(z)*zax.plot3D(x, y, z, 'k')savefig('plot3D.png', dpi=500)show() 三维曲面（plot_surface,plot_wireframe） plot_surface生成表面图形，plot_wireframe生成网格图形 生成三维曲面时，需指定网格坐标（描点坐标） 以下代码画出\\(z=\\sin (\\sqrt{x^2+y^2})\\)的图形 123456789101112131415161718192021from matplotlib.pyplot import *import numpy as npx = np.linspace(-6, 6, 30)y = np.linspace(-6, 6, 30)X, Y = np.meshgrid(x, y) # 生成网格坐标矩阵Z = np.sin(np.sqrt(X**2+Y**2))ax1 = subplot(1, 2, 1, projection='3d')ax1.plot_surface(X, Y, Z, cmap='viridis') # 使用viridis的配色创建表面图形ax1.set_xlabel('x')ax1.set_ylabel('y')ax1.set_zlabel('z')ax2 = subplot(1, 2, 2, projection='3d')ax2.plot_wireframe(X, Y, Z, color='c')ax2.set_xlabel('x')ax2.set_ylabel('y')ax2.set_zlabel('z')savefig('plot_surface.png', dpi=500)show() 等高线图（contour） 123456789from matplotlib.pyplot import *import numpy as npz = np.loadtxt(\"data.txt\") # 从文件导入高程数据x = np.arange(0, 1500, 100)y = np.arange(1200, -10, -100)contr = contour(x, y, z)clabel(contr) # 标注高度savefig('contour.png', dpi=500)show() 向量图（quiver） 以下代码画出向量场\\(\\vec A=(y\\cos x,y\\sin x)\\) quiver(x, y, vx, vy)分别接收两个网格坐标矩阵，以及向量场的xy分量 12345678910from matplotlib.pyplot import *import numpy as npx = np.linspace(0, 15, 11)y = np.linspace(0, 10, 12)x, y = np.meshgrid(x, y)vx = y*np.cos(x)vy = y*np.sin(x)quiver(x, y, vx, vy)savefig('quiver.png', dpi=500)show()","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://oi.linkfqy.top/tags/Python/"}]},{"title":"LitePal使用指南","slug":"LitePal使用指南","date":"2021-05-03T09:19:42.000Z","updated":"2021-05-03T09:19:47.991Z","comments":true,"path":"posts/LitePal使用指南/","link":"","permalink":"http://oi.linkfqy.top/posts/LitePal使用指南/","excerpt":"","text":"LitePal使用指南 我们项目中只涉及轻量级的数据库操作，因此使用LitePal中封装好的接口可以大大简化操作 建议全程使用LitePal进行开发 github地址 配置环境 注意：以下有些步骤是我已经完成的，请务必先将本地工程更新至仓库中的最新版本 在app/build.gradle中添加对LitePal的引用： 123dependencies &#123; implementation 'org.litepal.guolindev:core:3.2.3'&#125; 注意使用最新版本3.2.3 在assets中创建litepal.xml： 12345678&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;litepal&gt; &lt;dbname value=\"main\" /&gt; &lt;version value=\"1\" /&gt; &lt;list&gt; &lt;mapping class=\"com.hitsz.eazytime.model.Todo\" /&gt; &lt;/list&gt;&lt;/litepal&gt; 其中dbname指定数据库名，version指定数据库版本（增减数据表、增减数据表字段、改变字段类型等操作都必须增加版本号） 在list中使用mapping标签关联每个数据表 在AndroidManifest.xml配置： 12345678&lt;manifest&gt; &lt;application android:name=\"org.litepal.LitePalApplication\" ... &gt; ... &lt;/application&gt;&lt;/manifest&gt; 创建数据表 LitePal将数据表和java类一一对应，因此对对象的操作就很容易转化成对数据表的操作 在com.hitsz.eazytime.model包下新增一个java文件用于定义类： 1234567891011121314151617181920212223242526272829303132333435363738public class Todo extends LitePalSupport &#123; private String title; private Date startTime; private Date endTime; int id; public Todo()&#123; //构造函数 &#125; public String getTitle() &#123; return title; &#125; public void setTitle(String title) &#123; this.title = title; &#125; public Date getStartTime() &#123; return startTime; &#125; public void setStartTime(Date startTime) &#123; this.startTime = startTime; &#125; public Date getEndTime() &#123; return endTime; &#125; public void setEndTime(Date endTime) &#123; this.endTime = endTime; &#125; public int getId() &#123; return id; &#125;&#125; LitePal支持的数据类型一共有8种：int、short、long、float、double、boolean、String、Date id字段：无论类中定义与否，数据表里都会存在，且作为自增主键使用，但在类中定义id及getId可以方便查询 代码规范：类中的所有成员必须以private定义，取值和修改必须经过get和set函数 注意：新版本LitePal的数据表类应当继承自LitePalSupport而非DataSupport 注意：修改了类的定义后，请务必增加数据库的版本号，否则对类的更改无法应用至数据库 增查删改 这部分在《第一行代码》和作者博客里有较详细的介绍，这里有重点地讲一下 增 一般new一个新的对象出来，然后save就可以了 12Todo todo=new Todo(...);todo.save(); 查 注意：新版的查询使用LitePal而非DataSupport 1List&lt;Todo&gt; todos = LitePal.select(...).where(...).order(...).limit(...).offset(...).find(Todo.class) 以上连缀无固定顺序，也可不写其中的某些连缀 注：LitePal本身支持关联表的激进查询，但不推荐使用，合理的写法是在类中实现一个返回关联字段的函数，详细请看作者博客 删 没什么要说的，见作者博客 改 没什么要说的，见作者博客","categories":[{"name":"Android","slug":"Android","permalink":"http://oi.linkfqy.top/categories/Android/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://oi.linkfqy.top/tags/数据库/"}]},{"title":"简易版git教程","slug":"简易版Git教程","date":"2021-03-30T14:07:25.000Z","updated":"2021-03-30T14:25:24.253Z","comments":true,"path":"posts/简易版Git教程/","link":"","permalink":"http://oi.linkfqy.top/posts/简易版Git教程/","excerpt":"","text":"简易版git教程 这是写给大一立项小组成员看的简易版git教程 我们做这个项目只需要一些基本的git命令就可以了，因此这里教大家10min速成git 准备工作 GitHub和git的关系 git是版本管理工具，适合多人合作，储存代码的地方叫做仓库，仓库可以在本地，也可以在学校的服务器上，GitHub是个托管仓库的网站，大家经常把代码放在GitHub上 在这里下载并安装git，看不懂就一直点next就行 git是一个命令行工具，要使用它只能敲对应的命令 下面介绍的命令均在对应目录下的命令行中执行 如何在当前目录下打开命令行？ 如图在任务管理器路径前敲CMD即可 git clone clone是将网络上的仓库克隆到本地的操作 1git clone \"https://github.com/linkfqy/EazyTime.git\" 上面的命令将我们项目的工程文件clone至当前目录 当前目录会生成一个EazyTime文件夹即工程文件夹，打开它并重新打开命令行，后续命令均在此文件夹中进行 clone到本地后，你就可以对工程文件进行编辑了，可以任意增加想要的功能 git add 一般来说，我们只希望自己工作的那部分文件能够更新到仓库，而无关紧要的修改不应影响他人 因此需要对工作文件进行add add命令将指定的文件或目录添加至本地的暂存区，只有add过的文件才能被提交，add过的文件还可以修改，也可以再次add，最终提交的文件以最后一次add的版本为准 如： 1git add \"README.md\" 以上命令将README.md文件添加至本地的暂存区 1git add \"app\\src\\main\\java\" 以上命令将app\\src\\main\\java整个文件夹添加至本地的暂存区 1git add * 以上命令将所有文件添加至本地的暂存区 注意：不要随意使用以上命令！因为这会将你对工程做的所有修改（而非仅属于你的那部分工作）都添加！一旦push，会对所有人共用的仓库产生影响！ 合适的做法是，仅add自己工作所属的目录，如： 1git add \"app\\src\\main\\java\\com\\hitsz\\eazytime\\ui\\todo\" git status git status命令用于显示工作目录和暂存区的状态。 使用此命令能看到哪些修改被暂存到了, 哪些没有，哪些文件还没被add。git status不显示已经commit到项目历史中去的信息。 “Changes to be committed”所列的是已add过的文件版本 “Changed but not updated”所列的是add过但被修改，尚未再次add的文件 “Untracked files”中所列的是尚未add的文件 12345678Changes to be committed: (use \"git restore --staged &lt;file&gt;...\" to unstage) modified: README.mdChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git restore &lt;file&gt;...\" to discard changes in working directory) modified: README.md 以上表示README.md被add过一个版本，但之后又修改过，可以再次add以添加新的版本 同时也提示你： 想要舍弃已add的版本，使用git restore --staged &quot;README.md&quot;命令 想要还原对README.md的修改，使用git restore &quot;README.md&quot;将文件变为最后一次add的版本 git commit commit命令将暂存区的内容添加到本地仓库中 1git commit -m \"message\" 上面的message是对此次提交的注释，可以写点关于这次提交干了啥的解释 git push 终于到了最后一步，将本地所作的修改提交至GitHub上的仓库 注意：之前的操作都是本地的，不push大家是看不到你的工作的 1git push 一句话将本地仓库提交至GitHub 如果想要提交对应分支，则： 1git push origin main 将本地的main分支提交至GitHub 第一次push可能会弹出登录窗口，登录github账号就可以正常提交了","categories":[{"name":"杂","slug":"杂","permalink":"http://oi.linkfqy.top/categories/杂/"}],"tags":[{"name":"git","slug":"git","permalink":"http://oi.linkfqy.top/tags/git/"}]},{"title":"EazyTime开发笔记","slug":"EazyTime","date":"2021-03-29T15:12:08.000Z","updated":"2021-03-30T14:15:00.600Z","comments":true,"path":"posts/EazyTime/","link":"","permalink":"http://oi.linkfqy.top/posts/EazyTime/","excerpt":"","text":"","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[]},{"title":"Python学习笔记","slug":"Python学习笔记","date":"2021-03-25T15:35:00.000Z","updated":"2021-03-27T02:33:17.483Z","comments":true,"path":"posts/Python学习笔记/","link":"","permalink":"http://oi.linkfqy.top/posts/Python学习笔记/","excerpt":"","text":"3.25 今天遇到了这样一个问题： 12345678910111213141516171819202122class ListNode: def __init__(self, val=0, next=None): self.val = val self.next = next def set(self, L): self=ListNode(val=L[0]) now = self for x in L[1:]: now.next = ListNode(val=x) now = now.next def print(self): now = self while (now != None): print('%d ' % (now.val)) now = now.next print('\\n') a=ListNode()a.set([1,2,3])a.print() # 输出0 可见，a.set()并没有改变a的值，不得其解 看了这篇文章 豁然开朗，之前理解有误的原因是自动把C++的赋值与Python混淆了 Python的变量，其实是C++意义上的指针 下面摘录几段： 构造函数返回指针 Python 的构造函数将构造匿名对象，且返回此对象的一个指针。 这是 Python 与指针的第一个重要联系。 用代码描述，对于Python代码： 1sampleNum = 0 其不类似于 C++ 代码： 1int sampleNum = 0; 而更类似于： 1234int __tmpNum = 0, *sampleNum = &amp;__tmpNum;// 或者：shared_ptr&lt;int&gt; sampleNum(new int(0)); __setitems__操作将隐式解指针 Python 与指针的另一个重要联系在于 Python 的隐式解指针行为。 虽然 Python 不存在显式解指针操作，但（有且仅有）__setitems__操作将进行隐式解指针，通过此方法对变量进行修改等同于通过解指针操作修改变量原值。 此种性质意味着： 任何不涉及__setitems__的操作都将成为指针重绑定。 对于Python代码： 1234numList = [None] * 10# RebindingnumList = [None] * 5 其相当于： 123456int *numList = new int[10];// Rebindingdelete[] numList;numList = new int[5];delete[] numList; 由此可见，对 numList 的非__setitems__操作，导致 numList 被绑定到了一个新指针上。 任何涉及__setitems__的操作都将成为解指针操作。 由于 Python 对哈希表的高度依赖，“涉及__setitems__的操作”在 Python 中实际上是一个非常广泛的行为，这主要包括： 对数组的索引操作 对哈希表的查找操作 涉及__setattr__的操作（由于 Python 将 attribute 存储在哈希表中，所以__setattr__操作最终将是某种__setitems__操作） 于是，将set()改为这样： 1234567def set(self, L): self.val = L[0] # self=ListNode(val=L[0]) self.next = None now = self for x in L[1:]: now.next = ListNode(val=x) now = now.next 就解决了问题 self是默认将实例本身传入的参数，根据上文，实际传入的是实例的指针，而self=ListNode(val=L[0])将self重新绑定至一个新建的节点，那么后续进行的操作就与原实例无关了","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://oi.linkfqy.top/tags/Python/"}]},{"title":"【最大权闭合子图】LOJ6045 「雅礼集训 2017 Day8」价","slug":"LOJ6045","date":"2018-11-25T11:48:02.000Z","updated":"2018-11-25T12:09:24.000Z","comments":true,"path":"posts/LOJ6045/","link":"","permalink":"http://oi.linkfqy.top/posts/LOJ6045/","excerpt":"","text":"题面在这里 ​ 很明显是最大权闭合子图的模型 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=605,maxe=200005,inf=0x3f3f3f3f,INF=0x7fffffff;int n,S,T;int tot,son[maxe],nxt[maxe],lnk[maxn];ll flw[maxe],cap[maxe];inline void add(int x,int y,int f)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int que[maxn],d[maxn],pos[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; que[1]=S;d[S]=0; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==inf&amp;&amp;flw[j]&lt;cap[j]) d[que[++til]=son[j]]=d[x]+1; &#125; return d[T]!=inf;&#125;ll dfs(int x,ll flow)&#123; if (x==T||flow==0) return flow; ll f=0,res=0; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f;flw[j^1]-=f; res+=f,flow-=f; if (flow==0) return res; &#125; return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); S=2*n+1,T=S+1;tot=1; for (int i=1;i&lt;=n;i++)&#123; int t;scanf(\"%d\",&amp;t); for (int j=1,x;j&lt;=t;j++) scanf(\"%d\",&amp;x),add(i,x+n,INF); add(i+n,T,inf); &#125; ll ans=0; for (int i=1,pi;i&lt;=n;i++) scanf(\"%d\",&amp;pi),add(S,i,-pi+inf),ans-=inf-pi; while (bfs())&#123; memcpy(pos,lnk,sizeof(lnk)); ans+=dfs(S,INF); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","permalink":"http://oi.linkfqy.top/tags/最大权闭合子图/"},{"name":"LOJ","slug":"LOJ","permalink":"http://oi.linkfqy.top/tags/LOJ/"}]},{"title":"【莫队+bitset】BZOJ4810 [Ynoi2017]由乃的玉米田","slug":"BZOJ4810","date":"2018-11-22T22:52:00.000Z","updated":"2018-11-22T23:03:06.000Z","comments":true,"path":"posts/BZOJ4810/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4810/","excerpt":"","text":"题面在这里 ​ 直接莫队……用bitset维护出现过哪些值 \\[ a-b=x\\Leftrightarrow a=b+x \\\\ a+b=x\\Leftrightarrow a=-(b-x) \\] 对于操作1，bitset左移x位后对自己取并 对于操作2，需要同时维护一个所有值的相反数的bitset，同1 对于操作3，直接爆枚因子即可 时间复杂度\\(O(n\\sqrt n)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;bitset&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;int n,q,a[maxn],h[maxn];struct Query&#123; int t,l,r,x,id; bool operator&lt;(const Query&amp;b)const&#123; if (h[l]==h[b.l]) return r&lt;b.r; return l&lt;b.l; &#125;&#125;Q[maxn];void blocker()&#123; int k=sqrt(n); for (int i=1;i&lt;=n;i++) h[i]=i/k;&#125;bitset&lt;maxn*2&gt; A,B;int cnt[maxn*2];void add(int x)&#123; if (!cnt[x]) A[x+100000]=1; if (!cnt[x]) B[100000-x]=1; cnt[x]++;&#125;void dec(int x)&#123; cnt[x]--; if (!cnt[x]) A[x+100000]=0; if (!cnt[x]) B[100000-x]=0;&#125;bool ans[maxn];int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); blocker(); for (int i=1;i&lt;=q;i++) Q[i].t=red(),Q[i].l=red(),Q[i].r=red(),Q[i].x=red(),Q[i].id=i; sort(Q+1,Q+1+q); int L=1,R=1; add(a[1]); for (int i=1;i&lt;=q;i++)&#123; while (Q[i].l&lt;L) add(a[--L]); while (R&lt;Q[i].r) add(a[++R]); while (L&lt;Q[i].l) dec(a[L++]); while (Q[i].r&lt;R) dec(a[R--]); if (Q[i].t==1)&#123; ans[Q[i].id]=(A&amp;(A&lt;&lt;Q[i].x)).any(); &#125;else if (Q[i].t==2)&#123; ans[Q[i].id]=(A&amp;(B&lt;&lt;Q[i].x)).any(); &#125;else&#123; for (int d=1,td=sqrt(Q[i].x);d&lt;=td;d++) if (Q[i].x%d==0&amp;&amp;cnt[Q[i].x/d]&amp;&amp;cnt[d]) &#123;ans[Q[i].id]=1;break;&#125; &#125; &#125; for (int i=1;i&lt;=q;i++) puts(ans[i]?\"yuno\":\"yumi\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://oi.linkfqy.top/tags/莫队/"}]},{"title":"【二分图博弈】LOJ6033 「雅礼集训 2017 Day2」棋盘游戏","slug":"LOJ6033","date":"2018-11-22T09:37:58.000Z","updated":"2018-11-22T10:01:44.000Z","comments":true,"path":"posts/LOJ6033/","link":"","permalink":"http://oi.linkfqy.top/posts/LOJ6033/","excerpt":"","text":"题面在这里 ​ 显然可以把整个图黑白染色，得到一个二分图 考虑二分图最大匹配，如果初始点是未匹配点，则Bob只能走未匹配边到一个匹配点，而Alice一定可以沿匹配边走回左边的匹配点，由于不能往回走，此时的情形与初始状态一样，最终Bob输 如果初始点是匹配点，此时Bob走的是匹配边，Alice走未匹配边，如果最后能走回左边则Alice赢，否则Bob赢。其实他们走的是增广路，Alice能赢当且仅当初始点不一定是匹配点 所以答案是所有【不一定是匹配点】的点 具体做法是从左边未匹配点出发，沿增广路遍历到的所有左边点都是答案 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=10005,maxe=40005,p[4][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;int n,m,N,id[105][105];char a[105][105];int tot,son[maxe],lnk[maxn],nxt[maxe];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int vis[maxn],times,con[maxn];bool fnd(int x)&#123; if (vis[x]==times) return 0; vis[x]=times; for (int j=lnk[x];j;j=nxt[j])&#123; int k=con[son[j]];con[son[j]]=x; if (!k||fnd(k)) return 1; con[son[j]]=k; &#125; return 0;&#125;bool ans[maxn][maxn];void dfs(int x)&#123; vis[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!vis[con[son[j]]]) dfs(con[son[j]]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%s\",a[i]+1); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='.') id[i][j]=++N; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='.') for (int t=0;t&lt;4;t++)&#123; int ii=i+p[t][0],jj=j+p[t][1]; if (ii&lt;1||jj&lt;1||ii&gt;n||jj&gt;m||a[ii][jj]=='#') continue; add(id[i][j],id[ii][jj]); &#125; int num=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='.'&amp;&amp;((i+j)&amp;1)) times++,num+=fnd(id[i][j]); if (num*2==N) return puts(\"0\"),0; for (int i=1;i&lt;=N;i++) con[con[i]]=i; cl(vis,0); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='.'&amp;&amp;!vis[id[i][j]]) if (!con[id[i][j]]) dfs(id[i][j]); int ANS=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (vis[id[i][j]]) ANS++,ans[i][j]=1; printf(\"%d\\n\",ANS); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (ans[i][j]) printf(\"%d %d\\n\",i,j); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"博弈论","slug":"博弈论","permalink":"http://oi.linkfqy.top/tags/博弈论/"},{"name":"LOJ","slug":"LOJ","permalink":"http://oi.linkfqy.top/tags/LOJ/"}]},{"title":"LOJ6030 「雅礼集训 2017 Day1」矩阵","slug":"LOJ6030","date":"2018-11-16T12:47:02.000Z","updated":"2018-11-16T12:48:42.000Z","comments":true,"path":"posts/LOJ6030/","link":"","permalink":"http://oi.linkfqy.top/posts/LOJ6030/","excerpt":"","text":"题面在这里 ​ 直接乱搞即可 ​ 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,x[maxn],y[maxn];char s[maxn];int main()&#123; scanf(\"%d\",&amp;n); bool suc=0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",s+1); for (int j=1;j&lt;=n;j++) if (s[j]=='#') suc=1,x[i]++,y[j]++; &#125; if (!suc) return puts(\"-1\"),0; int ans=n*n; for (int i=1;i&lt;=n;i++) ans=min(ans,n-x[i]+!y[i]); for (int i=1;i&lt;=n;i++) if (y[i]!=n) ans++; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"LOJ","slug":"LOJ","permalink":"http://oi.linkfqy.top/tags/LOJ/"}]},{"title":"【线段树+势能分析】LOJ6029 「雅礼集训 2017 Day1」市场","slug":"LOJ6029","date":"2018-11-16T09:52:29.000Z","updated":"2018-11-16T10:09:08.000Z","comments":true,"path":"posts/LOJ6029/","link":"","permalink":"http://oi.linkfqy.top/posts/LOJ6029/","excerpt":"","text":"题面在这里 ​ 考虑一个区间除后变化量如果都相同，就转化为区间减了 维护最大值和最小值即可判断 复杂度证明： 考虑两个数\\(a,b\\)，差是\\(a-b\\)，除以\\(d\\)后差是\\(\\frac{a-b}d\\) 也就是说两个数被除\\(\\log\\)次就相等了 令一个线段树节点的势能为\\(\\log(Max-Min)\\) 操作2就相当于把区间内所有势能不为1的节点势能-1，代价为势能减小总量 操作1会将\\(\\log\\)个节点的势能恢复为\\(\\log(Max-Min)\\) 总时间复杂度为整个过程中产生的势能总量\\(O((n+q\\log n)\\log a_i)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005,maxs=400005;int n,q,a[maxn];ll mx[maxs],mn[maxs],s[maxs],ad[maxs],len[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x) &#123;s[x]=s[ls]+s[rs];mx[x]=max(mx[ls],mx[rs]);mn[x]=min(mn[ls],mn[rs]);&#125;inline void addad(int x,int w) &#123;mx[x]+=w;mn[x]+=w;ad[x]+=w;s[x]+=len[x]*w;&#125;inline void pushdown(int x)&#123; if (ad[x]) addad(ls,ad[x]),addad(rs,ad[x]),ad[x]=0;&#125;void build(int x,int l,int r)&#123; ad[x]=0; len[x]=r-l+1; if (l==r) return mx[x]=mn[x]=s[x]=a[l],void(); int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); pushup(x);&#125;void istad(int x,int l,int r,int ql,int qr,int w)&#123; if (qr&lt;l||r&lt;ql) return; if (ql&lt;=l&amp;&amp;r&lt;=qr) return addad(x,w); int mid=l+r&gt;&gt;1; pushdown(x); istad(ls,l,mid,ql,qr,w);istad(rs,mid+1,r,ql,qr,w); pushup(x);&#125;void istdv(int x,int l,int r,int ql,int qr,int d)&#123; if (qr&lt;l||r&lt;ql) return; if (ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;floor(1.0*mx[x]/d)-mx[x]==floor(1.0*mn[x]/d)-mn[x]) return addad(x,floor(1.0*mn[x]/d)-mn[x]); int mid=l+r&gt;&gt;1; pushdown(x); istdv(ls,l,mid,ql,qr,d);istdv(rs,mid+1,r,ql,qr,d); pushup(x);&#125;ll qrymn(int x,int l,int r,int ql,int qr)&#123; if (qr&lt;l||r&lt;ql) return 1e18; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mn[x]; int mid=l+r&gt;&gt;1; pushdown(x); return min(qrymn(ls,l,mid,ql,qr),qrymn(rs,mid+1,r,ql,qr));&#125;ll qrys(int x,int l,int r,int ql,int qr)&#123; if (qr&lt;l||r&lt;ql) return 0; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; int mid=l+r&gt;&gt;1; pushdown(x); return qrys(ls,l,mid,ql,qr)+qrys(rs,mid+1,r,ql,qr);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); build(1,1,n); while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1)&#123; int l,r,w;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;w);l++,r++; istad(1,1,n,l,r,w); &#125;else if (c==2)&#123; int l,r,w;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;w);l++,r++; istdv(1,1,n,l,r,w); &#125;else if (c==3)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r);l++,r++; printf(\"%lld\\n\",qrymn(1,1,n,l,r)); &#125;else&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r);l++,r++; printf(\"%lld\\n\",qrys(1,1,n,l,r)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"LOJ","slug":"LOJ","permalink":"http://oi.linkfqy.top/tags/LOJ/"}]},{"title":"【施工ing】模板合集","slug":"Template","date":"2018-11-09T08:54:43.000Z","updated":"2018-11-09T13:11:06.000Z","comments":true,"path":"posts/Template/","link":"","permalink":"http://oi.linkfqy.top/posts/Template/","excerpt":"考前背板就看这里了","text":"考前背板就看这里了 数据结构 传统数据结构 线段树 线段树动态开点/线段树合并 BZOJ2733 123456789101112131415161718int Rot[maxn],len,tre[maxs],ls[maxs],rs[maxs];inline void pushup(int x) &#123;tre[x]=tre[ls[x]]+tre[rs[x]];&#125;inline int newnode(int _ls,int _rs,int _s) &#123;ls[++len]=_ls,rs[len]=_rs,tre[len]=_s;return len;&#125;void ist(int &amp;x,int l,int r,int k)&#123; if (!x) x=newnode(0,0,0); if (l==r) &#123;tre[x]++;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k); else ist(rs[x],mid+1,r,k); pushup(x);&#125;int merge(int x,int y)&#123; //此处为节省空间，直接把合并后的信息储存在x节点了，合并其他信息要小心 if (!x||!y) return x+y; ls[x]=merge(ls[x],ls[y]); rs[x]=merge(rs[x],rs[y]); tre[x]=tre[x]+tre[y]; return x;&#125; 可持久化线段树/主席树 POJ2104 1234567891011121314151617181920212223int Rot[maxn],tre[maxs],s[maxs][2],len;inline void pushup(int x) &#123;tre[x]=tre[s[x][0]]+tre[s[x][1]];&#125;int build(int l,int r)&#123; int x=++len; tre[x]=0; if (l==r) &#123;s[x][0]=s[x][1]=0;return x;&#125; int mid=l+r&gt;&gt;1; s[x][0]=build(l,mid); s[x][1]=build(mid+1,r); return x;&#125;int ist(int fa,int l,int r,int k)&#123; int x=++len; tre[x]=tre[fa];s[x][0]=s[fa][0];s[x][1]=s[fa][1]; if (l==r) return tre[x]++,x; int mid=l+r&gt;&gt;1; if (k&lt;=mid) s[x][0]=ist(s[fa][0],l,mid,k); else s[x][1]=ist(s[fa][1],mid+1,r,k); return pushup(x),x;&#125;int qry(int x,int y,int l,int r,int k)&#123; if (l==r) return l; int mid=l+r&gt;&gt;1,tem; if ((tem=tre[s[y][0]]-tre[s[x][0]])&gt;=k) return qry(s[x][0],s[y][0],l,mid,k); else return qry(s[x][1],s[y][1],mid+1,r,k-tem);&#125; 可并堆 随机堆太好用了 123456789101112int merge(int a,int b)&#123; if (!a||!b) return a+b; if (key[a]&gt;key[b]) swap(a,b); pushdown(a); if (rand()&amp;1) ls[a]=merge(ls[a],b);else rs[a]=merge(rs[a],b); return a;&#125;int del(int a)&#123; if (!a) return 0; pushdown(a); return merge(ls[a],rs[a]);&#125; 图相关数据结构 并查集 路径压缩： 1inline int getfa(int x) &#123;return x==fa[x]:x:fa[x]=getfa(fa[x]);&#125; 按秩合并+撤销： 123456789101112131415161718int fa[maxn],rk[maxn],rkk[maxq],X[maxq],Y[maxq],len;inline void init()&#123; len=0; for (int i=1;i&lt;=n;i++) fa[i]=i,rk[i]=1;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:getfa(fa[x]);&#125;inline void merge(int x,int y)&#123; x=getfa(x);y=getfa(y); if (x==y) return; if (rk[x]&lt;rk[y]) swap(x,y); ++len; X[len]=x;Y[len]=y; rkk[len]=rk[x]; rk[x]=max(rk[x],rk[y]+1); fa[y]=x;&#125;inline void undo()&#123; rk[X[len]]=rkk[len]; fa[Y[len]]=Y[len]; len--;&#125; 树链剖分 板子题：BZOJ1036 1234567891011121314151617181920212223242526272829303132333435int H_son[maxn],siz[maxn],fa[maxn],dep[maxn],in[maxn],out[maxn],top[maxn],times;void getH(int x)&#123; siz[x]=1;dep[x]=dep[fa[x]]+1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x; getH(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst;in[x]=++times;id[times]=x; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;void insert(int x,int y,int w)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); ist(1,1,N,in[top[x]],in[x],w); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); ist(1,1,N,in[x],in[y],w); //ist(1,1,N,in[x]+1,in[y],w); 维护边权&#125;int query(int x,int y)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=max(res,qry(1,1,N,in[top[x]],in[x])); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); return max(res,qry(1,1,N,in[x],in[y])); //return max(res,qry(1,1,N,in[x]+1,in[y])); 维护边权&#125; LCT 板子题：BZOJ2631 1234567891011121314151617181920212223242526272829303132333435int s[maxn][2],fa[maxn];bool flp[maxn];#define isroot(x) (s[fa[x]][0]!=x&amp;&amp;s[fa[x]][1]!=x)inline void addflip(int x) &#123;swap(s[x][0],s[x][1]);flp[x]^=1;&#125;inline void pushup(int x) &#123;/* do something */&#125;inline void pushdown(int x) &#123;if (flp[x]) flp[x]^=1,addflip(s[x][0]),addflip(s[x][1]);&#125;inline void rotate(int x)&#123; int f=fa[x],g=fa[f],d=s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; pushup(f); s[x][d]=f; fa[f]=x; pushup(x);&#125;int top,stk[maxn];inline void splay(int x)&#123; stk[top=1]=x; for (int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x))&#123; int f=fa[x],g=fa[f],d=s[f][0]==x,dd=s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x);else rotate(x),rotate(x); else rotate(x); &#125;&#125;inline void access(int x) &#123;for (int t=0;x;t=x,x=fa[x]) splay(x),s[x][1]=t,pushup(x);&#125;inline void mr(int x) &#123;access(x),splay(x),addflip(x);&#125;inline void join(int x,int y) &#123;mr(x);fa[x]=y;&#125;inline void cut(int x,int y) &#123;mr(x),access(y),splay(y);if (s[y][0]==x) fa[x]=s[y][0]=0;&#125;inline int getrt(int x) &#123;access(x),splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125; //!!!//...if (getrt(x)!=getrt(y)) join(x,y); //加边 cut(x,y); //删边mr(x);access(x); //修改x的点权mr(x);access(y);splay(x); //获取(x,y)路径的信息 图论 最短路 SPFA 1234567891011121314151617int dst[maxn],que[maxn];int vis[maxn];void spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=1;dst[1]=0;vis[1]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125;&#125; Dijkstra 12345678910111213141516171819ll dst[maxn]; bool vis[maxn];struct data&#123; ll d;int id; data () &#123;&#125; data (int _id,ll _d):id(_id),d(_d) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return d&gt;b.d;&#125;&#125;;priority_queue&lt;data&gt; H;void DIJ()&#123; cl(dst,63); dst[1]=0;H.push(data(1,0)); while (!H.empty())&#123; data k=H.top();H.pop(); if (vis[k.id]) continue; vis[k.id]=1;if (k.id==n) return; for (int j=lnk[k.id];j;j=nxt[j]) if (!vis[son[j]]&amp;&amp;dst[son[j]]&gt;dst[k.id]+w[j]) dst[son[j]]=dst[k.id]+w[j],H.push(data(son[j],dst[son[j]])); &#125;&#125; 网络流 最大流 BZOJ1066 12345678910111213141516171819202122232425262728293031323334353637int tot,son[maxe],nxt[maxe],pos[maxn],lnk[maxn],flw[maxe],cap[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int d[maxn],que[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; d[S]=0;que[1]=S; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==INF&amp;&amp;flw[j]&lt;cap[j]) que[++til]=son[j],d[son[j]]=d[x]+1; &#125; return d[T]!=INF;&#125;int dfs(int x,int flow)&#123; if (x==T||flow==0) return flow; ll res=0,f; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f; flw[j^1]-=f; res+=f; flow-=f; if (flow==0) break; //!!!!!!! &#125; return res;&#125;//.....tot=1; add();ans=0;while (bfs())&#123; memcpy(pos,lnk,sizeof(lnk)); ans+=dfs(S,INF);&#125; 最小费用最大流 1234567891011121314151617181920212223242526272829303132int tot,son[maxe],nxt[maxe],lnk[maxn],flw[maxe],cap[maxe],w[maxe];inline void add(int x,int y,int f,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;int que[maxn],dst[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(vis,0);cl(dst,63); int hed=0,til=1;que[1]=S;dst[S]=0;fa[S]=0; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (flw[j]&lt;cap[j]&amp;&amp;dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; fa[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125; return dst[T]!=INF;&#125;//......tot=1; //!!!//addedge......int ans=0;while (spfa()&amp;&amp;dst[T]&gt;0)&#123; int Min=INF; for (int x=T;x!=S;x=fa[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=fa[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; ans+=Min*dst[T];&#125; 二分图 二分图最大匹配 Hungary算法 123456789101112131415int times,vis[maxn],con[maxn];bool find(int x)&#123; if (vis[x]==times) return 0; vis[x]=times; for (int j=lnk[x];j;j=nxt[j])&#123; int k=con[son[j]];con[son[j]]=x; if (!k||find(k)) return 1; con[son[j]]=k; &#125; return 0;&#125;//....int ans=0;for (int i=1;i&lt;=N;i++) times++,ans+=find(i); 强连通分量 HDU1269 Tarjan 1234567891011121314int dfn[maxn],low[maxn],stk[maxn],SCC[maxn],times;bool instk[maxn];void Tarjan(int x)&#123; dfn[x]=low[x]=++times;instk[stk[++stk[0]]=x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]); else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (dfn[x]==low[x])&#123; SCC[0]++; while (stk[stk[0]]!=x) instk[stk[stk[0]]]=0,SCC[stk[stk[0]--]]=SCC[0]; instk[stk[stk[0]]]=0,SCC[stk[stk[0]--]]=SCC[0]; &#125;&#125; 双联通分量 直接看这个 差分约束系统 直接看这个 BZOJ2330 虚树 BZOJ2286 12345678910111213void insert(int x)&#123; if (!top) &#123;stk[++top]=x;return;&#125; int lca=LCA(x,stk[top]); while (top&gt;1&amp;&amp;dfn[stk[top-1]]&gt;dfn[lca]) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; if (dfn[stk[top]]&gt;dfn[lca]) add(lca,stk[top],dst(lca,stk[top])),top--; if (!top||dfn[stk[top]]&lt;dfn[lca]) stk[++top]=lca; stk[++top]=x;&#125;//......sort(h+1,h+1+K,cmp); tot=top=0;for (int i=1;i&lt;=K;i++) insert(h[i]);while (top&gt;1) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; dsu on tree Codeforces 600E 123456789101112void change(int x,int w)&#123; 记录x的贡献 for (int j=lnk[x];j;j=nxt[j]) if (!xH[son[j]]) change(son[j],w);&#125;void dsu(int x,bool keep)&#123; for 每个轻儿子 dsu(son,0); dsu(H_son[x],1); xH[H_son[x]]=1; change(x,1); xH[H_son[x]]=0; 更新x的答案 if (!keep) change(x,-1);&#125; 字符串相关 KMP 1234567891011121314nxt[1]=0;for (int i=2,j=0;i&lt;=n;i++)&#123; while (j&gt;0&amp;&amp;B[j+1]!=B[i]) j=nxt[j]; if (B[j+1]==B[i]) j++; nxt[i]=j;&#125;for (int i=1,j=0;i&lt;=n;i++)&#123; while (j&gt;0&amp;&amp;B[j+1]!=A[i]) j=nxt[j]; if (B[j+1]==A[i]) j++; if (j==m)&#123; //do something…… j=nxt[j]; &#125;&#125; 后缀数组 板子题：UOJ#35 12345678910111213141516171819202122232425262728int n,m,buc[maxn],sa[maxn],rk[maxn*2],t[maxn],ht[maxn];char s[maxn];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1,p=0;k&lt;n&amp;&amp;p&lt;n;k&lt;&lt;=1,m=p)&#123; p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(t)); &#125; for (int i=1,h=0;i&lt;=n;i++)&#123; if (h) h--; int j=sa[rk[i]-1]; while (s[i+h]==s[j+h]) h++; ht[rk[i]]=h; &#125;&#125; 数学相关 FFT 板子题：UOJ#34 12345678910111213141516171819202122232425struct comp&#123; double r,i; comp (double _r=0,double _i=0):r(_r),i(_i) &#123;&#125; comp operator+(const comp&amp;b) &#123;return comp(r+b.r,i+b.i);&#125; comp operator-(const comp&amp;b) &#123;return comp(r-b.r,i-b.i);&#125; comp operator*(const comp&amp;b) &#123;return comp(r*b.r-i*b.i,r*b.i+i*b.r);&#125; comp operator/(const double&amp;b) &#123;return comp(r/b,r/b);&#125;&#125;a[maxn],b[maxn],c[maxn];int rev[maxn];inline void get_rev(int n)&#123; rev[0]=0; int l=log2(n); for (int i=1;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125;void FFT(comp *a,int n,int d)&#123; for (int i=0;i&lt;n;i++) if (rev[i]&lt;i) swap(a[i],a[rev[i]]); for (int l=2;l&lt;=n;l&lt;&lt;=1)&#123; comp wl(cos(2*PI/l),d*sin(2*PI/l)); for (int k=0;k&lt;n;k+=l)&#123; comp w(1,0),_t,_T; for (int j=0,tj=l&gt;&gt;1;j&lt;tj;j++,w=w*wl) _t=a[k+j],_T=w*a[k+j+tj],a[k+j]=_t+_T,a[k+j+tj]=_t-_T; &#125; &#125; if (d&lt;0) for (int i=0;i&lt;n;i++) a[i]=a[i]/n;&#125; 其他 莫队算法 BZOJ2038 莫队一定要先移R指针！不然有可能会出现L&gt;R，询问函数写得不好就炸了 12345678910111213141516171819202122inline void blocker()&#123; int k=sqrt(n); for (int i=1;i&lt;=n;i++) h[i]=(i-1)/k+1;&#125;struct data&#123; int l,r,id; bool operator&lt;(const data&amp;b)const&#123; if (h[l]==h[b.l]) return r&lt;b.r; return l&lt;b.l; &#125;&#125;a[maxn];//......blocker();sort(a+1,a+1+q);int L=1,R=0;for (int i=1;i&lt;=q;i++)&#123; while (R&lt;a[i].r) insert(++R); while (R&gt;a[i].r) del(R--); while (L&gt;a[i].l) insert(--L) while (L&lt;a[i].l) del(L++); ans[a[i].id]=now;&#125;","categories":[{"name":"实用","slug":"实用","permalink":"http://oi.linkfqy.top/categories/实用/"}],"tags":[]},{"title":"【启发式分裂】BZOJ4059 [Cerc2012]Non-boring sequences","slug":"BZOJ4059","date":"2018-11-07T10:50:02.000Z","updated":"2018-11-07T10:52:08.000Z","comments":true,"path":"posts/BZOJ4059/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4059/","excerpt":"","text":"题面在这里 ​ 启发式分裂裸题 ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005;int tst,n,m,a[maxn],b[maxn],L[maxn],R[maxn],lst[maxn];bool solve(int l,int r)&#123; if (l&gt;=r) return 1; for (int i=l,j=r;i&lt;=j;i++,j--)&#123; if (L[i]&lt;l&amp;&amp;r&lt;R[i]) return solve(l,i-1)&amp;&amp;solve(i+1,r); if (L[j]&lt;l&amp;&amp;r&lt;R[j]) return solve(l,j-1)&amp;&amp;solve(j+1,r); &#125; return 0;&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),b[i]=a[i]; sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+1+m,a[i])-b; for (int i=1;i&lt;=m;i++) lst[i]=0; for (int i=1;i&lt;=n;i++) L[i]=lst[a[i]],lst[a[i]]=i; for (int i=1;i&lt;=m;i++) lst[i]=n+1; for (int i=n;i&gt;=1;i--) R[i]=lst[a[i]],lst[a[i]]=i; if (solve(1,n)) puts(\"non-boring\");else puts(\"boring\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"启发式分裂","slug":"启发式分裂","permalink":"http://oi.linkfqy.top/tags/启发式分裂/"}]},{"title":"【启发式分裂】BZOJ5200 [NWERC2017]Factor-Free Tree","slug":"BZOJ5200","date":"2018-11-07T07:10:59.000Z","updated":"2018-11-07T07:19:08.000Z","comments":true,"path":"posts/BZOJ5200/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ5200/","excerpt":"","text":"题面在这里 ​ 考虑一个子树（序列），\\(i\\)能作为根当且仅当区间内所有数与\\(a_i\\)互质 可以预处理出左边第一个与\\(a_i\\)不互质的位置\\(L_i\\)和右边第一个与\\(a_i\\)不互质的位置\\(R_i\\) 具体方法：枚举每个数的质因子，取所有质因子出现位置最大的 还有一个结论：对于任意区间，更靠两端的点满足与整个区间互质却不能作为根，则里面的点一定也不能 然后就可以启发式分裂找每个子树的根啦 启发式分裂：由于指针移动次数为分裂出较小的那个区间长度，可以看作时启发式合并的逆过程 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;inline void put(int x)&#123; static int stk[11];stk[0]=0; do stk[++stk[0]]=x%10,x/=10; while (x); while (stk[0]) putchar(stk[stk[0]--]+48);&#125;const int maxn=1000005,maxa=10000005;int n,a[maxn],L[maxn],R[maxn];int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125;int p[maxa],pre[maxa],lst[maxa];bool vis[maxa];void makep(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i,pre[i]=i; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1; pre[i*p[j]]=p[j]; if (i%p[j]==0) break; &#125; &#125;&#125;int fa[maxn];bool solve(int l,int r,int f)&#123; if (l&gt;r) return 1; for (int i=l,j=r;i&lt;=j;i++,j--)&#123; if (L[i]&lt;l&amp;&amp;r&lt;R[i])&#123; fa[i]=f;return solve(l,i-1,i)&amp;&amp;solve(i+1,r,i); &#125; if (L[j]&lt;l&amp;&amp;r&lt;R[j])&#123; fa[j]=f;return solve(l,j-1,j)&amp;&amp;solve(j+1,r,j); &#125; &#125; return 0;&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); makep(10000000); for (int i=1;i&lt;=n;i++)&#123; int x=a[i]; while (x!=1)&#123; int p=pre[x]; L[i]=max(L[i],lst[p]); lst[p]=i; while (x%p==0) x/=p; &#125; &#125; for (int i=1;i&lt;=p[0];i++) lst[p[i]]=n+1; for (int i=n;i;i--)&#123; int x=a[i];R[i]=n+1; while (x!=1)&#123; int p=pre[x]; R[i]=min(R[i],lst[p]); lst[p]=i; while (x%p==0) x/=p; &#125; &#125; if (solve(1,n,0)) for (int i=1;i&lt;=n;i++) put(fa[i]),putchar(' '); else puts(\"impossible\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"启发式分裂","slug":"启发式分裂","permalink":"http://oi.linkfqy.top/tags/启发式分裂/"}]},{"title":"NOIP2017 宝藏","slug":"NOIP2017_D2T2","date":"2018-11-07T00:07:23.000Z","updated":"2018-11-07T00:14:04.000Z","comments":true,"path":"posts/NOIP2017_D2T2/","link":"","permalink":"http://oi.linkfqy.top/posts/NOIP2017_D2T2/","excerpt":"","text":"题面自取 ​ 一看就是状压DP，但是如何保存深度信息？每个点存深度显然不现实 考虑一个点的深度信息只在加新点时有用，所以强行定义当前所有点的深度即可 \\(f_{i,s}\\)表示当前所有点深度为\\(i\\)，连通块集合为\\(s\\) 显然枚举\\(s\\)补集的子集\\(ss\\)，则有 \\[ f_{i+1,s+ss}\\leftarrow f_{i,s}+g_{ss} \\] 其中\\(g_{ss}\\)表示\\(ss\\)集合中所有点到\\(s\\)代价之和，可以预处理出来 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=15,maxe=2005,INF=0x3f3f3f3f;int n,e,f[maxn][4100],d[maxn][maxn],g[4100],w[maxn],lg[4100],stk[4100];#define up(x,y) (x=min(x,y))#define lowbit(x) ((x)&amp;-(x))int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); cl(d,63); for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),x--,y--,up(d[x][y],z),up(d[y][x],z); cl(f,63); for (int i=0;i&lt;n;i++) f[1][1&lt;&lt;i]=0,lg[1&lt;&lt;i]=i; for (int i=1;i&lt;n;i++) for (int s=0;s&lt;(1&lt;&lt;n);s++)&#123; cl(w,63); for (int j=0;j&lt;n;j++) for (int k=s;k;k-=k&amp;-k) if (d[j][lg[k&amp;-k]]!=INF) up(w[j],d[j][lg[k&amp;-k]]*i); int t=s^((1&lt;&lt;n)-1); cl(g,0); stk[0]=0; for (int ss=t;ss;ss=(ss-1)&amp;t) stk[++stk[0]]=ss; for (int j=stk[0];j;j--)&#123; g[stk[j]]=g[stk[j]^lowbit(stk[j])]+w[lg[lowbit(stk[j])]]; if (g[stk[j]]&gt;INF) g[stk[j]]=INF; &#125; for (int ss=t;ss;ss=(ss-1)&amp;t)&#123; up(f[i+1][s|ss],f[i][s]+g[ss]); &#125; &#125; int ans=INF; for (int i=0;i&lt;=n;i++) up(ans,f[i][(1&lt;&lt;n)-1]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"}]},{"title":"Codeforces 700B Connecting Universities","slug":"CF700B","date":"2018-11-06T09:01:23.000Z","updated":"2018-11-06T09:02:56.000Z","comments":true,"path":"posts/CF700B/","link":"","permalink":"http://oi.linkfqy.top/posts/CF700B/","excerpt":"","text":"题面在这里 ​ 对于每条边\\((u,v)\\)，对答案的贡献是两边特殊点少的那个 ​ 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=200005,maxe=400005;int n,K,s[maxn]; ll ans;int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x,int fa)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x),s[x]+=s[son[j]],ans+=min(s[son[j]],2*K-s[son[j]]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1,x;i&lt;=2*K;i++) scanf(\"%d\",&amp;x),s[x]++; for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs(1,1); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 999F Cards and Joy","slug":"CF999F","date":"2018-11-05T23:48:04.000Z","updated":"2018-11-05T23:59:46.000Z","comments":true,"path":"posts/CF999F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF999F/","excerpt":"","text":"题面在这里 ​ \\(f_{i,j}\\)表示\\(i\\)张卡片，分给\\(j\\)个人（所有卡片的编号和人的一样） \\[ f_{i,j}=f_{i-k,j-1}+h[k] \\] 然后统计一下答案就好了 ​ 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=505,maxk=15,maxs=5005;int n,K,h[maxk],f[maxs][maxn],cnt[100005],num[100005];#define up(x,y) (x=max(x,y))int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1,x;i&lt;=n*K;i++) scanf(\"%d\",&amp;x),cnt[x]++; for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),num[x]++; for (int i=1;i&lt;=K;i++) scanf(\"%d\",&amp;h[i]); for (int i=1;i&lt;=n*K;i++) for (int j=1;j&lt;=n;j++) for (int k=1;k&lt;=i&amp;&amp;k&lt;=K;k++) up(f[i][j],f[i-k][j-1]+h[k]); int ans=0; for (int i=1;i&lt;=100000;i++) if (cnt[i]&gt;0&amp;&amp;num[i]&gt;0) ans+=f[cnt[i]][num[i]]; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"51Nod 1250 排列与交换","slug":"BZOJ1250","date":"2018-11-05T10:29:30.000Z","updated":"2018-11-05T10:56:52.000Z","comments":true,"path":"posts/BZOJ1250/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1250/","excerpt":"","text":"题面在这里 ​ 考虑把1到n的数一个一个加入，这样状态比较好设计 对于第一问： \\(f_{i,j}\\)表示长度为\\(i\\)的排列，恰好做了\\(j\\)次交换 \\[ f_{i,j}=\\sum_{k=max(0,j-i+1)}^j f_{i-1,k} \\] 因为可以两个数不断交换，答案是\\(\\sum_{j\\text{ mod }2=m\\text{ mod }2} f_{n,j}\\) 对于第二问： \\(g_{i,j}\\)表示长度为\\(i\\)的排列，恰好做了\\(j\\)次交换 \\[ g_{i,j}=g_{i-1,j}+(i-1)\\cdot g_{i-1,j-1} \\] 答案是\\(\\sum_j g_{n,j}\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=3005,MOD=1e9+7;int n,K,f[maxn][maxn],g[maxn][maxn],s[maxn][maxn],ans;#define up(x,y) ((x+=y)%=MOD)int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); f[0][0]=1; for (int j=0;j&lt;=K;j++) s[0][j]=1; for (int i=1;i&lt;=n;i++)&#123; for (int j=0;j&lt;=K;j++) up(f[i][j],s[i-1][j]-(j&gt;=i?s[i-1][j-i]:0)), s[i][j]=((j==0?0:s[i][j-1])+f[i][j])%MOD; &#125; ans=0; for (int j=0;j&lt;=K;j++) if (j%2==K%2) up(ans,f[n][j]); printf(\"%d \",ans); g[0][0]=1; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=K;j++) up(g[i][j],(g[i-1][j]+(ll)(j==0?0:g[i-1][j-1])*(i-1))%MOD); ans=0; for (int j=0;j&lt;=K;j++) up(ans,g[n][j]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"51Nod","slug":"51Nod","permalink":"http://oi.linkfqy.top/tags/51Nod/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【分层图最短路】BZOJ2662 [BeiJing wc2012]冻结","slug":"BZOJ2662","date":"2018-11-04T12:54:42.000Z","updated":"2018-11-04T12:56:54.000Z","comments":true,"path":"posts/BZOJ2662/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2662/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=55,maxe=2005,maxs=2505;int n,e,K;int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int que[maxs],quek[maxs],dst[maxn][maxn];bool vis[maxn][maxn];void spfa()&#123; cl(dst,63); int hed=0,til=1; que[1]=1,quek[1]=0,dst[1][0]=0;vis[1][0]=1; while (hed!=til)&#123; hed=(hed+1)%maxs; int x=que[hed],k=quek[hed]; vis[x][k]=0; for (int j=lnk[x];j;j=nxt[j])&#123; if (dst[son[j]][k]&gt;dst[x][k]+w[j])&#123; dst[son[j]][k]=dst[x][k]+w[j]; if (!vis[son[j]][k]) vis[son[j]][k]=1,til=(til+1)%maxs, que[til]=son[j],quek[til]=k; &#125; if (k&lt;=K&amp;&amp;dst[son[j]][k+1]&gt;dst[x][k]+w[j]/2)&#123; dst[son[j]][k+1]=dst[x][k]+w[j]/2; if (!vis[son[j]][k+1]) vis[son[j]][k+1]=1,til=(til+1)%maxs, que[til]=son[j],quek[til]=k+1; &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;e,&amp;K); for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); spfa(); int ans=0x3f3f3f3f; for (int i=0;i&lt;=K;i++) ans=min(ans,dst[n][i]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"【期望DP+循环矩阵】BZOJ2510 弱题","slug":"BZOJ2510","date":"2018-11-04T11:48:42.000Z","updated":"2018-11-04T11:53:28.000Z","comments":true,"path":"posts/BZOJ2510/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2510/","excerpt":"","text":"题面在这里 ​ \\(f_{i,j}\\)表示\\(i\\)次操作后，编号为\\(j\\)的球的个数期望 则\\(f_{i,j}=\\frac 1 m f_{i-1,j-1}+\\frac{m-1} m f_{i-1,j}\\) 发现这是一个循环矩阵，那么只需要维护第一行即可，时间复杂度\\(O(n^2\\log K)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=1005;int n,m,K;struct data&#123; double s[maxn]; data () &#123;cl(s,0);&#125;&#125;f,t;data operator*(const data&amp;a,const data&amp;b)&#123; data c; for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) c.s[(i+j)%n]+=a.s[i]*b.s[j]; return c;&#125;data Pow(data a,int b)&#123; data w=a,res;res.s[0]=1; while (b)&#123; if (b&amp;1) res=res*w; w=w*w; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K); for (int i=0;i&lt;n;i++) scanf(\"%lf\",&amp;f.s[i]); t.s[0]=(m-1.0)/m; t.s[1]=1.0/m; f=f*Pow(t,K); for (int i=0;i&lt;n;i++) printf(\"%.3lf\\n\",f.s[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"矩阵","slug":"矩阵","permalink":"http://oi.linkfqy.top/tags/矩阵/"},{"name":"期望DP","slug":"期望DP","permalink":"http://oi.linkfqy.top/tags/期望DP/"}]},{"title":"Codeforces 870E Points, Lines and Ready-made Titles","slug":"CF870E","date":"2018-11-02T23:21:15.000Z","updated":"2018-11-02T23:28:30.000Z","comments":true,"path":"posts/CF870E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF870E/","excerpt":"","text":"题面在这里 ​ 考虑两种方案不一样当且仅当某一行或某一列的情况不一样 熟悉的套路……对于每个点，连接它所在的行和列 对于每条边，可以把权赋给一个端点或者什么都不做 方案不同其实是图中点的01串不同 那么如果一个连通块是树，有\\(2^{size}-1\\)的贡献，否则有\\(2^{size}\\)的贡献 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=200005,MOD=1e9+7;int n,x[maxn],y[maxn],a[maxn],b[maxn],pw[maxn];int fa[maxn],siz[maxn],ed[maxn];inline int getfa(int x)&#123; return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;x[i],&amp;y[i]),a[++a[0]]=x[i],b[++b[0]]=y[i]; sort(a+1,a+1+a[0]); a[0]=unique(a+1,a+1+a[0])-a-1; sort(b+1,b+1+b[0]); b[0]=unique(b+1,b+1+b[0])-b-1; for (int i=1;i&lt;=n;i++) x[i]=lower_bound(a+1,a+1+a[0],x[i])-a,y[i]=lower_bound(b+1,b+1+b[0],y[i])-b; pw[0]=1; for (int i=1;i&lt;=a[0]+b[0];i++) fa[i]=i,siz[i]=1,pw[i]=pw[i-1]*2%MOD; for (int i=1;i&lt;=n;i++)&#123; int fx=getfa(x[i]),fy=getfa(y[i]+a[0]); if (fx==fy) ed[fx]++; else fa[fx]=fy,siz[fy]+=siz[fx],ed[fy]+=ed[fx]+1; &#125; ll ans=1; for (int i=1;i&lt;=a[0]+b[0];i++) if (getfa(i)==i) if (ed[i]==siz[i]-1) (ans*=pw[siz[i]]-1)%=MOD; else (ans*=pw[siz[i]])%=MOD; printf(\"%lld\",(ans+MOD)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【结论】BZOJ4401 块的计数","slug":"BZOJ4401","date":"2018-11-02T11:47:47.000Z","updated":"2018-11-02T11:55:18.000Z","comments":true,"path":"posts/BZOJ4401/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4401/","excerpt":"","text":"题面在这里 ​ 只有n的因子能作为块的大小 块大小确定的情况下，至多有一种划分方法 块大小为\\(d\\)时，存在一种划分方法当且仅当有\\(\\frac n d\\)个子树的大小被\\(d\\)整除 前两条的正确性显然 对于第三条，考虑如果有划分方法，把根所在的块去掉，剩下几个子树大小一定都被\\(d\\)整除，以此类推 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005,maxe=2000005;int n,siz[maxn],s[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x,int fa)&#123; siz[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa)&#123; dfs(son[j],x); siz[x]+=siz[son[j]]; &#125;&#125;bool check(int x)&#123; int tot=0; for (int i=x;i&lt;=n;i+=x) tot+=s[i]; return tot==n/x;&#125;int main()&#123; n=red(); for (int i=1,x,y;i&lt;n;i++) x=red(),y=red(),add(x,y),add(y,x); dfs(1,1); for (int i=1;i&lt;=n;i++) s[siz[i]]++; int ans=0; for (int d=1;d*d&lt;=n;d++) if (n%d==0)&#123; if (check(d)) ans++; if (d*d!=n&amp;&amp;check(n/d)) ans++; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"结论题","slug":"结论题","permalink":"http://oi.linkfqy.top/tags/结论题/"}]},{"title":"【DP】BZOJ1296 [SCOI2009]粉刷匠","slug":"BZOJ1296","date":"2018-11-02T08:03:07.000Z","updated":"2018-11-02T08:19:50.000Z","comments":true,"path":"posts/BZOJ1296/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1296/","excerpt":"","text":"题面在这里 ​ 考虑每一行粉刷是独立的 对每一行DP：\\(f_{i,j}\\)表示前\\(i\\)个位置，刷了\\(j\\)个位置 \\[ f_{i,j}=f_{k,j-1}+\\max(num_0,num_1) \\] 然后总的粉刷次数是确定的，把每行看作一个组，就是分组背包了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=55,maxk=2505;int n,m,K,N,s[maxn][maxn],f[maxn][maxk],g[maxn][maxk];char a[maxn][maxn];#define w(i,l,r) (max(s[i][r]-s[i][(l)-1],(r)-(l)+1-s[i][r]+s[i][(l)-1]))#define up(x,y) (x=max(x,y))int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;K); for (int i=1;i&lt;=n;i++) scanf(\"%s\",a[i]+1); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) s[i][j]=s[i][j-1]+a[i][j]-'0'; for (int x=1;x&lt;=n;x++)&#123; cl(f,192); f[0][0]=0; for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=i&amp;&amp;j&lt;=K;j++)&#123; f[i][j]=f[i-1][j]; for (int k=0;k&lt;i;k++) up(f[i][j],f[k][j-1]+w(x,k+1,i)); &#125; for (int i=1;i&lt;=m;i++) for (int j=i;j&lt;=K;j++) up(g[x][j],g[x-1][j-i]+f[m][i]); &#125; int ans=0; for (int i=1;i&lt;=K;i++) ans=max(ans,g[n][i]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"BZOJ2037 [Sdoi2008]Sue的小球","slug":"BZOJ2037","date":"2018-11-02T04:00:08.000Z","updated":"2018-11-02T04:00:34.000Z","comments":true,"path":"posts/BZOJ2037/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2037/","excerpt":"","text":"题面在这里 ​ 直接区间DP即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=1005;int n,xx,X[maxn],s[maxn],f[maxn][maxn][2];struct data&#123; int x,y,v; bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x;&#125;&#125;a[maxn];#define w(l,r,t) ((s[(l)-1]+s[n]-s[r])*(t))#define up(x,y) (x=max(x,y))int main()&#123; scanf(\"%d%d\",&amp;n,&amp;xx); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].x),X[i]=a[i].x; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].y); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].v); n++;a[n].x=X[n]=xx; sort(a+1,a+1+n);sort(X+1,X+1+n); for (int i=1;i&lt;=n;i++) s[i]=s[i-1]+a[i].v; cl(f,192); &#123; for (int i=1;i&lt;=n;i++) if (a[i].x==xx) f[i][i][0]=f[i][i][1]=0; &#125; for (int L=0;L&lt;n;L++) for (int i=1;i+L&lt;=n;i++)&#123; int j=i+L; up(f[i-1][j][0],f[i][j][0]-w(i,j,X[i]-X[i-1])+a[i-1].y); up(f[i-1][j][0],f[i][j][1]-w(i,j,X[j]-X[i-1])+a[i-1].y); up(f[i][j+1][1],f[i][j][0]-w(i,j,X[j+1]-X[i])+a[j+1].y); up(f[i][j+1][1],f[i][j][1]-w(i,j,X[j+1]-X[j])+a[j+1].y); &#125; printf(\"%.3lf\",max(f[1][n][0],f[1][n][1])/1000.0); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"BZOJ2276 [Poi2011]Temperature","slug":"BZOJ2276","date":"2018-11-02T01:26:23.000Z","updated":"2018-11-02T01:39:22.000Z","comments":true,"path":"posts/BZOJ2276/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2276/","excerpt":"","text":"题面在这里 ​ 考虑枚举右端点 因为\\(a_i\\)递增的部分都可以取到，直接维护\\(a_i\\)递减的单调队列 ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000005;int n,l[maxn],r[maxn],que[maxn];int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;l[i],&amp;r[i]); int ans=0,hed=1,til=0; for (int i=1;i&lt;=n;i++)&#123; while (hed&lt;=til&amp;&amp;l[que[hed]]&gt;r[i]) hed++; ans=max(ans,i-que[hed-1]); while (hed&lt;=til&amp;&amp;l[que[til]]&lt;=l[i]) til--; que[++til]=i; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调队列","slug":"单调队列","permalink":"http://oi.linkfqy.top/tags/单调队列/"}]},{"title":"【调和级数】计蒜客31431 手拉手","slug":"JSK_31431","date":"2018-11-02T01:17:51.000Z","updated":"2018-11-02T01:24:02.000Z","comments":true,"path":"posts/JSK_31431/","link":"","permalink":"http://oi.linkfqy.top/posts/JSK_31431/","excerpt":"","text":"题面在这里 ​ 考虑新加入第i个人，要么自己成环，要么加入某个已有的环内 而只有自己成环才对答案有1的贡献，概率为\\(\\frac 1 {2i-1}\\) 答案就是：\\(\\sum_{i=1}^n \\frac 1 {2i-1}\\) 而\\(\\sum_{i=1}^n \\frac 1 i\\approx \\ln n+c\\)，\\(c\\)是欧拉常数 答案就是两个调和级数相减 ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;cmath&gt;typedef long long ll;const double C=0.57721566490153286060651209;ll n;int main()&#123; freopen(\"hand.in\",\"r\",stdin); freopen(\"hand.out\",\"w\",stdout); scanf(\"%lld\",&amp;n); if (n&lt;=1000000)&#123; double ans=0; for (int i=1;i&lt;=n;i++) ans+=1.0/(2*i-1); printf(\"%.9lf\",ans); &#125;else&#123; printf(\"%.9lf\",(log(n)+C)/2+log(2)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://oi.linkfqy.top/tags/数学/"},{"name":"计蒜客","slug":"计蒜客","permalink":"http://oi.linkfqy.top/tags/计蒜客/"}]},{"title":"NOIP2017 逛公园","slug":"NOIP2017_D1T3","date":"2018-10-31T12:02:00.000Z","updated":"2018-10-31T12:24:12.000Z","comments":true,"path":"posts/NOIP2017_D1T3/","link":"","permalink":"http://oi.linkfqy.top/posts/NOIP2017_D1T3/","excerpt":"","text":"题面自取 ​ 直接记忆化搜索就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxe=200005;int tst,n,e,K,MOD;int son[maxe],nxt[maxe],lnk[maxn],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int dst[maxn],que[maxn];int vis[maxn];void spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=1;dst[1]=0;vis[1]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125;&#125;int f[maxn][55];bool in[maxn][55];int dfs(int x,int d)&#123; if (in[x][d]) return -1; if (f[x][d]&gt;=0) return f[x][d]; in[x][d]=1; int t; f[x][d]=(x==n&amp;&amp;d&lt;=K); for (int j=lnk[x];j;j=nxt[j])&#123; int k=dst[x]+w[j]+d-dst[son[j]]; if (k&lt;0||k&gt;K) continue; (f[x][d]+=(t=dfs(son[j],k)))%=MOD; if (t&lt;0) return -1; &#125; in[x][d]=0; return f[x][d];&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d%d%d\",&amp;n,&amp;e,&amp;K,&amp;MOD); cl(lnk,0);tot=0; for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z); spfa(); cl(f,-1);cl(in,0); printf(\"%d\\n\",dfs(1,0)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"BZOJ4240 有趣的家庭菜园","slug":"BZOJ4240","date":"2018-10-30T10:55:45.000Z","updated":"2018-10-30T11:03:26.000Z","comments":true,"path":"posts/BZOJ4240/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4240/","excerpt":"","text":"题面在这里 ​ 最终状态一定是一个先增后减的峰形 然后交换次数其实等于 最终状态的\\(id\\)序列的逆序对数 考虑按高度从小到大加入最终的序列，只能放在两端，分别统计答案，选小的那个 用树状数组维护 未加入的点的\\(id\\)分布情况 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=300005;int n;struct data&#123; int x,id; bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x;&#125;&#125;a[maxn];int b1[maxn],b2[maxn];#define lowbit(x) ((x)&amp;-(x))void ist(int x,int w)&#123; for (int i=x;i&lt;=n;i+=lowbit(i)) b1[i]+=w; for (int i=x;i&gt;=1;i-=lowbit(i)) b2[i]+=w;&#125;int qry(int x)&#123; int r1=0,r2=0; for (int i=x;i&gt;=1;i-=lowbit(i)) r1+=b1[i]; for (int i=x;i&lt;=n;i+=lowbit(i)) r2+=b2[i]; return min(r1,r2);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].x),a[i].id=i,ist(i,1); sort(a+1,a+1+n); ll ans=0; for (int i=1,j=1;i&lt;=n;i=j)&#123; for (j=i;j&lt;=n&amp;&amp;a[i].x==a[j].x;j++) ist(a[j].id,-1); for (j=i;j&lt;=n&amp;&amp;a[i].x==a[j].x;j++) ans+=qry(a[j].id); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"BZOJ3304 [Shoi2005]带限制的最长公共子序列","slug":"BZOJ3304","date":"2018-10-30T01:08:07.000Z","updated":"2018-10-30T01:08:50.000Z","comments":true,"path":"posts/BZOJ3304/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3304/","excerpt":"","text":"题面在这里 ​ 大力DP即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=505;int A,B,C,f[2][maxn][maxn];char a[maxn],b[maxn],c[maxn];int main()&#123; scanf(\"%s%s%s\",a+1,b+1,c+1); A=strlen(a+1); B=strlen(b+1); C=strlen(c+1); for (int i=1;i&lt;=A;i++) for (int j=1;j&lt;=B;j++) if (a[i]==b[j]) f[0][i][j]=f[0][i-1][j-1]+1; else f[0][i][j]=max(f[0][i-1][j],f[0][i][j-1]); for (int k=1;k&lt;=C;k++)&#123; cl(f[k&amp;1],192); for (int i=1;i&lt;=A;i++) for (int j=1;j&lt;=B;j++)&#123; if (a[i]==b[j]) if (a[i]==c[k]) f[k&amp;1][i][j]=f[k&amp;1^1][i-1][j-1]+1; else f[k&amp;1][i][j]=f[k&amp;1][i-1][j-1]+1; else f[k&amp;1][i][j]=max(f[k&amp;1][i-1][j],f[k&amp;1][i][j-1]); &#125; &#125; if (f[C&amp;1][A][B]&lt;0) puts(\"NO SOLUTION\");else printf(\"%d\",f[C&amp;1][A][B]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【拓扑排序+堆】BZOJ3832 [Poi2014]Rally","slug":"BZOJ3832","date":"2018-10-29T12:57:33.000Z","updated":"2018-10-29T13:20:40.000Z","comments":true,"path":"posts/BZOJ3832/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3832/","excerpt":"","text":"题面在这里 ​ 思路太妙了…… 首先建立超级源\\(S\\)向所有点连边，所有点向超级汇\\(T\\)连边 可以拓扑求出\\(S\\)到\\(x\\)的最长路\\(f_x\\)，以\\(x\\)到\\(T\\)的最长路\\(g_x\\) 那么边\\((u,v)\\)对应的权值就是\\(f_u+g_v-1\\) 注意到最长路其实是\\(S\\)到\\(T\\)的任意割中所有边的最大权值 这个割把图划分成两个集合：\\(S\\)集和\\(T\\)集 一开始除\\(S\\)点外，所有点都在\\(T\\)集 按拓扑序将点从\\(T\\)集转移至\\(S\\)集 一次转移的过程是：把指向\\(x\\)的边从割中删去，此时割中最大权值就是\\(x\\)的答案，再把\\(x\\)的出边加入割即可 用一个堆维护割即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=500005,maxe=2000005,INF=0x3f3f3f3f;int n,e,ans=INF,p;int tot,son[maxe],nxt[maxe],lnk[maxn],lnk1[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline void add1(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk1[x];lnk1[x]=tot;&#125;int que[maxn],in[maxn],f[maxn],g[maxn];void topo()&#123; int hed=0,til=0; for (int i=1;i&lt;=n;i++) if (!in[i]) que[++til]=i; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j])&#123; in[son[j]]--; if (!in[son[j]]) que[++til]=son[j]; &#125; &#125; for (int i=1;i&lt;=n;i++)&#123; f[que[i]]=max(f[que[i]],1); for (int j=lnk[que[i]];j;j=nxt[j]) f[son[j]]=max(f[son[j]],f[que[i]]+1); &#125; for (int i=n;i&gt;=1;i--)&#123; g[que[i]]=max(g[que[i]],1); for (int j=lnk[que[i]];j;j=nxt[j]) g[que[i]]=max(g[que[i]],g[son[j]]+1); &#125;&#125;priority_queue&lt;int&gt; Q;int tag[maxn]; inline int Top()&#123; while (tag[Q.top()]) tag[Q.top()]--,Q.pop(); return Q.top();&#125;inline void Push(int x) &#123;Q.push(x);&#125;inline void Del(int x) &#123;tag[x]++;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add1(y,x),in[y]++; topo(); for (int i=1;i&lt;=n;i++) Push(g[i]); Push(0); for (int i=1;i&lt;=n;i++)&#123; int x=que[i]; for (int j=lnk1[x];j;j=nxt[j]) Del(f[son[j]]+g[x]); Del(g[x]); int t=Top(); if (t&lt;ans) ans=t,p=x; for (int j=lnk[x];j;j=nxt[j]) Push(f[x]+g[son[j]]); Push(f[x]); &#125; printf(\"%d %d\",p,ans-1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"拓扑排序","slug":"拓扑排序","permalink":"http://oi.linkfqy.top/tags/拓扑排序/"},{"name":"堆","slug":"堆","permalink":"http://oi.linkfqy.top/tags/堆/"}]},{"title":"【树形背包】BZOJ4987 Tree","slug":"BZOJ4987","date":"2018-10-28T11:55:53.000Z","updated":"2018-10-28T12:02:32.000Z","comments":true,"path":"posts/BZOJ4987/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4987/","excerpt":"","text":"题面在这里 ​ 首先有以下两个结论： 选的点一定是一个连通子树 答案是这个连通子树的边权和*2-直径 \\(f_{i,j,0/1/2}\\)表示\\(i\\)子树内，选了大小为\\(j\\)的连通子树（\\(i\\)在其中），包含了0/1/2个直径端点 大力树形背包即可，如果怕更新出问题就开临时数组搞把 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=3005,maxe=6005;int n,K;int son[maxe],nxt[maxe],lnk[maxn],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int f[maxn][maxn][3],t[maxn][3],siz[maxn],ans=0x3f3f3f3f;void dfs(int x,int fa)&#123; siz[x]=1; f[x][1][0]=f[x][1][1]=f[x][1][2]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa)&#123; dfs(son[j],x); cl(t,63); for (int i=0;i&lt;=siz[x];i++) for (int k=0;k&lt;=siz[son[j]];k++)&#123; t[i+k][0]=min(t[i+k][0],f[x][i][0]+f[son[j]][k][0]+2*w[j]); t[i+k][1]=min(t[i+k][1],f[x][i][1]+f[son[j]][k][0]+2*w[j]); t[i+k][1]=min(t[i+k][1],f[x][i][0]+f[son[j]][k][1]+w[j]); t[i+k][2]=min(t[i+k][2],f[x][i][1]+f[son[j]][k][1]+w[j]); t[i+k][2]=min(t[i+k][2],f[x][i][0]+f[son[j]][k][2]+2*w[j]); t[i+k][2]=min(t[i+k][2],f[x][i][2]+f[son[j]][k][0]+2*w[j]); &#125; siz[x]+=siz[son[j]]; for (int i=0;i&lt;=siz[x];i++) for (int k=0;k&lt;3;k++) f[x][i][k]=min(f[x][i][k],t[i][k]); &#125; ans=min(ans,f[x][K][2]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1,x,y,z;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); cl(f,63); dfs(1,1); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【最小生成树】BZOJ2753 [SCOI2012]滑雪与时间胶囊","slug":"BZOJ2753","date":"2018-10-28T07:57:43.000Z","updated":"2018-10-28T08:10:48.000Z","comments":true,"path":"posts/BZOJ2753/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2753/","excerpt":"","text":"题面在这里 ​ 第一问就是能遍历到的点数 考虑第二问，肯定是尽量先走较高的点，高度相同时再走边权小的 这样才能在遍历最多点的情况下走最短的路 那么高度第一关键字，边权第二关键字排序，做最小生成树即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005,maxe=2000005;int n,m,e,h[maxn],nn;struct edge&#123; int x,y,w; bool operator&lt;(const edge&amp;b)const &#123;return h[y]&gt;h[b.y]||h[y]==h[b.y]&amp;&amp;w&lt;b.w;&#125;&#125;a[maxe];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int que[maxn];bool vis[maxn];void bfs()&#123; int hed=0,til=1; que[1]=1;vis[1]=1; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]) vis[que[++til]=son[j]]=1; &#125; nn=til;&#125;int fa[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;h[i]); for (int i=1;i&lt;=e;i++)&#123; scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w); if (h[a[i].x]&lt;h[a[i].y]) swap(a[i].x,a[i].y); add(a[i].x,a[i].y); if (h[a[i].x]==h[a[i].y]) add(a[i].y,a[i].x); &#125; bfs(); sort(a+1,a+1+e); for (int i=1;i&lt;=n;i++) fa[i]=i; ll ans=0; for (int i=1;i&lt;=e;i++) if (vis[a[i].x]&amp;&amp;vis[a[i].y]) if (getfa(a[i].x)!=getfa(a[i].y))&#123; fa[getfa(a[i].x)]=getfa(a[i].y); ans+=a[i].w; &#125; printf(\"%d %lld\",nn,ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"}]},{"title":"【费用流】BZOJ2661 [BeiJing wc2012]连连看","slug":"BZOJ2661","date":"2018-10-28T06:09:41.000Z","updated":"2018-10-28T06:35:56.000Z","comments":true,"path":"posts/BZOJ2661/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2661/","excerpt":"","text":"题面在这里 ​ 拆点费用流…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=2005,maxe=10400,INF=0x3f3f3f3f;int L,R,S,T;bool issq[1000005];int son[maxe],nxt[maxe],lnk[maxn],w[maxe],flw[maxe],cap[maxe],tot;inline void add(int x,int y,int f,int z) &#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125;int dst[maxn],que[maxn],pre[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(dst,192);cl(vis,0); int hed=0,til=1; que[1]=S;dst[S]=0;vis[S]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (flw[j]&lt;cap[j]&amp;&amp;dst[son[j]]&lt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; pre[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125; return dst[T]!=dst[0];&#125;int main()&#123; scanf(\"%d%d\",&amp;L,&amp;R); for (int i=1;i&lt;=1000;i++) issq[i*i]=1; S=2001,T=2002;tot=1; for (int i=L;i&lt;=R;i++) add(S,i,1,0),add(i+1000,T,1,0); for (int i=L;i&lt;=R;i++) for (int j=i+1;j&lt;=R;j++) if (issq[j*j-i*i]&amp;&amp;gcd(i*i,j*j-i*i)==1) add(i,j+1000,1,i+j),add(j,i+1000,1,i+j); int F=0,W=0; while (spfa())&#123; int Min=INF; for (int x=T;x!=S;x=pre[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=pre[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; F+=Min; W+=Min*dst[T]; &#125; printf(\"%d %d\",F/2,W/2); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ4361 isn","slug":"BZOJ4361","date":"2018-10-28T02:07:30.000Z","updated":"2018-10-28T02:16:50.000Z","comments":true,"path":"posts/BZOJ4361/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4361/","excerpt":"","text":"题面在这里 ​ \\(f_{i,j}\\)：长度为i，以j结尾的非降序列个数 \\[ f_{i,j}=\\sum_{k\\lt i}^{a_k\\le a_i} f_{i-1,k} \\] 直接用树状数组优化到\\(O(n^2\\log n)\\) 于是得到\\(g_i\\)：长度为i的非降序列个数 答案就是 \\[ \\sum_{i=1}^n g_i(n-i)!-g_{i+1}(i+1)(n-i-1)! \\] 如何理解？ 直接\\(\\sum g_i(n-i)!\\)肯定是不对的，因为有些已经变成非降序列但没有停止删除 但是不合法方案一定是由\\(g_{i+1}\\)来的，枚举删去哪个数，得到对应方案 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=2005,MOD=1e9+7;int n,m,a[maxn],b[maxn],f[maxn][maxn],g[maxn];ll fac[maxn];int BIT[maxn];#define lowbit(x) ((x)&amp;-(x))inline void ist(int x,int w)&#123; for (int i=x;i&lt;=m;i+=lowbit(i)) (BIT[i]+=w)%=MOD;&#125;inline int qry(int x)&#123; int res=0; for (int i=x;i;i-=lowbit(i)) (res+=BIT[i])%=MOD; return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),b[i]=a[i]; sort(b+1,b+1+n); m=unique(b+1,b+1+n)-1-b; for (int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+1+m,a[i])-b; for (int i=1;i&lt;=n;i++) f[1][i]=1; for (int i=2;i&lt;=n;i++)&#123; cl(BIT,0); for (int j=1;j&lt;=n;j++)&#123; f[i][j]=qry(a[j]); ist(a[j],f[i-1][j]); &#125; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) (g[i]+=f[i][j])%=MOD; fac[0]=1; for (int i=1;i&lt;=n;i++) fac[i]=(fac[i-1]*i)%MOD; ll ans=0; for (int i=1;i&lt;=n;i++) (ans+=g[i]*fac[n-i]%MOD-g[i+1]*fac[n-i-1]%MOD*(i+1)%MOD)%=MOD; printf(\"%lld\",(ans+MOD)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"}]},{"title":"BZOJ1098 [POI2007]办公楼biu","slug":"BZOJ1098","date":"2018-10-27T07:24:16.000Z","updated":"2018-10-27T07:30:54.000Z","comments":true,"path":"posts/BZOJ1098/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1098/","excerpt":"","text":"题面在这里 ​ 直接用set维护没有遍历的点 BFS时遍历整个set，找下是否在没有边的集合中 两边的贡献都只有\\(\\log\\)，所以总的是\\(O(n\\log n+m\\log m)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,e,ans[maxn];set&lt;int&gt; S;set&lt;int&gt;::iterator it;vector&lt;int&gt; V[maxn];int que[maxn],del[maxn];void BFS()&#123; int hed=0,til=1; que[1]=*S.begin();S.erase(S.begin()); while (hed!=til)&#123; int x=que[++hed]; del[0]=0; for (it=S.begin();it!=S.end();it++) if ((*lower_bound(V[x].begin(),V[x].end(),*it))!=(*it))&#123; que[++til]=*it;del[++del[0]]=*it; &#125; while (del[0]) S.erase(del[del[0]--]); &#125; ans[++ans[0]]=til;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),V[x].push_back(y),V[y].push_back(x); for (int i=1;i&lt;=n;i++) S.insert(i),sort(V[i].begin(),V[i].end()); while (!S.empty()) BFS(); sort(ans+1,ans+1+ans[0]); printf(\"%d\\n\",ans[0]); for (int i=1;i&lt;=ans[0];i++) printf(\"%d \",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"}]},{"title":"【贪心】BZOJ3709 [PA2014]Bohater","slug":"BZOJ3709","date":"2018-10-27T03:12:03.000Z","updated":"2018-10-27T03:17:44.000Z","comments":true,"path":"posts/BZOJ3709/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3709/","excerpt":"","text":"题面在这里 ​ 显然先打那些\\(a&gt;d\\)的怪 这些按照\\(d\\)排序 对于\\(d&gt;a\\)的怪，考虑打完后的血是一定的，把过程反过来，就是前面的情况了，按照\\(a\\)排序 ​ 示例程序： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005;int n;ll z;struct data&#123; int d,s,id; bool operator&lt;(const data&amp;b)const&#123; if ((d&lt;s)^(b.d&lt;b.s)) return d&lt;s; if (d&lt;s) return d&lt;b.d; return s&gt;b.s; &#125;&#125;a[maxn];int main()&#123; scanf(\"%d%lld\",&amp;n,&amp;z); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].d,&amp;a[i].s),a[i].id=i; sort(a+1,a+1+n); for (int i=1;i&lt;=n;i++) if (z&gt;a[i].d) z+=-a[i].d+a[i].s; else return puts(\"NIE\"),0; puts(\"TAK\"); for (int i=1;i&lt;=n;i++) printf(\"%d \",a[i].id); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"}]},{"title":"【差分+线段树】BZOJ3747 [POI2015]Kinoman","slug":"BZOJ3747","date":"2018-10-26T23:49:14.000Z","updated":"2018-10-27T00:29:50.000Z","comments":true,"path":"posts/BZOJ3747/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3747/","excerpt":"","text":"题面在这里 ​ 这种贡献与出现次数有关的题，常见套路是考虑下次出现的位置 \\(nxt[i]\\)表示i下次出现的位置，那么每部电影第一次出现的位置\\(+w\\)，第二次出现位置\\(-w\\) 前缀和就是左端点为1时，每个右端点的答案 枚举左端点，用线段树维护这个答案序列，支持区间加，询问区间最大值 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005,maxs=4000005;int n,m,f[maxn],w[maxn],nxt[maxn],lst[maxn];ll a[maxn]; bool vis[maxn];ll mx[maxs],ad[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x) &#123;mx[x]=max(mx[ls],mx[rs]);&#125;inline void addad(int x,ll w) &#123;mx[x]+=w;ad[x]+=w;&#125;inline void pushdown(int x)&#123; if (ad[x]) addad(ls,ad[x]),addad(rs,ad[x]),ad[x]=0;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mx[x]=a[l];return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,ll w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return addad(x,w); if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(ls,l,mid,ql,qr,w); ist(rs,mid+1,r,ql,qr,w); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return max(qry(ls,l,mid,ql,qr),qry(rs,mid+1,r,ql,qr));&#125;int main()&#123; n=red(),m=red(); for (int i=1;i&lt;=n;i++) f[i]=red(); for (int i=1;i&lt;=m;i++) w[i]=red(),lst[i]=n+1; for (int i=n;i;i--)&#123; nxt[i]=lst[f[i]]; lst[f[i]]=i; &#125; for (int i=1;i&lt;=n;i++) if (!vis[f[i]])&#123; vis[f[i]]=1; a[i]=w[f[i]];a[nxt[i]]=-w[f[i]]; &#125; ll ans=0; for (int i=1;i&lt;=n;i++) a[i]+=a[i-1],ans=max(ans,a[i]); build(1,1,n); for (int i=1;i&lt;n;i++)&#123; ist(1,1,n,i,nxt[i]-1,-w[f[i]]); ist(1,1,n,nxt[i],nxt[nxt[i]]-1,w[f[i]]); ans=max(ans,qry(1,1,n,i+1,n)); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"差分","slug":"差分","permalink":"http://oi.linkfqy.top/tags/差分/"}]},{"title":"【二分+贪心】BZOJ3613 [Heoi2014]南园满地堆轻絮","slug":"BZOJ3613","date":"2018-10-26T11:51:08.000Z","updated":"2018-10-26T11:55:46.000Z","comments":true,"path":"posts/BZOJ3613/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3613/","excerpt":"","text":"题面在这里 ​ 题解见tag ​ 示例程序： 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=5000005;int n,Sa,Sb,Sc,Sd,MOD,a[maxn];inline ll F(ll x)&#123; return Sa*x%MOD*x%MOD*x%MOD+Sb*x%MOD*x%MOD+Sc*x%MOD+Sd;&#125;bool check(int x)&#123; int M=1; for (int i=1;i&lt;=n;i++) if (a[i]&gt;=M) M=max(M,a[i]-x); else&#123; if (a[i]+x&lt;M) return 0; &#125; return 1;&#125;int main()&#123; scanf(\"%d%d%d%d%d%d%d\",&amp;n,&amp;Sa,&amp;Sb,&amp;Sc,&amp;Sd,&amp;a[1],&amp;MOD); for (int i=2;i&lt;=n;i++) a[i]=(F(a[i-1])+F(a[i-2]))%MOD; int L=0,R=MOD,ans=R; while (L&lt;=R)&#123; int mid=L+R&gt;&gt;1; if (check(mid)) ans=mid,R=mid-1;else L=mid+1; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"}]},{"title":"【线段树合并统计逆序对】BZOJ2212 [Poi2011]Tree Rotations","slug":"BZOJ2212","date":"2018-10-26T11:06:29.000Z","updated":"2018-10-26T11:10:32.000Z","comments":true,"path":"posts/BZOJ2212/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2212/","excerpt":"","text":"题面在这里 ​ 显然只要让每个子树的逆序对最少，总的就是最少 如何统计逆序对数？权值线段树合并，统计过中线的逆序对 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll; const int maxn=400005,maxs=7000005,maxe=maxn;int n,w[maxn],N,lson[maxn],rson[maxn];void readin(int &amp;x)&#123; x=++N; scanf(\"%d\",&amp;w[x]); if (w[x]) return; readin(lson[x]); readin(rson[x]);&#125;int s[maxs],ls[maxs],rs[maxs],len,Rot[maxn];void ist(int &amp;x,int l,int r,int k)&#123; if (!x) x=++len,s[x]=ls[x]=rs[x]=0; if (l==r) &#123;s[x]++;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k);else ist(rs[x],mid+1,r,k); s[x]=s[ls[x]]+s[rs[x]];&#125;ll ans=0,L,R;int merge(int x,int y)&#123; if (!x||!y) return x+y; L+=(ll)s[ls[x]]*s[rs[y]]; R+=(ll)s[rs[x]]*s[ls[y]]; ls[x]=merge(ls[x],ls[y]); rs[x]=merge(rs[x],rs[y]); s[x]=s[ls[x]]+s[rs[x]]; return x;&#125;void dfs(int x)&#123; if (w[x]) ist(Rot[x],1,n,w[x]); else&#123; dfs(lson[x]);dfs(rson[x]); L=R=0; Rot[x]=merge(Rot[lson[x]],Rot[rson[x]]); ans+=min(L,R); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); int x;readin(x); dfs(1); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"【树形背包】BZOJ5072 [Lydsy1710月赛]小A的树","slug":"BZOJ5072","date":"2018-10-25T11:39:20.000Z","updated":"2018-10-25T11:47:54.000Z","comments":true,"path":"posts/BZOJ5072/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ5072/","excerpt":"","text":"题面在这里 ​ 有一个结论：连通块大小确定时，黑点的取值是连续的 于是\\(f_{i,j},g_{i,j}\\)分别表示i子树内大小为j的连通块取到黑点的最多/最少值（i在连通块内） 树形背包即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))#include&lt;algorithm&gt;using namespace std;const int maxn=5005,maxe=10005;int tst,n,q,b[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int f[maxn][maxn],g[maxn][maxn],siz[maxn];void dfs(int x,int fa)&#123; siz[x]=1; f[x][1]=g[x][1]=b[x]; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa)&#123; dfs(son[j],x); for (int i=siz[x];i;i--) for (int k=siz[son[j]];k;k--) f[x][i+k]=min(f[x][i+k],f[x][i]+f[son[j]][k]), g[x][i+k]=max(g[x][i+k],g[x][i]+g[son[j]][k]); siz[x]+=siz[son[j]]; &#125; for (int i=1;i&lt;=n;i++) f[0][i]=min(f[0][i],f[x][i]),g[0][i]=max(g[0][i],g[x][i]);&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d\",&amp;n,&amp;q); tot=0,cl(lnk,0); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;b[i]); cl(f,63);cl(g,192); dfs(1,0); while (q--)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); if (f[0][x]&lt;=y&amp;&amp;y&lt;=g[0][x]) puts(\"YES\");else puts(\"NO\"); &#125; puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【贪心】BZOJ2666 [cqoi2012]组装","slug":"BZOJ2666","date":"2018-10-25T03:18:47.000Z","updated":"2018-10-25T03:36:42.000Z","comments":true,"path":"posts/BZOJ2666/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2666/","excerpt":"","text":"题面在这里 ​ 令\\(x_i\\)为第\\(i\\)种零件选择的工厂的位置 \\[ \\sum_{i=1}^n(x-x_i)^2 \\\\ n*x^2+\\sum_{i=1}^nx_i^2-2x*\\sum_{i=1}^nx_i \\\\ 当x取\\frac{\\sum_{i=1}^nx_i} n时，最小值为\\sum_{i=1}^n x_i^2 - \\frac{(\\sum_{i=1}^nx_i)^2} n \\] 这样只需要维护\\(\\sum x_i\\)和\\(\\sum x^2_i\\)两个量即可 严格证明在此 对于每种零件，先选择最左边的工厂 然后用二元组\\((x,y)\\)表示一次修正，把位置在\\(x\\)的工厂换成\\(y\\) 然后按照\\(x+y\\)升序的顺序修正当前选择的工厂集合 一起更新答案即可 感性理解：组装车间从\\(-\\infty\\)到\\(+\\infty\\)移动，考虑零件相同的两个相邻工厂 从选择\\(x\\)到选择\\(y\\)，交界点肯定是中点，所以要按照\\(\\frac{x+y} 2\\)的顺序修正 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,q;vector&lt;int&gt; V[maxn];struct data&#123; int x,y; data (int _x=0,int _y=0):x(_x),y(_y) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return x+y&lt;b.x+b.y;&#125;&#125;a[maxn];double ans,SS,S,pos=1e100;#define sqr(x) ((double)(x)*(x))int main ()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1,x,y;i&lt;=m;i++) scanf(\"%d%d\",&amp;x,&amp;y),V[y].push_back(x); for (int i=1;i&lt;=n;i++) if (V[i].size())&#123; pos=min(pos,(double)V[i][0]); S+=V[i][0]; SS+=sqr(V[i][0]); for (int j=1;j&lt;V[i].size();j++) a[++q]=data(V[i][j-1],V[i][j]); &#125; ans=SS-S*S/n; sort(a+1,a+1+q); for (int i=1;i&lt;=q;i++)&#123; S+=a[i].y-a[i].x; SS+=sqr(a[i].y)-sqr(a[i].x); if (SS-S*S/n&lt;ans) ans=SS-S*S/n,pos=S/n; &#125; printf(\"%.4lf\",pos); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"}]},{"title":"BZOJ3107 [cqoi2013]二进制a+b","slug":"BZOJ3107","date":"2018-10-25T01:25:43.000Z","updated":"2018-10-25T01:37:00.000Z","comments":true,"path":"posts/BZOJ3107/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3107/","excerpt":"","text":"题面在这里 ​ \\(f_{t,i,j,k,0/1}\\)表示\\(a\\)用了\\(i\\)个1，\\(b\\)用了\\(j\\)个1，\\(c\\)用了\\(k\\)个1的最小\\(c\\) 手动暴力转移即可 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=35;int a,b,c,sa,sb,sc,n,w[maxn];ll f[maxn][maxn][maxn][maxn][2],INF;inline void up(ll &amp;a,ll b) &#123;a=min(a,b);&#125;int main()&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c); int len=0; while (a) sa+=a%2,a/=2,len++; n=max(n,len); len=0; while (b) sb+=b%2,b/=2,len++; n=max(n,len); len=0; while (c) sc+=c%2,c/=2,len++; n=max(n,len); w[0]=1; for (int i=1;i&lt;=n;i++) w[i]=w[i-1]&lt;&lt;1; cl(f,63);INF=f[0][0][0][0][0]; f[0][0][0][0][0]=0; for (int t=0;t&lt;n;t++) for (int i=0;i&lt;=sa;i++) for (int j=0;j&lt;=sb;j++) for (int k=0;k&lt;=sc;k++)&#123; up(f[t+1][i][j][k][0],f[t][i][j][k][0]); up(f[t+1][i][j][k+1][0],f[t][i][j][k][1]+w[t]); up(f[t+1][i+1][j][k+1][0],f[t][i][j][k][0]+w[t]); up(f[t+1][i][j+1][k+1][0],f[t][i][j][k][0]+w[t]); up(f[t+1][i+1][j+1][k][1],f[t][i][j][k][0]); up(f[t+1][i+1][j][k][1],f[t][i][j][k][1]); up(f[t+1][i][j+1][k][1],f[t][i][j][k][1]); up(f[t+1][i+1][j+1][k+1][1],f[t][i][j][k][1]+w[t]); &#125; if (f[n][sa][sb][sc][0]==INF) puts(\"-1\"); else printf(\"%lld\",f[n][sa][sb][sc][0]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"BZOJ4104 [Thu Summer Camp 2015]解密运算","slug":"BZOJ4104","date":"2018-10-24T12:13:30.000Z","updated":"2018-10-24T12:47:02.000Z","comments":true,"path":"posts/BZOJ4104/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4104/","excerpt":"","text":"题面在这里 ​ 此题太妙了…… 考虑给定的序列\\(a_i\\)，\\(i\\)表示 以\\(a_i\\)后面那个数为开头的后缀的排名 其实这是求后缀数组中用到的\\(rank\\)数组 如果我们知道 以\\(a_i\\)为开头的后缀的排名，就可以知道答案 考虑字符串是怎么排序的，先比第一位，再比下一位 也就是以\\(a_i\\)为第一关键字，\\(i\\)为第二关键字排序（考虑i的意义） 然后就好了 ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define mp make_pair#define X first#define Y secondusing namespace std;const int maxn=200005;int n,m;pair&lt;int,int&gt; a[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=0;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].X),a[i].Y=i; sort(a,a+1+n); int t=a[0].Y; for (int i=1;i&lt;=n;i++) printf(\"%d \",a[t].X),t=a[t].Y; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"}]},{"title":"【无向图最大团】BZOJ3632 外太空旅行","slug":"BZOJ3632","date":"2018-10-24T07:08:57.000Z","updated":"2018-10-24T07:13:56.000Z","comments":true,"path":"posts/BZOJ3632/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3632/","excerpt":"","text":"题面在这里 ​ 无向图最大团的随机算法： 每次随机一个n的排列，依次加入点，每个点都要与团内点有边 ​ 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=55;int n,a[maxn],ans=0;bool vis[maxn],d[maxn][maxn];void work()&#123; random_shuffle(a+1,a+1+n); cl(vis,0);int s=0; for (int i=1;i&lt;=n;i++) if (!vis[a[i]])&#123; s++; for (int j=1;j&lt;=n;j++) if (!d[a[i]][a[j]]) vis[a[j]]=1; &#125; ans=max(ans,s);&#125;int main()&#123; scanf(\"%d\",&amp;n);int x,y; while (~scanf(\"%d%d\",&amp;x,&amp;y)) d[x][y]=d[y][x]=1; for (int i=1;i&lt;=n;i++) a[i]=i; for (int i=1;i&lt;=10000;i++) work(); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"随机","slug":"随机","permalink":"http://oi.linkfqy.top/tags/随机/"}]},{"title":"BZOJ4419 [Shoi2013]发微博","slug":"BZOJ4419","date":"2018-10-23T12:01:06.000Z","updated":"2018-10-23T12:03:08.000Z","comments":true,"path":"posts/BZOJ4419/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4419/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005;int n,q,num[maxn],ans[maxn];set&lt;int&gt; S[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); while (q--)&#123; char c=getchar();while (c!='+'&amp;&amp;c!='-'&amp;&amp;c!='!') c=getchar(); if (c=='!')&#123; int x;scanf(\"%d\",&amp;x); num[x]++; &#125;else if (c=='+')&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); S[x].insert(y); S[y].insert(x); ans[x]-=num[y]; ans[y]-=num[x]; &#125;else&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); S[x].erase(y); S[y].erase(x); ans[x]+=num[y]; ans[y]+=num[x]; &#125; &#125; for (int i=1;i&lt;=n;i++) for (set&lt;int&gt;::iterator it=S[i].begin();it!=S[i].end();it++) ans[i]+=num[*it]; for (int i=1;i&lt;=n;i++) printf(\"%d \",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【最大权闭合子图】BZOJ3996 [TJOI2015]线性代数","slug":"BZOJ3996","date":"2018-10-23T07:55:38.000Z","updated":"2018-10-23T08:01:26.000Z","comments":true,"path":"posts/BZOJ3996/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3996/","excerpt":"","text":"题面在这里 ​ 把矩阵全部展开，最后得到这样的式子： \\[ \\sum_{i,j} B_{i,j}\\cdot A_i\\cdot A_j-\\sum_i C_i\\cdot A_i \\] 考虑取\\(B_{i,j}\\)的权值，则\\(A_i=A_j=1\\)，那么必须有\\(C_i+C_j\\)的代价 其实是一个最大权闭合子图的问题 最小割刷之 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=250505,maxe=1600005,INF=0x3f3f3f3f;int n,N,S,T,b[505][505],c[505],id[505][505];int son[maxe],nxt[maxe],lnk[maxn],flw[maxe],cap[maxe],tot;inline void add(int x,int y,int f)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int d[maxn],pos[maxn],que[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; que[1]=S;d[S]=0; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==INF&amp;&amp;cap[j]&gt;flw[j]) d[son[j]]=d[x]+1,que[++til]=son[j]; &#125; return d[T]!=INF;&#125;int dfs(int x,int flow)&#123; if (x==T||flow==0) return flow; int f,res=0; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f; flw[j^1]-=f; res+=f; flow-=f; if (flow==0) return res; &#125; return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); S=++N;T=++N;tot=1; int sum=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) scanf(\"%d\",&amp;b[i][j]),id[i][j]=++N,add(S,N,b[i][j]),sum+=b[i][j]; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;c[i]),add(i+N,T,c[i]); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) add(id[i][j],i+N,INF),add(id[i][j],j+N,INF); int ans=0; while (bfs())&#123; memcpy(pos,lnk,sizeof(pos)); ans+=dfs(S,INF); &#125; printf(\"%d\",sum-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","permalink":"http://oi.linkfqy.top/tags/最大权闭合子图/"}]},{"title":"BZOJ1131 [POI2008]Sta","slug":"BZOJ1131","date":"2018-10-22T12:02:09.000Z","updated":"2018-10-22T12:04:42.000Z","comments":true,"path":"posts/BZOJ1131/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1131/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=1000005,maxe=2000005;int n,siz[maxn],dep[maxn]; ll ans[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void getsiz(int x,int fa)&#123; siz[x]=1;dep[x]=dep[fa]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) getsiz(son[j],x),siz[x]+=siz[son[j]];&#125;void dfs(int x,int fa,ll now)&#123; ans[x]=now; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x,now-siz[son[j]]+n-siz[son[j]]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); getsiz(1,1); ll now=0; for (int i=1;i&lt;=n;i++) now+=dep[i]; dfs(1,1,now); int ID=1; for (int i=2;i&lt;=n;i++) if (ans[i]&gt;ans[ID]) ID=i; printf(\"%d\",ID); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【LCS+树状数组】BZOJ1264 [AHOI2006]基因匹配Match","slug":"BZOJ1264","date":"2018-10-22T11:44:42.000Z","updated":"2018-10-22T11:48:24.000Z","comments":true,"path":"posts/BZOJ1264/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1264/","excerpt":"","text":"题面在这里 ​ 考虑LCS的DP 先滚动数组，然后发现每个位置就是前缀最小值 因为每个数只出现5次，所以对于每个\\(i\\)，只有5个位置要更新 树状数组维护之 ​ 示例程序： 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,N,a[maxn],b[maxn];vector&lt;int&gt; pos[maxn];int BIT[maxn];#define lowbit(x) ((x)&amp;-(x))void ist(int x,int w)&#123; for (int i=x;i&lt;=N;i+=lowbit(i)) BIT[i]=max(BIT[i],w);&#125;int qry(int x)&#123; int res=0; for (int i=x;i;i-=lowbit(i)) res=max(res,BIT[i]); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n);N=n*5; for (int i=1;i&lt;=N;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=N;i++) scanf(\"%d\",&amp;b[i]),pos[b[i]].push_back(i); for (int i=1;i&lt;=N;i++) for (int j=4;j&gt;=0;j--) ist(pos[a[i]][j],qry(pos[a[i]][j]-1)+1); printf(\"%d\",qry(N)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"【Hall定理+线段树】BZOJ1135 [POI2009]Lyz","slug":"BZOJ1135","date":"2018-10-22T06:08:48.000Z","updated":"2018-10-22T06:24:50.000Z","comments":true,"path":"posts/BZOJ1135/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1135/","excerpt":"","text":"题面在这里 ​ Hall定理：二分图\\(G=(V_1,V_2,E)\\)中\\(|V_1|=n\\le|V_2|=m\\)，\\(G\\)中存在从\\(V_1\\)到\\(V_2\\)的完全匹配当且仅当\\(V_1\\)中任意\\(k\\)个点至少与\\(V_2\\)中\\(k\\)个点有边相连。 对于这题，因为连边都是连续的一段区间，所以只用考虑连续区间是否满足，即 \\[ \\sum_{i=l}^r a_i \\le (r-l+1+d)k \\\\ \\sum_{i=l}^r (a_i-k)\\le kd \\] 要对所有的\\(l,r\\)都成立 那么只需要序列\\(\\{a_i-k\\}\\)的最大连续子序列满足 所以用线段树维护，支持单点加 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=200005,maxs=800005;int n,m,q;ll K,d;ll s[maxs],mx[maxs],lm[maxs],rm[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x)&#123; s[x]=s[ls]+s[rs]; mx[x]=max(max(mx[ls],mx[rs]),rm[ls]+lm[rs]); lm[x]=max(lm[ls],s[ls]+lm[rs]); rm[x]=max(rm[rs],s[rs]+rm[ls]);&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;s[x]=mx[x]=lm[x]=rm[x]=-K;return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid); build(rs,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int k,int w)&#123; if (l==r) &#123;s[x]+=w;mx[x]=lm[x]=rm[x]=s[x];return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls,l,mid,k,w);else ist(rs,mid+1,r,k,w); pushup(x);&#125;int main()&#123; n=red(),q=red(),K=red(),d=red(),m=n-d; build(1,1,m); while (q--)&#123; int k=red(),w=red(); ist(1,1,m,k,w); if (mx[1]&lt;=K*d) puts(\"TAK\");else puts(\"NIE\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"BZOJ3555 [Ctsc2014]企鹅QQ","slug":"BZOJ3555","date":"2018-10-21T11:54:47.000Z","updated":"2018-10-21T11:55:48.000Z","comments":true,"path":"posts/BZOJ3555/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3555/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int maxn=30005,maxm=205;int n,m,s;ull pw[maxm],hsh[maxn][maxm],a[maxn];char ch[maxm];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;s); pw[0]=1; for (int i=1;i&lt;=m;i++) pw[i]=pw[i-1]*149; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",ch+1); for (int j=1;j&lt;=m;j++) hsh[i][j]=hsh[i][j-1]*149+ch[j]; &#125; int ans=0; for (int i=1;i&lt;=m;i++)&#123; for (int j=1;j&lt;=n;j++) a[j]=hsh[j][i-1]*pw[m-i]+hsh[j][m]-hsh[j][i]*pw[m-i]; sort(a+1,a+n+1); int s=0;a[0]=-1; for (int j=1;j&lt;=n;j++) if (a[j]!=a[j-1]) ans+=s*(s-1)/2,s=1; else s++; ans+=s*(s-1)/2; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"}]},{"title":"【小清新线段树】BZOJ3333 排队计划","slug":"BZOJ3333","date":"2018-10-21T11:02:28.000Z","updated":"2018-10-21T11:06:26.000Z","comments":true,"path":"posts/BZOJ3333/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3333/","excerpt":"","text":"题面在这里 ​ 考虑每个点对答案的贡献 是后面比自己小的个数 每次操作就相当于把一个区间内小于某值点贡献都变为0 小清新线段树即可 因为每个点只会被删除一次，每次删除有\\(O(\\log n)\\)的贡献 总复杂度\\(O(n\\log n)\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxs=1000005,INF=0x3f3f3f3f;int n,q,m,a[maxn],b[maxn],w[maxn];int BIT[maxn];#define lowbit(x) ((x)&amp;-(x))void ist(int x,int w)&#123; for (int i=x;i&lt;=m;i+=lowbit(i)) BIT[i]+=w;&#125;int qry(int x)&#123; int res=0; for (int i=x;i;i-=lowbit(i)) res+=BIT[i]; return res;&#125;int mn[maxs];ll ans;#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1void build(int x,int l,int r)&#123; if (l==r) &#123;mn[x]=a[l];return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); mn[x]=min(mn[ls],mn[rs]);&#125;void solve(int x,int l,int r,int ql,int qr,int ww)&#123; if (mn[x]&gt;ww||qr&lt;l||r&lt;ql) return; if (l==r) &#123;ans-=w[l];mn[x]=INF;return;&#125; int mid=l+r&gt;&gt;1; solve(ls,l,mid,ql,qr,ww); solve(rs,mid+1,r,ql,qr,ww); mn[x]=min(mn[ls],mn[rs]);&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) a[i]=b[i]=red(); sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=n;i&gt;=1;i--)&#123; a[i]=lower_bound(b+1,b+1+m,a[i])-b; ist(a[i],1); w[i]=qry(a[i]-1);ans+=w[i]; &#125; build(1,1,n); printf(\"%lld\\n\",ans); while (q--)&#123; int x=red(); solve(1,1,n,x,n,a[x]); printf(\"%lld\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"BZOJ2346 [Baltic 2011]Lamp","slug":"BZOJ2346","date":"2018-10-21T09:05:49.000Z","updated":"2018-10-21T09:07:24.000Z","comments":true,"path":"posts/BZOJ2346/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2346/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x));using namespace std;const int maxn=300005,maxe=1000005,INF=0x3f3f3f3f;int n,m; char a[505][505];#define ID(x,y) (((x)-1)*(m+1)+(y))int son[maxe],nxt[maxe],lnk[maxn],tot,w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int S,T,dst[maxn],que[maxn];bool vis[maxn];void spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=S;dst[S]=0;vis[S]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%s\",a[i]+1); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='/')&#123; add(ID(i+1,j),ID(i,j+1),0),add(ID(i,j+1),ID(i+1,j),0), add(ID(i,j),ID(i+1,j+1),1),add(ID(i+1,j+1),ID(i,j),1); &#125;else&#123; add(ID(i+1,j),ID(i,j+1),1),add(ID(i,j+1),ID(i+1,j),1), add(ID(i,j),ID(i+1,j+1),0),add(ID(i+1,j+1),ID(i,j),0); &#125; S=1,T=(n+1)*(m+1); spfa(); if (dst[T]==INF) puts(\"NO SOLUTION\");else printf(\"%d\",dst[T]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"【区间DP】BZOJ1939 [Croatian2010] Zuma","slug":"BZOJ1939","date":"2018-10-21T04:29:00.000Z","updated":"2018-10-21T04:58:50.000Z","comments":true,"path":"posts/BZOJ1939/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1939/","excerpt":"","text":"题面在这里 ​ 定义\\(f_{i,j,k}\\)表示消去区间\\([i,j]\\)以及后面与\\(a_j\\)同色的\\(k\\)个珠子 的最少步骤 则有如下转移： \\[ f_{i,j,k}=\\begin{cases} f_{i,j,k+1}+1 &amp;k\\lt K-1 \\\\ f_{i,j-1,0} &amp;k=K-1 \\\\ f_{i,x,k+1}+f_{x+1,j-1,0} &amp;i\\le x\\lt j ,a_x=a_j \\end{cases} \\] ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=105;int n,K,a[maxn],f[maxn][maxn][6];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); cl(f,63); for (int i=1;i&lt;=n;i++) for (int k=0;k&lt;K;k++) f[i][i][k]=K-k-1,f[i][i-1][k]=0; for (int L=1;L&lt;n;L++) for (int l=1;l+L&lt;=n;l++)&#123; int r=l+L; for (int k=K-1;~k;k--)&#123; if (k&lt;K-1) f[l][r][k]=min(f[l][r][k],f[l][r][k+1]+1); if (k==K-1) f[l][r][k]=min(f[l][r][k],f[l][r-1][0]); for (int i=l;i&lt;r;i++) if (a[r]==a[i]) f[l][r][k]=min(f[l][r][k],f[l][i][min(k+1,K-1)]+f[i+1][r-1][0]); &#125; &#125; printf(\"%d\\n\",f[1][n][0]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【势能分析】BZOJ2321 [BeiJing2011集训]星器","slug":"BZOJ2321","date":"2018-10-20T13:45:42.000Z","updated":"2018-10-20T14:04:00.000Z","comments":true,"path":"posts/BZOJ2321/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2321/","excerpt":"","text":"题面在这里 ​ 发现无论怎么操作，最后的答案都是一样的 考虑如何计算答案 定义一颗星\\((x,y)\\)具有势能\\(x^2+y^2\\) 假设对\\((x,y)\\)和\\((x,z)\\)两颗星使用魔法，有： \\[ E=2x^2+y^2+z^2 \\\\ E&#39;=2x^2+(y+1)^2+(z-1)^2 \\\\ E-E&#39;=2(z-y-1) \\] 而\\((z-y-1)\\)就是这次产生的魔力 所以初始势能-末态势能除以二就是答案了 ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;typedef long long ll;int n,m; ll E1=0,E2=0;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; int x;scanf(\"%d\",&amp;x); E1+=x*(i*i+j*j); &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; int x;scanf(\"%d\",&amp;x); E2+=x*(i*i+j*j); &#125; printf(\"%lld\",(E1-E2)/2); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"}]},{"title":"【树上差分+线段树合并】BZOJ3307 雨天的尾巴","slug":"BZOJ3307","date":"2018-10-20T03:10:13.000Z","updated":"2018-10-20T03:13:32.000Z","comments":true,"path":"posts/BZOJ3307/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3307/","excerpt":"","text":"题面在这里 ​ 考虑树上差分，给\\(x,y\\)打\\(+z\\)的标记，给\\(lca,fa_{lca}\\)打\\(-z\\)的标记 每个点合并子树的权值线段树，得到当前节点 可以只维护mx值，询问按优先级往下找 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005,maxs=4000005;int n,m,q,b[maxn],ans[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct data&#123; int x,y,w;&#125;Q[maxn];int ls[maxs],rs[maxs],mx[maxs],len,rt[maxn];void ist(int &amp;x,int l,int r,int k,int w)&#123; if (!x) &#123;x=++len;ls[x]=rs[x]=mx[x]=0;&#125; if (l==r) &#123;mx[x]+=w;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k,w);else ist(rs[x],mid+1,r,k,w); mx[x]=max(mx[ls[x]],mx[rs[x]]);&#125;int qry(int x,int l,int r)&#123; if (mx[x]==0) return 0; if (l==r) return b[l]; int mid=l+r&gt;&gt;1; if (mx[ls[x]]&gt;=mx[rs[x]]) return qry(ls[x],l,mid);else return qry(rs[x],mid+1,r);&#125;int merge(int x,int y,int l=1,int r=m)&#123; if (!x||!y) return x+y; if (l==r) &#123;mx[x]+=mx[y];return x;&#125; int mid=l+r&gt;&gt;1; ls[x]=merge(ls[x],ls[y],l,mid); rs[x]=merge(rs[x],rs[y],mid+1,r); mx[x]=max(mx[ls[x]],mx[rs[x]]); return x;&#125;int f[maxn][17],dep[maxn];void getdep(int x)&#123; dep[x]=dep[f[x][0]]+1; for (int j=lnk[x];j;j=nxt[j]) if (f[x][0]!=son[j]) f[son[j]][0]=x,getdep(son[j]);&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=16;~j;j--) if (dep[f[x][j]]&gt;=dep[y]) x=f[x][j]; if (x==y) return x; for (int j=16;~j;j--) if (f[x][j]!=f[y][j]) x=f[x][j],y=f[y][j]; return f[x][0];&#125;vector&lt;int&gt; V[maxn];#define pb push_backvoid dfs(int x)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=f[x][0])&#123; dfs(son[j]); rt[x]=merge(rt[x],rt[son[j]]); &#125; for (int i=0;i&lt;V[x].size();i++) if (V[x][i]&gt;0) ist(rt[x],1,m,V[x][i],1);else ist(rt[x],1,m,-V[x][i],-1); ans[x]=qry(rt[x],1,m);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); for (int i=1;i&lt;=q;i++) scanf(\"%d%d%d\",&amp;Q[i].x,&amp;Q[i].y,&amp;Q[i].w),b[i]=Q[i].w; sort(b+1,b+1+q); m=unique(b+1,b+1+q)-b-1; for (int i=1;i&lt;=q;i++) Q[i].w=lower_bound(b+1,b+1+m,Q[i].w)-b; getdep(1); for (int j=1;j&lt;=16;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; for (int i=1;i&lt;=q;i++)&#123; int lca=LCA(Q[i].x,Q[i].y); V[Q[i].x].pb(Q[i].w),V[Q[i].y].pb(Q[i].w); V[lca].pb(-Q[i].w);V[f[lca][0]].pb(-Q[i].w); &#125; dfs(1); for (int i=1;i&lt;=n;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"差分","slug":"差分","permalink":"http://oi.linkfqy.top/tags/差分/"}]},{"title":"【分块+并查集】Codeforces 896E Welcome home, Chtholly","slug":"CF896E","date":"2018-10-19T12:12:40.000Z","updated":"2018-10-19T12:26:58.000Z","comments":true,"path":"posts/CF896E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF896E/","excerpt":"","text":"题面在这里 ​ 考虑分块，两端的散块都可以暴力搞了 对于中间的整块，维护最大值\\(mx\\)，减标记\\(tag\\)，用并查集把相同值连在一起 修改：分两类做 \\(mx\\gt 2x\\)：先把值在\\([1,x]\\)的数加\\(x\\)，再把整个块减\\(x\\) \\(2x\\ge mx\\)：把值在\\([x+1,mx]\\)的数减\\(x\\) 询问：由并查集连通块大小直接得到 复杂度证明：分块的复杂度是\\(O(n\\sqrt n)\\)，现在只要证明对整块单次修改的复杂度 考虑块内的极差，修改操作其实在\\(O(x)\\)的时间内把极差减小了\\(x\\) 所以整块单次修改均摊是\\(O(1)\\)的 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxb=320;int n,m,q,a[maxn],fa[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int rt[maxb][maxn],cnt[maxb][maxn],mx[maxb],h[maxn],bg[maxb],ed[maxb],tag[maxb];void blocker()&#123; int S=sqrt(n); for (int i=1;i&lt;=n;i++)&#123; if (S*m&lt;i) bg[++m]=i; h[i]=m; if (i%S==0||i==n) ed[m]=i; &#125;&#125;void rebuild(int b)&#123; mx[b]=0; for (int i=bg[b];i&lt;=ed[b];i++)&#123; if (!rt[b][a[i]])&#123; rt[b][a[i]]=i; fa[i]=i; cnt[b][a[i]]=1; &#125;else&#123; fa[i]=rt[b][a[i]]; cnt[b][a[i]]++; &#125; mx[b]=max(mx[b],a[i]); &#125;&#125;int tmp[maxn];void pushdown(int b)&#123; for (int i=bg[b];i&lt;=ed[b];i++) if (getfa(i)==i) rt[b][a[i]]=0,cnt[b][a[i]]=0; for (int i=bg[b];i&lt;=ed[b];i++) tmp[i]=a[i]; for (int i=bg[b];i&lt;=ed[b];i++) a[i]=tmp[getfa(i)]-tag[b]; tag[b]=0;&#125;void ist_force(int l,int r,int x)&#123; for (int i=h[l];i&lt;=h[r];i++) pushdown(i); for (int i=l;i&lt;=r;i++) if (a[i]&gt;x) a[i]-=x; for (int i=h[l];i&lt;=h[r];i++) rebuild(i);&#125;int qry_force(int l,int r,int x)&#123; int res=0; for (int i=h[l];i&lt;=h[r];i++) pushdown(i); for (int i=l;i&lt;=r;i++) res+=(a[i]==x); for (int i=h[l];i&lt;=h[r];i++) rebuild(i); return res;&#125;void merge(int &amp;rt1,int &amp;rt2,int &amp;c1,int &amp;c2,int x)&#123; if (rt1) if (rt2) fa[rt1]=rt2,c2+=c1; else rt2=rt1,a[rt2]=x,c2=c1; rt1=c1=0;&#125;void ist(int b,int x)&#123; if (mx[b]-tag[b]&gt;2*x)&#123; for (int i=1+tag[b];i&lt;=x+tag[b];i++) merge(rt[b][i],rt[b][i+x],cnt[b][i],cnt[b][i+x],i+x); tag[b]+=x; &#125;else&#123; for (int i=x+1+tag[b];i&lt;=mx[b];i++) merge(rt[b][i],rt[b][i-x],cnt[b][i],cnt[b][i-x],i-x); while (!rt[b][mx[b]]) mx[b]--; &#125;&#125;int qry(int b,int x)&#123; return x+tag[b]&lt;=100000?cnt[b][x+tag[b]]:0;&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); blocker(); for (int i=1;i&lt;=m;i++) rebuild(i); while (q--)&#123; int c=red(),l=red(),r=red(),x=red(); if (c==1)&#123; if (h[l]==h[r]) ist_force(l,r,x);else&#123; ist_force(l,ed[h[l]],x); ist_force(bg[h[r]],r,x); for (int i=h[l]+1;i&lt;h[r];i++) ist(i,x); &#125; &#125;else&#123; int ans=0; if (h[l]==h[r]) ans=qry_force(l,r,x);else&#123; ans+=qry_force(l,ed[h[l]],x); ans+=qry_force(bg[h[r]],r,x); for (int i=h[l]+1;i&lt;h[r];i++) ans+=qry(i,x); &#125; printf(\"%d\\n\",ans); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"分块","slug":"分块","permalink":"http://oi.linkfqy.top/tags/分块/"}]},{"title":"BZOJ4870 [Shoi2017]组合数问题","slug":"BZOJ4870","date":"2018-10-17T11:30:10.000Z","updated":"2018-10-17T11:37:34.000Z","comments":true,"path":"posts/BZOJ4870/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4870/","excerpt":"","text":"题面在这里 ​ 考虑实际意义，就是从\\(nk\\)个中选\\(r\\)个，选的个数是在模k意义下的 仍旧满足\\(f_{i,j}=f_{i-1,j}+f_{i-1,j-1}\\) 矩乘即可 ​ WA了2发的经历告诉我构造转移矩阵一定不能赋值！！！！ ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;int n,p,k,r;struct matrix&#123; int n,m; ll s[50][50]; matrix () &#123;cl(s,0);n=m=0;&#125;&#125;t,ans;inline matrix operator*(const matrix&amp;a,const matrix&amp;b)&#123; matrix c; c.n=a.n;c.m=b.m; for (int i=0;i&lt;c.n;i++) for (int j=0;j&lt;c.m;j++) for (int k=0;k&lt;a.m;k++) (c.s[i][j]+=a.s[i][k]*b.s[k][j])%=p; return c;&#125;matrix power(matrix a,ll b)&#123; matrix w=a,res; res.n=res.m=k; for (int i=0;i&lt;k;i++) res.s[i][i]=1; while (b)&#123; if (b&amp;1) res=res*w; w=w*w; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(\"%d%d%d%d\",&amp;n,&amp;p,&amp;k,&amp;r); ans.n=k;ans.m=1; ans.s[0][0]=1; t.n=t.m=k; for (int i=0;i&lt;k;i++) t.s[i][i]++,t.s[i][(i-1+k)%k]++; ans=power(t,(ll)n*k)*ans; printf(\"%lld\",ans.s[r][0]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"矩阵","slug":"矩阵","permalink":"http://oi.linkfqy.top/tags/矩阵/"}]},{"title":"Codeforces 633H Fibonacci-ish II","slug":"CF633H","date":"2018-10-16T23:19:48.000Z","updated":"2018-10-16T23:24:20.000Z","comments":true,"path":"posts/CF633H/","link":"","permalink":"http://oi.linkfqy.top/posts/CF633H/","excerpt":"","text":"题面在这里 ​ 这题正解是莫队+线段树维护矩乘，复杂度\\(O(n\\sqrt n\\log n)\\) 然而常数过大，还没有暴力跑得快…… ​ 示例程序： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define mp make_pair()#define X first#define Y secondusing namespace std;const int maxn=100005;int n,q,MOD,f[maxn],L[maxn],R[maxn],stp[maxn],lst[maxn],ans[maxn];pair&lt;int,int&gt; a[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;MOD); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i].X),a[i].Y=i; f[1]=1; for (int i=2;i&lt;=n;i++) f[i]=(f[i-1]+f[i-2])%MOD; sort(a+1,a+1+n); scanf(\"%d\",&amp;q); for (int i=1;i&lt;=q;i++) scanf(\"%d%d\",&amp;L[i],&amp;R[i]); for (int i=1;i&lt;=n;i++)&#123; int d=a[i].X%MOD,id=a[i].Y; for (int j=1;j&lt;=q;j++) if (L[j]&lt;=id&amp;&amp;id&lt;=R[j]&amp;&amp;lst[j]!=a[i].X) (ans[j]+=f[++stp[j]]*d)%=MOD,lst[j]=a[i].X; &#125; for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"矩阵","slug":"矩阵","permalink":"http://oi.linkfqy.top/tags/矩阵/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"莫队","slug":"莫队","permalink":"http://oi.linkfqy.top/tags/莫队/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ4974 [Lydsy1708月赛]字符串大师","slug":"BZOJ4974","date":"2018-10-16T22:44:52.000Z","updated":"2018-10-16T22:46:46.000Z","comments":true,"path":"posts/BZOJ4974/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4974/","excerpt":"","text":"题面在这里 ​ 直接用KMP XJB贪心就好了 ​ 示例程序： 123456789101112131415161718192021#include&lt;cstdio&gt;const int maxn=100005;int n,nxt[maxn];char s[maxn];bool check(int i,char c)&#123; s[i]=c; int j=nxt[i-1]; while (j&amp;&amp;s[j+1]!=s[i]) j=nxt[j]; return (s[j+1]==s[i]?j+1:j)==nxt[i];&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;nxt[i]),nxt[i]=i-nxt[i]; s[1]='a'; for (int i=2;i&lt;=n;i++)&#123; for (char c='a';c&lt;='z';c++) if (check(i,c)) break; &#125; printf(\"%s\",s+1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"KMP","slug":"KMP","permalink":"http://oi.linkfqy.top/tags/KMP/"}]},{"title":"BZOJ2750 [HAOI2012]Road","slug":"BZOJ2750","date":"2018-10-16T22:41:07.000Z","updated":"2018-10-16T22:44:26.000Z","comments":true,"path":"posts/BZOJ2750/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2750/","excerpt":"","text":"题面在这里 ​ 枚举起点，建出由最短路径构成的DAG 在DAG上按拓扑序刷DP即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=1505,maxe=15005,MOD=1e9+7;int n,e,S,ans[maxe];int son[maxe],nxt[maxe],lnk[maxn],lnk1[maxn],lnk2[maxn],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;inline void add(int x,int y,int z,int *lnk)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int que[maxn],dst[maxn];bool vis[maxn];void spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=S;dst[S]=0;vis[S]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125;&#125;int f[maxn],g[maxn],f1[maxn],f2[maxn],hed,til;void topo(int *lnk,int *f)&#123; hed=0,til=0; for (int i=1;i&lt;=n;i++) if (!f[i]) que[++til]=i; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j])&#123; f[son[j]]--; if (f[son[j]]==0) que[++til]=son[j]; &#125; &#125;&#125;void DP()&#123; cl(lnk1,0);cl(lnk2,0);tot=e;cl(f1,0);cl(f2,0); for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (dst[son[j]]==dst[i]+w[j]) add(i,son[j],0,lnk1),add(son[j],i,0,lnk2),f1[son[j]]++,f2[i]++; topo(lnk1,f1); cl(f,0);cl(g,0); f[S]=1; for (int i=1;i&lt;=til;i++)&#123; int x=que[i]; for (int j=lnk1[x];j;j=nxt[j]) (f[son[j]]+=f[x])%=MOD; &#125; topo(lnk2,f2); for (int i=1;i&lt;=til;i++) g[que[i]]=1; for (int i=1;i&lt;=til;i++)&#123; int x=que[i]; for (int j=lnk2[x];j;j=nxt[j]) (g[son[j]]+=g[x])%=MOD; &#125; for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (dst[son[j]]==dst[i]+w[j]) (ans[j]+=(ll)f[i]*g[son[j]])%=MOD;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z); for (S=1;S&lt;=n;S++)&#123; spfa();DP(); &#125; for (int i=1;i&lt;=e;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"BZOJ4540 [Hnoi2016]序列","slug":"BZOJ4540","date":"2018-10-15T23:14:22.000Z","updated":"2018-10-15T23:24:24.000Z","comments":true,"path":"posts/BZOJ4540/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4540/","excerpt":"","text":"题面在这里 ​ 参考题解：Ngshily 原来cmath里的log2()函数真的很慢…… 写ST表还是自己造一个对数表好了 坑点：莫队一定要先移R指针！不然有可能会出现L&gt;R，询问函数写得不好就炸了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;int n,q,h[maxn]; ll a[maxn];struct data&#123; int l,r,id; bool operator&lt;(const data&amp;b)const&#123; if (h[l]==h[b.l]) return r&lt;b.r; return l&lt;b.l; &#125;&#125;Q[maxn];void blocker()&#123; int k=sqrt(n); for (int i=1;i&lt;=n;i++) h[i]=(i-1)/k+1;&#125;int stk[maxn],top,f[maxn][18],log_2[maxn];ll fl[maxn],fr[maxn];int Min(int i,int j) &#123;return a[i]&lt;a[j]?i:j;&#125;void DP()&#123; top=0; for (int i=1;i&lt;=n;i++)&#123; while (top&amp;&amp;a[stk[top]]&gt;=a[i]) top--; fr[i]=fr[stk[top]]+a[i]*(i-stk[top]); stk[++top]=i; &#125; top=0;stk[0]=n+1; for (int i=n;i&gt;=1;i--)&#123; while (top&amp;&amp;a[stk[top]]&gt;=a[i]) top--; fl[i]=fl[stk[top]]+a[i]*(stk[top]-i); stk[++top]=i; &#125; log_2[1]=0; for (int i=2;i&lt;=n;i++) log_2[i]=log_2[i&gt;&gt;1]+1; for (int i=1;i&lt;=n;i++) f[i][0]=i; for (int j=1;j&lt;=log_2[n];j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=Min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);&#125;int qry(int l,int r)&#123; int j=log_2[r-l+1]; return Min(f[l][j],f[r-(1&lt;&lt;j)+1][j]);&#125;ll ANS[maxn];ll istl(int l,int r)&#123; int p=qry(l,r); return a[p]*(r-p+1)+fl[l]-fl[p];&#125;ll istr(int l,int r)&#123; int p=qry(l,r); return a[p]*(p-l+1)+fr[r]-fr[p];&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); for (int i=1;i&lt;=q;i++) Q[i].l=red(),Q[i].r=red(),Q[i].id=i; blocker(); sort(Q+1,Q+1+q); DP(); int L=1,R=0;ll ans=0; for (int i=1;i&lt;=q;i++)&#123; while (Q[i].r&gt;R) ans+=istr(L,++R); while (Q[i].r&lt;R) ans-=istr(L,R--); while (Q[i].l&lt;L) ans+=istl(--L,R); while (Q[i].l&gt;L) ans-=istl(L++,R); ANS[Q[i].id]=ans; &#125; for (int i=1;i&lt;=q;i++) printf(\"%lld\\n\",ANS[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://oi.linkfqy.top/tags/莫队/"}]},{"title":"BZOJ1449&&BZOJ2895 [JSOI2009]球队收益","slug":"BZOJ1449_BZOJ2895","date":"2018-10-14T11:51:35.000Z","updated":"2018-10-14T12:26:10.000Z","comments":true,"path":"posts/BZOJ1449_BZOJ2895/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1449_BZOJ2895/","excerpt":"","text":"题面在这里 ​ 需要转化一下，假设接下来所有人都是输 然后只需要计算赢比赛的增量就好了 每场比赛只有一队能赢，这个很好控制，对每场比赛\\(i\\)连边\\((S,i,1,0),(i,a_i,1,0),(i,b_i,1,0)\\)即可 考虑一支球队\\(i\\)从赢\\(win_i\\)场变成赢\\(win_i+1\\)场的代价是： \\[ W_i=C_i\\cdot(2win_i+1)-D_i\\cdot(2lose_i-1) \\] 对每场比赛\\(i\\)连边\\((a_i,T,1,W_{a_i}),(b_i,T,1,W_{b_i})\\) 做最小费用最大流即可 这样如果一支球队出现了\\(k\\)次，就表示了赢第\\(win\\)次到赢第\\(win+k\\)次的所有代价（这只球队最多再赢\\(k\\)次） 如何保证一定先取赢第\\(i\\)次的代价，再去赢第\\(i+1\\)次的代价呢？ 考虑上面那个\\(W\\)是随\\(win\\)递增的，所以对于\\(a_i\\)费用流时一定先取小的代价，即次序更前面的代价 ​ 其实这就是凸函数的斜率单调，可以用费用流保证次序的先后，这个套路非常有用 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=10005,maxe=10005,INF=0x3f3f3f3f;int n,m,S,T,win[maxn],los[maxn],a[maxn],b[maxn],c[maxn],d[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot,flw[maxe],cap[maxe],w[maxe];inline void add(int x,int y,int f,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;int que[maxn],dst[maxn],fa[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=S;vis[S]=1;dst[S]=0; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (flw[j]&lt;cap[j]&amp;&amp;dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; fa[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125; return dst[T]!=INF;&#125;int main()&#123; n=red(),m=red(); for (int i=1;i&lt;=n;i++) win[i]=red(),los[i]=red(),c[i]=red(),d[i]=red(); for (int i=1;i&lt;=m;i++) a[i]=red(),b[i]=red(),los[a[i]]++,los[b[i]]++; int ans=0; for (int i=1;i&lt;=n;i++) ans+=c[i]*win[i]*win[i]+d[i]*los[i]*los[i]; tot=1;S=n+m+1;T=S+1; for (int i=1;i&lt;=m;i++)&#123; add(S,i+n,1,0); add(i+n,a[i],1,0); add(i+n,b[i],1,0); add(a[i],T,1,c[a[i]]*(win[a[i]]*2+1)-d[a[i]]*(los[a[i]]*2-1)); win[a[i]]++;los[a[i]]--; add(b[i],T,1,c[b[i]]*(win[b[i]]*2+1)-d[b[i]]*(los[b[i]]*2-1)); win[b[i]]++;los[b[i]]--; &#125; while (spfa())&#123; int Min=INF; for (int x=T;x!=S;x=fa[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=fa[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; ans+=Min*dst[T]; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"POJ3680 Intervals","slug":"POJ3680","date":"2018-10-13T00:32:09.000Z","updated":"2018-10-13T00:50:48.000Z","comments":true,"path":"posts/POJ3680/","link":"","permalink":"http://oi.linkfqy.top/posts/POJ3680/","excerpt":"","text":"题面在这里 ​ 因为是开区间，需要限制 被覆盖不超过K次 的点一定在区间端点之间 那么先离散所有端点，i向i+1连边\\((+\\infty,0)\\) 源点向1，n向汇点连边\\((K,0)\\) 对于每个区间，连边\\((l_i,r_i,1,w_i)\\) 最大费用流即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=405,maxe=6*maxn,INF=0x3f3f3f3f;int tst,n,N,K,S,T,b[maxn];struct data&#123; int l,r,w;&#125;a[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot,flw[maxe],cap[maxe],w[maxe];inline void add(int x,int y,int f,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;int que[maxn],dst[maxn],fa[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(vis,0);cl(dst,192); int hed=0,til=1; que[1]=S;dst[S]=0;vis[S]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (cap[j]&gt;flw[j]&amp;&amp;dst[son[j]]&lt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; fa[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]; &#125; &#125; return dst[T]!=0xc0c0c0c0;&#125;int main()&#123; tst=red(); while (tst--)&#123; n=red(),K=red();N=0; for (int i=1;i&lt;=n;i++) b[++N]=a[i].l=red(),b[++N]=a[i].r=red(),a[i].w=red(); sort(b+1,b+1+N); N=unique(b+1,b+1+N)-b-1; tot=1;cl(lnk,0);S=0;T=N+1; for (int i=0;i&lt;=N;i++) add(i,i+1,K,0); for (int i=1;i&lt;=n;i++)&#123; a[i].l=lower_bound(b+1,b+1+N,a[i].l)-b; a[i].r=lower_bound(b+1,b+1+N,a[i].r)-b; add(a[i].l,a[i].r,1,a[i].w); &#125; int ans=0; while (spfa())&#123; int Min=INF; for (int x=T;x!=S;x=fa[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=fa[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; ans+=Min*dst[T]; &#125; printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"POJ","slug":"POJ","permalink":"http://oi.linkfqy.top/tags/POJ/"}]},{"title":"BZOJ2809 [Apio2012]dispatching","slug":"BZOJ2809","date":"2018-10-12T09:02:11.000Z","updated":"2018-10-12T09:08:30.000Z","comments":true,"path":"posts/BZOJ2809/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2809/","excerpt":"","text":"题面在这里 ​ 对于每个子树，显然选择薪水最小的几个忍者比较好 那么就直接可并堆 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxe=100005;int n,M; ll ans,l[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int key[maxn],ls[maxn],rs[maxn],siz[maxn],rt[maxn]; ll sum[maxn];inline void pushup(int x) &#123;siz[x]=siz[ls[x]]+siz[rs[x]]+1;sum[x]=sum[ls[x]]+sum[rs[x]]+key[x];&#125;int merge(int a,int b)&#123; if (!a||!b) return a+b; if (key[a]&lt;key[b]) swap(a,b); if (rand()&amp;1) ls[a]=merge(ls[a],b);else rs[a]=merge(rs[a],b); pushup(a); return a;&#125;int del(int a)&#123; if (!a) return 0; return merge(ls[a],rs[a]);&#125;void dfs(int x)&#123; for (int j=lnk[x];j;j=nxt[j])&#123; dfs(son[j]); rt[x]=merge(rt[x],rt[son[j]]); &#125; while (sum[rt[x]]&gt;M) rt[x]=del(rt[x]); ans=max(ans,l[x]*siz[rt[x]]);&#125;int main()&#123; n=red(),M=red(); for (int i=1;i&lt;=n;i++)&#123; int x=red();add(x,i); sum[i]=key[i]=red(),l[i]=red(); rt[i]=i;siz[i]=1; &#125; dfs(1); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"可并堆","slug":"可并堆","permalink":"http://oi.linkfqy.top/tags/可并堆/"}]},{"title":"【打标记可并堆】BZOJ2333 [SCOI2011]棘手的操作","slug":"BZOJ2333","date":"2018-10-12T03:17:05.000Z","updated":"2018-10-12T03:28:04.000Z","comments":true,"path":"posts/BZOJ2333/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2333/","excerpt":"","text":"题面在这里 ​ 直接上可并堆。 几个点： A1和F1操作需要手动把祖先的标记都传下来，因为随机堆的深度期望有保障，可以暴力搞 F3操作是询问所有堆顶的最大值，这里用multiset维护，所有修改堆顶的操作都要注意 实测随机堆使用rand()函数并不会慢到哪里去 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;inline void reads(char *s)&#123; char ch=nc(); while (ch&lt;'A'||'Z'&lt;ch) ch=nc(); int t=0; while ('0'&lt;=ch&amp;&amp;ch&lt;='9'||'A'&lt;=ch&amp;&amp;ch&lt;='Z') s[t++]=ch,ch=nc(); s[t]=0;&#125;inline int Rand() &#123;static int x=31253125;x+=(x&lt;&lt;4)+1;return x;&#125;const int maxn=300005;int n,q,fa[maxn],rt[maxn];int ls[maxn],rs[maxn],key[maxn],ad[maxn],f[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline void addad(int x,int w) &#123;if (x) key[x]+=w,ad[x]+=w;&#125;inline void pushdown(int x)&#123; if (ad[x]) addad(ls[x],ad[x]),addad(rs[x],ad[x]),ad[x]=0;&#125;int merge(int a,int b)&#123; if (!a||!b) return a+b; if (key[a]&lt;key[b]) swap(a,b); pushdown(a); if (Rand()&amp;1) ls[a]=merge(ls[a],b);else rs[a]=merge(rs[a],b); if (ls[a]) f[ls[a]]=a; if (rs[a]) f[rs[a]]=a; f[a]=0; return a;&#125;int stk[maxn];inline void pushtag(int x)&#123; stk[stk[0]=1]=x; for (int i=x;f[i];i=f[i]) stk[++stk[0]]=f[i]; while (stk[0]) pushdown(stk[stk[0]--]);&#125;multiset&lt;int&gt; S;inline void erase(int x) &#123;S.erase(S.find(x));&#125;int main()&#123; n=red(); key[0]=0xc0c0c0c0; for (int i=1;i&lt;=n;i++) key[i]=red(),fa[i]=rt[i]=i,S.insert(key[i]); q=red(); char s[5];int AD=0; while (q--)&#123; reads(s); if (s[0]=='U')&#123; int x=red(),y=red(),fx=getfa(x),fy=getfa(y); if (fx==fy) continue; erase(key[rt[fx]]);erase(key[rt[fy]]); rt[fy]=merge(rt[fy],rt[fx]); fa[fx]=fy; S.insert(key[rt[fy]]); &#125;else if (s[0]=='A')&#123; if (s[1]=='1')&#123; int x=red(),w=red(); pushtag(x); erase(key[rt[getfa(x)]]); if (ls[f[x]]==x) ls[f[x]]=0;else rs[f[x]]=0; int fx=getfa(x); if (f[x]) rt[fx]=merge(rt[fx],merge(ls[x],rs[x])); else rt[fx]=merge(ls[x],rs[x]); f[x]=ls[x]=rs[x]=0; key[x]+=w; rt[fx]=merge(rt[fx],x); S.insert(key[rt[fx]]); &#125;else if (s[1]=='2')&#123; int x=red(),w=red(); int fx=getfa(x); erase(key[rt[fx]]); addad(rt[fx],w); S.insert(key[rt[fx]]); &#125;else AD+=red(); &#125;else&#123; if (s[1]=='1')&#123; int x=red(); pushtag(x); printf(\"%d\\n\",AD+key[x]); &#125;else if (s[1]=='2')&#123; int x=red(),fx=getfa(x); printf(\"%d\\n\",AD+key[rt[fx]]); &#125;else printf(\"%d\\n\",*(--S.end())+AD); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"可并堆","slug":"可并堆","permalink":"http://oi.linkfqy.top/tags/可并堆/"}]},{"title":"【打标记可并堆】BZOJ4003 [JLOI2015]城池攻占","slug":"BZOJ4003","date":"2018-10-11T12:20:35.000Z","updated":"2018-10-11T12:32:54.000Z","comments":true,"path":"posts/BZOJ4003/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4003/","excerpt":"","text":"题面在这里 ​ 因为任意操作都不会改变骑士战斗力的相对大小 直接可并堆就好了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=300005,maxe=300005;int n,m,a[maxn],c[maxn],ans[maxn*2];ll h[maxn],v[maxn];int son[maxe],lnk[maxn],nxt[maxe],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int ls[maxn],rs[maxn],rt[maxn],id[maxn];ll key[maxn],ad[maxn],ml[maxn];inline void addad(int x,ll w) &#123;if (x) key[x]+=w,ad[x]+=w;&#125;inline void addml(int x,ll w) &#123;if (x) key[x]*=w,ml[x]*=w,ad[x]*=w;&#125;inline void pushdown(int x)&#123; if (ml[x]!=1) addml(ls[x],ml[x]),addml(rs[x],ml[x]),ml[x]=1; if (ad[x]!=0) addad(ls[x],ad[x]),addad(rs[x],ad[x]),ad[x]=0;&#125;int merge(int a,int b)&#123; if (!a||!b) return a+b; if (key[a]&gt;key[b]) swap(a,b); pushdown(a);pushdown(b); if (rand()&amp;1) ls[a]=merge(ls[a],b);else rs[a]=merge(rs[a],b); return a;&#125;int del(int a)&#123; if (!a) return 0; pushdown(a); return merge(ls[a],rs[a]);&#125;int dep[maxn];void dfs(int x)&#123; for (int j=lnk[x];j;j=nxt[j])&#123; dep[son[j]]=dep[x]+1; dfs(son[j]); rt[x]=merge(rt[son[j]],rt[x]); &#125; while (rt[x]&amp;&amp;key[rt[x]]&lt;h[x])&#123; ans[x]++; ans[rt[x]+n]=dep[c[rt[x]]]-dep[x]; rt[x]=del(rt[x]); &#125; if (a[x]==0) addad(rt[x],v[x]); else addml(rt[x],v[x]);&#125;int main()&#123; srand(19260817); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;h[i]); for (int i=2,x;i&lt;=n;i++) scanf(\"%d%d%lld\",&amp;x,&amp;a[i],&amp;v[i]),add(x,i); key[0]=1e18; for (int i=1;i&lt;=m;i++)&#123; int x; scanf(\"%lld%d\",&amp;key[i],&amp;x);ad[i]=0;ml[i]=1; c[i]=x; rt[x]=merge(rt[x],i); &#125; dfs(1); while (rt[1])&#123; ans[rt[1]+n]=dep[c[rt[1]]]+1; rt[1]=del(rt[1]); &#125; for (int i=1;i&lt;=n+m;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"可并堆","slug":"可并堆","permalink":"http://oi.linkfqy.top/tags/可并堆/"}]},{"title":"BZOJ1965 [Ahoi2005]SHUFFLE 洗牌","slug":"BZOJ1965","date":"2018-10-10T10:40:32.000Z","updated":"2018-10-10T10:46:50.000Z","comments":true,"path":"posts/BZOJ1965/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1965/","excerpt":"","text":"题面在这里 ​ \\[ x\\cdot 2^m\\equiv L\\pmod {n+1} \\\\ x\\equiv L\\cdot \\left( \\frac {n+2} 2 \\right)^m \\pmod {n+1} \\] ​ 示例程序： 123456789101112131415161718#include&lt;cstdio&gt;typedef long long ll;ll n,m,l,MOD;ll power(ll a,ll b)&#123; ll w=a%MOD,res=1; while (b)&#123; if (b&amp;1) (res*=w)%=MOD; (w*=w)%=MOD; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(\"%lld%lld%lld\",&amp;n,&amp;m,&amp;l);MOD=n+1; printf(\"%lld\",l*power(n/2+1,m)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【线段树+矩阵乘法】Codeforces 719E Sasha and Array","slug":"CF719E","date":"2018-10-10T10:19:45.000Z","updated":"2018-10-10T10:23:12.000Z","comments":true,"path":"posts/CF719E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF719E/","excerpt":"","text":"题面在这里 ​ 因为矩乘是满足分配率和结合律的 所以直接用线段树维护矩阵即可 修改的值和懒标记都是一个矩阵 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;typedef long long ll;const int maxn=100005,maxs=400005,MOD=1e9+7;int n,q;struct matrix&#123; int n,m; ll s[2][2]; matrix () &#123;n=m=0;s[0][0]=s[0][1]=s[1][0]=s[1][1]=0;&#125;&#125;a[maxn],t,one;inline matrix operator*(const matrix&amp;a,const matrix&amp;b)&#123; matrix c; c.n=a.n;c.m=b.m; for (int i=0;i&lt;c.n;i++) for (int j=0;j&lt;c.m;j++) for (int k=0;k&lt;a.m;k++) (c.s[i][j]+=a.s[i][k]*b.s[k][j]%MOD)%=MOD; return c;&#125;inline matrix operator+(const matrix&amp;a,const matrix&amp;b)&#123; matrix c; c.n=a.n;c.m=b.m; for (int i=0;i&lt;c.n;i++) for (int j=0;j&lt;c.m;j++) c.s[i][j]=(a.s[i][j]+b.s[i][j])%MOD; return c;&#125;inline bool operator==(const matrix&amp;a,const matrix&amp;b)&#123; for (int i=0;i&lt;2;i++) for (int j=0;j&lt;2;j++) if (a.s[i][j]!=b.s[i][j]) return 0; return 1;&#125;inline matrix power(matrix a,int b)&#123; matrix w=a,res=one; while (b)&#123; if (b&amp;1) res=res*w; w=w*w; b&gt;&gt;=1; &#125; return res;&#125;matrix m[maxs],tg[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x) &#123;m[x]=m[ls]+m[rs];&#125;inline void addtg(int x,matrix w) &#123;m[x]=w*m[x];tg[x]=w*tg[x];&#125;inline void pushdown(int x)&#123; if (!(tg[x]==one)) addtg(ls,tg[x]),addtg(rs,tg[x]),tg[x]=one;&#125;void build(int x,int l,int r)&#123; tg[x]=one; if (l==r) &#123;m[x]=a[l];return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,matrix w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addtg(x,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(ls,l,mid,ql,qr,w); ist(rs,mid+1,r,ql,qr,w); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return m[x].s[1][0]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return (qry(ls,l,mid,ql,qr)+qry(rs,mid+1,r,ql,qr))%MOD;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); t.n=t.m=2; t.s[0][0]=t.s[0][1]=t.s[1][0]=1; one.n=one.m=2; one.s[0][0]=one.s[1][1]=1; for (int i=1;i&lt;=n;i++)&#123; int x;scanf(\"%d\",&amp;x); a[i].n=2;a[i].m=1;a[i].s[0][0]=a[i].s[1][0]=1; a[i]=power(t,x-1)*a[i]; &#125; build(1,1,n); while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1)&#123; int l,r,x;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;x); ist(1,1,n,l,r,power(t,x)); &#125;else&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%lld\\n\",qry(1,1,n,l,r)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"矩阵","slug":"矩阵","permalink":"http://oi.linkfqy.top/tags/矩阵/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【状压+期望DP，定积分】BZOJ3925 [Zjoi2015]地震后的幻想乡","slug":"BZOJ3925","date":"2018-10-09T11:26:23.000Z","updated":"2018-10-09T11:30:52.000Z","comments":true,"path":"posts/BZOJ3925/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3925/","excerpt":"","text":"以下是ChesterKing神仙的题解： ​ ​ 题目传送门 这题是真的神仙题……整整花了我两个礼拜来理解这题 首先这题据我了解有三种做法：纯OI做法、积分+数学推导、直接积分 请做好一定的心理准备，接下来的东西可能有点难理解（好像不是一点点的难吧……） 1.纯OI做法 首先我们根据期望的线性性，可以得到\\(ans=\\sum_{x=0}^mw(x)\\times p(x)\\)，其中\\(w(x)\\)为最大边为\\(x\\)时的对答案的贡献，\\(p(x)\\)为最大边为\\(x\\)时的概率。 由题目所给信息“对于\\(n\\)个之\\([0,1]\\)间的随机变量\\(x1,x2,...,xn\\)，第\\(k\\)小的那个的期望值是\\(\\frac{k}{n+1}\\)”可知：\\(w(x)=\\frac{x}{m+1}\\)。 \\(\\therefore ans=\\sum_{x=0}^m\\frac{x}{m+1}\\times p(x)\\) 设\\(f(x)\\)为最大边权的排名\\(\\ge x\\)的概率，则\\(p(x)=f(x-1)-f(x)\\)。 \\[ \\therefore ans=\\frac{1}{m+1}\\times[f(0)-f(1)]+\\frac{2}{m+1}\\times[f(1)-f(2)]+...+\\frac{m}{m+1}\\times[f(m-1)-f(m)]+\\frac{m+1}{m+1}\\times[f(m)-f(m+1)] \\] \\(\\because f(0)=1,f(m+1)=0\\) \\[ \\therefore ans=\\frac{1}{m+1}\\sum_{x=0}^mf(x) \\] 定义\\(f[S][i]\\)为点集为\\(S\\)，选取了\\(i\\)条边使得点集不连通的方案数；同理，定义\\(g[S][i]\\)为点集为\\(S\\)，选取了\\(i\\)条边使得点集连通的方案数。 易得\\(f[S][i]+g[S][i]={i\\choose cnt[s]}\\)，其中\\(cnt[S]\\)为点集\\(S\\)内的边数。 可以通过固定某定点\\(P\\)来进行转移，以达到不重复、不遗漏的计数。 \\[ f[S][i+j]=\\sum_{P \\in S,T \\subset S}g[T][i]\\times{j \\choose cnt[S-T]} \\] 那么最终答案即为\\(ans=\\frac{1}{m+1}\\sum_{x=0}^m\\frac{f[all][x]}{x \\choose cnt[all]}\\)。 附上AC代码： 12345678910111213141516171819202122232425262728293031#include &lt;cstdio&gt;using namespace std;typedef long long ll;const int N=11,M=46;int n,m,e[N],sz[1&lt;&lt;N],cnt[1&lt;&lt;N],wz;ll c[M][M],f[1&lt;&lt;N][M],g[1&lt;&lt;N][M];double ans;int main(void)&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1,x,y; i&lt;=m; ++i) scanf(\"%d%d\",&amp;x,&amp;y),--x,--y,e[x]|=1&lt;&lt;y,e[y]|=1&lt;&lt;x; c[0][0]=1; for (int i=1; i&lt;=m; ++i)&#123; c[i][0]=1; for (int j=1; j&lt;=i; ++j) c[i][j]=c[i-1][j-1]+c[i-1][j]; &#125; for (int sub=1; sub&lt;(1&lt;&lt;n); ++sub)&#123; if ((sz[sub]=sz[sub&gt;&gt;1]+(sub&amp;1))==1)&#123;g[sub][0]=1; continue;&#125; for (int i=0; i&lt;n; ++i) if ((sub&gt;&gt;i)&amp;1) cnt[sub]+=sz[e[i]&amp;sub]; cnt[sub]&gt;&gt;=1,wz=sub&amp;-sub; for (int opt=(sub-1)&amp;sub; opt; opt=(opt-1)&amp;sub) if (opt&amp;wz) for (int i=0; i&lt;=cnt[opt]; ++i) for (int j=0; j&lt;=cnt[opt^sub]; ++j) f[sub][i+j]+=g[opt][i]*c[cnt[opt^sub]][j]; for (int i=0; i&lt;=cnt[sub]; ++i) g[sub][i]=c[cnt[sub]][i]-f[sub][i]; &#125; for (int i=0; i&lt;=m; ++i) ans+=(double)f[(1&lt;&lt;n)-1][i]/c[cnt[(1&lt;&lt;n)-1]][i]; return printf(\"%.6lf\\n\",ans/=m+1),0;&#125; 接下来的两种做法可能需要一定的高等数学知识，至于定积分、求导之类的运算法则，出门左拐度娘处。 讲接下来的两种做法之前，我们先来证明一个对于我个人很难理解的东西，因为接下来的做法都要用到。 求证：\\(ans=\\int_0^1f(x){\\rm d}x\\)，其中\\(f(x)\\)为答案\\(&gt;x\\)的概率。 证明：设\\(p(x)\\)为答案\\(=x\\)的概率 易得：\\(p(x)=\\lim_{\\Delta x \\rightarrow 0}\\frac{f(x)-f(x+\\Delta x)}{\\Delta x}=-f&#39;(x)\\) 根据期望的定义，得：\\(ans=\\int_0^1x\\times p(x){\\rm d}x\\) \\[ \\begin{align} \\therefore ans&amp;=\\int_0^1x\\times (-f&#39;(x)){\\rm d}x\\\\ &amp;=\\int_0^1x{\\rm d}(-f(x))\\\\ &amp;=[x\\times (-f(x))]_0^1+\\int_0^1f(x){\\rm d}x \\end{align} \\] \\(\\because f(x)\\)为答案\\(&gt;x\\)的概率\\(\\qquad\\therefore f(0)=1,f(1)=0\\qquad\\therefore ans=\\int_0^1f(x){\\rm d}x\\) 证毕。 2.积分+数学推导 我们设一个函数\\(P_S(t)\\)表示当\\(S\\)[\\(S\\)为一个点集在原图中的导出子图]中的最大边为\\(t\\)时，\\(S\\)不连通的概率为\\(P_S(t)\\)。 那么有\\(E(X)=\\int_0^1P_{SIE}(t){\\rm d}t\\qquad\\)[\\(SIE\\)为全集]\\(\\qquad\\)(根据上面的证明可得) 我们可以方便地写出\\(P(t)\\)的递归式。 我们考虑一张图\\(S\\)，我们把其分成两部分(\\(S_0\\)与\\(S-S_0\\))，那么\\(S_0\\)连通而\\(S\\)不连通的概率为： \\[ [1-P_{S_0}(t)]\\times(1-t)^{E(S_0,S)} \\] 其中\\(E(S_0,S)\\)为\\(S_0\\)到\\(S- S0\\)的边数。 \\[ \\begin{align} \\therefore P_S(t)&amp;=\\sum_{S_0\\not\\subseteq S}(1-t)^{E(S_0,S)}\\times [1-P_{S_0}(t)]\\qquad[1\\in S_0]\\\\ \\therefore E(X)&amp;=\\int_0^1P_{SIE}(t){\\rm d}t\\\\ &amp;=\\int_0^1\\sum(1-t)^{E(S_0,S)}\\times[1-P_{S_0}(t)]]{\\rm d}t\\qquad[1\\in S_0)]\\\\ &amp;=\\sum\\int_0^1(1-t)^{E(S_0,S)}{\\rm d}t-\\int_0^1(1-t)^{E(S_0,S)}\\times P_{S_0}(t){\\rm d}t\\\\ &amp;=\\sum\\frac{1}{E(S_0,S)+1}-\\int_0^1(1-t)^{E(S_0,S)}\\times P_{S_0}(t){\\rm d}t \\end{align} \\] 我们递归定义\\(f[S_0][E(S_0,S)]=\\int_0^1(1-t)^{E(S_0,S)}\\times P_{S_0}(t){\\rm d}t​\\) \\(\\therefore f[1][k]=0,k\\in[0,m]\\qquad f[S][k]=\\sum\\frac{1}{k+E(S_0,S)+1}-f[S_0][k+E(S_0,S)]\\) 然后直接暴力即可。 附上AC代码： 1234567891011121314151617181920212223242526272829#include &lt;cstdio&gt;using namespace std;const int N=11,M=56;int n,m,x,y,t[1&lt;&lt;N][1&lt;&lt;N],all,b[1&lt;&lt;N][M];double f[1&lt;&lt;N][M];inline double calc(int sub,int k)&#123; if (sub==1) return 0; if (b[sub][k]) return f[sub][k]; b[sub][k]=1; double &amp;ans=(f[sub][k]=.0); for (int opt=(sub-1)&amp;sub; opt^sub; opt=(opt-1)&amp;sub) if (opt&amp;1) ans+=1.0/(k+t[opt][sub&amp;~opt]+1),ans-=calc(opt,k+t[opt][sub&amp;~opt]); return ans;&#125;int main(void)&#123; scanf(\"%d%d\",&amp;n,&amp;m),all=(1&lt;&lt;n)-1; while (m--)&#123; scanf(\"%d%d\",&amp;x,&amp;y),--x,--y; for (int s1=0; s1&lt;=all; ++s1) if ((s1&gt;&gt;x)&amp;1) for (int s2=0; s2&lt;=all; ++s2) if ((s2&gt;&gt;y)&amp;1) ++t[s1][s2],++t[s2][s1]; &#125; return printf(\"%.6lf\\n\",calc(all,0)),0;&#125; 3.直接积分 首先记\\(F(x)\\)为答案\\(&gt;x\\)的概率，可知\\(ans=\\int_0^1F(x){\\rm d}x\\) \\(F(x)\\)等价于边权\\(&lt;x\\)时不能使图连通的概率。有点难求，正难则反，考虑使图连通的概率。 记\\(f(S)\\)为集合\\(S\\)连通的概率，\\(f(S)=1-\\sum_{S&#39;\\subset S}f(S&#39;)\\times(1-x)^{cnt}\\)，其中\\(cnt\\)为\\(S&#39;\\)和\\(S-S&#39;\\)的边数。 可以发现，\\(f(S)\\)为关于\\(x\\)的多项式，可以做定积分。 也可以换一种理解的方式。 设\\(f(x)\\)为\\(x==ans\\)的概率密度函数，令\\(F(x)=\\int f(x){\\rm d}x\\) \\[ \\begin{align} ans&amp;=\\int_0^1xf(x){\\rm d}x\\\\ &amp;=\\int_0^1x{\\rm d}(F(x))\\\\ &amp;=[x\\times F(x)]_0^1-\\int_0^1F(x){\\rm d}x\\\\ &amp;=1-\\int_0^1F(x){\\rm d}x\\\\ &amp;=\\int_0^1(1-F(x)){\\rm d}x \\end{align} \\] \\(F(x)\\)的意义为取值\\(\\le x\\)的概率，等价于每条边有\\(x\\)的概率出现，问图的连通概率。 注意：这种做法不知为何有点卡精度，需要开__float128。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;cstdio&gt;#include &lt;vector&gt;using namespace std;const int N=10,M=57;typedef __float128 ld;typedef long long ll;typedef vector &lt;ll&gt; poly;struct note&#123; int x,y;&#125;a[M];int n,m;poly o,tmp,f[1&lt;&lt;N],ans;inline bool in(int x,int sub)&#123;return (sub&gt;&gt;x-1)&amp;1;&#125;inline poly operator * (const poly x,const poly y)&#123; poly ret(x.size()+y.size()-1,0); for (int i=0; i&lt;x.size(); ++i) for (int j=0; j&lt;y.size(); ++j) ret[i+j]+=x[i]*y[j]; return ret;&#125;inline poly operator - (const poly x,const poly y)&#123; poly ret(max(x.size(),y.size()),0); for (int i=0; i&lt;x.size(); ++i) ret[i]+=x[i]; for (int i=0; i&lt;y.size(); ++i) ret[i]-=y[i]; return ret;&#125;inline ld integrate(poly ans)&#123; ld ret=0; for (int i=0; i&lt;ans.size(); ++i) ret+=ld(1.0)*ans[i]/(i+1); return ret;&#125;int main(void)&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1; i&lt;=m; ++i) scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y); o.push_back(1),o.push_back(-1),f[1].push_back(1); for (int sub=3; sub&lt;(1&lt;&lt;n); sub+=2)&#123; f[sub].clear(),f[sub].push_back(1); for (int opt=(sub-1)&amp;sub; opt; opt=(opt-1)&amp;sub) if (opt&amp;1)&#123; int cnt=0; for (int i=1; i&lt;=m; ++i) if (in(a[i].x,sub)&amp;&amp;in(a[i].y,sub)&amp;&amp;(in(a[i].x,opt)^in(a[i].y,opt))) ++cnt; for (tmp=f[opt]; cnt; --cnt) tmp=tmp*o; f[sub]=f[sub]-tmp; &#125; &#125; ans.push_back(1),ans=ans-f[(1&lt;&lt;n)-1]; return printf(\"%.6f\\n\",(double)integrate(ans)),0;&#125; 后记：讲真，这的确是一道神题，很有思考的价值。 还有一小部分没有弄懂，就是“对于\\(n\\)个之\\([0,1]\\)间的随机变量\\(x1,x2,...,xn\\)，第\\(k\\)小的那个的期望值是\\(\\frac{k}{n+1}\\)”的证明，最近还在思考，挖坑待填。 连续性变量的期望用微积分的方法来做会简便很多。 希望我写的博客能够帮助各位巨佬解这道题，另外我不觉得信息学和微积分有何冲突，只要是能做题的方法都是好方法，并没有哪种方法好一些，不应该有偏见，能掌握做题的方法肯定是越多越好。 就这样吧。","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"期望DP","slug":"期望DP","permalink":"http://oi.linkfqy.top/tags/期望DP/"},{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"}]},{"title":"Codeforces 453A Little Pony and Expected Maximum","slug":"CF453A","date":"2018-10-08T11:22:41.000Z","updated":"2018-10-08T11:26:58.000Z","comments":true,"path":"posts/CF453A/","link":"","permalink":"http://oi.linkfqy.top/posts/CF453A/","excerpt":"","text":"题面在这里 ​ \\[ \\sum_{i=1}^m i\\cdot \\left[\\left( \\frac i m \\right)^n - \\left( \\frac {i-1} m \\right)^n\\right] \\] ​ 示例程序： 1234567891011#include&lt;cstdio&gt;#include&lt;cmath&gt;int n,m;int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); double ans=0; for (int i=1;i&lt;=m;i++) ans+=i*(pow(1.0*i/m,n)-pow(1.0*(i-1)/m,n)); printf(\"%.08f\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ4872 [Shoi2017]分手是祝愿","slug":"BZOJ4872","date":"2018-10-07T12:02:16.000Z","updated":"2018-10-07T12:20:40.000Z","comments":true,"path":"posts/BZOJ4872/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4872/","excerpt":"","text":"题面在这里 ​ 考虑最优策略是什么 从大到小，遇到亮的灯就按一下，感觉一下应该是最优的 那么问题就变成了有\\(t\\)个按钮需要按奇数次 \\(f_i\\)表示还有\\(i\\)个按钮需要按奇数次，则有： \\[ f_i=\\frac i n f_{i-1}+\\frac {n-i} n f_{i+1} +1 \\] 然而这并不太好搞，再转化一下： \\(g_i\\)表示\\(i\\)个按钮到\\(i-1\\)个按钮需要的期望步数 \\[ g_i=\\frac i n + \\frac {n-i} n (1+g_i+g_{i+1}) \\\\ g_i=\\frac {(n-i)g_{i+1}+n} i \\] \\(g_n=1\\)，答案就是\\(k+\\sum_{i=k+1}^t g_i\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cmath&gt;typedef long long ll;const int maxn=100005,MOD=100003;int n,m,K,d[maxn];ll f[maxn];ll power(int a,int b)&#123; ll res=1,w=a; while (b)&#123; if (b&amp;1) (res*=w)%=MOD; (w*=w)%=MOD; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;d[i]); for (int i=n;i&gt;=1;i--) if (d[i])&#123; int tj=sqrt(i);d[i]=0;m++; for (int j=1;j&lt;=tj;j++) if (i%j==0)&#123; d[j]^=1; if (j*j!=i) d[i/j]^=1; &#125; &#125; if (m&lt;=K)&#123; ll ans=m; for (int i=1;i&lt;=n;i++) (ans*=i)%=MOD; printf(\"%lld\",ans); return 0; &#125; ll ans=K; f[n]=1; for (int i=n-1;i&gt;K;i--) f[i]=((n-i)*f[i+1]+n)%MOD*power(i,MOD-2)%MOD; for (int i=m;i&gt;K;i--) (ans+=f[i])%=MOD; for (int i=1;i&lt;=n;i++) (ans*=i)%=MOD; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"期望DP","slug":"期望DP","permalink":"http://oi.linkfqy.top/tags/期望DP/"}]},{"title":"BZOJ4146 [AMPPZ2014]Divisors","slug":"BZOJ4146","date":"2018-10-06T11:54:38.000Z","updated":"2018-10-06T11:56:10.000Z","comments":true,"path":"posts/BZOJ4146/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4146/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920#include&lt;cstdio&gt;typedef long long ll;const int maxn=2000005;int n;ll c[maxn],ans;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++)&#123; int x;scanf(\"%d\",&amp;x); c[x]++; &#125; for (int i=1;i&lt;=2000000;i++)&#123; ans+=(c[i]-1)*c[i]; for (int j=2*i;j&lt;=2000000;j+=i) ans+=c[i]*c[j]; &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ4145 [AMPPZ2014]The Prices","slug":"BZOJ4145","date":"2018-10-06T11:21:13.000Z","updated":"2018-10-06T11:28:10.000Z","comments":true,"path":"posts/BZOJ4145/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4145/","excerpt":"","text":"题面在这里 ​ \\(f_{i,s}\\) 对第i层背包转移即可 我一开始还想子集枚举来着……太蠢了 ​ 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105,maxs=65540;int n,m,c[maxn][maxn],f[maxn][maxs],d[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;d[i]); for (int j=0;j&lt;m;j++) scanf(\"%d\",&amp;c[i][j]); &#125; memset(f,63,sizeof(f)); f[0][0]=0; for (int i=1;i&lt;=n;i++)&#123; for (int s=0;s&lt;(1&lt;&lt;m);s++) f[i][s]=f[i-1][s]+d[i]; for (int j=0;j&lt;m;j++) for (int s=0;s&lt;(1&lt;&lt;m);s++) if (((s&gt;&gt;j)&amp;1)==0) f[i][s|(1&lt;&lt;j)]=min(f[i][s|(1&lt;&lt;j)],f[i][s]+c[i][j]); for (int s=0;s&lt;(1&lt;&lt;m);s++) f[i][s]=min(f[i][s],f[i-1][s]); &#125; printf(\"%d\",f[n][(1&lt;&lt;m)-1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"}]},{"title":"BZOJ4144 [AMPPZ2014]Petrol","slug":"BZOJ4144","date":"2018-10-05T12:11:21.000Z","updated":"2018-10-05T12:28:38.000Z","comments":true,"path":"posts/BZOJ4144/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4144/","excerpt":"","text":"题面在这里 ​ 如果知道所有加油站之间的距离，最小生成树路径上的最大边就是决定了是否能走到 令\\(from_i\\)为离i最近的加油站，\\(dist_i\\)为到最近的加油站的距离 考虑从加油站\\(x\\)走到\\(y\\)，路径上的\\(from\\)一定是这样的： x,x,x...x,x,y,y...y,y,y（反证得） 所以对于给定的边\\((x,y,w)\\)，建边\\((from_x,from_y,dist_x+dist_y+w)\\) 然后就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=200005,maxe=800005;int n,s,e,q,c[maxn];int son[maxe],nxt[maxe],lnk1[maxn],lnk2[maxn],w[maxe],tot;inline void add(int x,int y,int z,int *lnk)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int que[maxn],dst[maxn],frm[maxn];bool vis[maxn];void spfa()&#123; cl(dst,63); int hed=0,til=0; for (int i=1;i&lt;=s;i++) que[++til]=c[i],dst[c[i]]=0,vis[c[i]]=1,frm[c[i]]=c[i]; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk1[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; frm[son[j]]=frm[x]; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125;&#125;struct edge&#123; int x,y,w; bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxn],b[maxn];int fa[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int f[maxn][18],g[maxn][18],dep[maxn];void dfs(int x)&#123; vis[x]=1;dep[x]=dep[f[x][0]]+1; for (int j=lnk2[x];j;j=nxt[j]) if (!vis[son[j]]) f[son[j]][0]=x,g[son[j]][0]=w[j],dfs(son[j]);&#125;void DP()&#123; for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], g[i][j]=max(g[i][j-1],g[f[i][j-1]][j-1]);&#125;int LCA(int x,int y)&#123; int res=0; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=17;~j;j--) if (dep[f[x][j]]&gt;=dep[y]) res=max(res,g[x][j]),x=f[x][j]; if (x==y) return res; for (int j=17;~j;j--) if (f[x][j]!=f[y][j]) res=max(res,max(g[x][j],g[y][j])),x=f[x][j],y=f[y][j]; return max(res,max(g[x][0],g[y][0]));&#125;int main()&#123; n=red(),s=red(),e=red(); for (int i=1;i&lt;=s;i++) c[i]=red(); for (int i=1,x,y,z;i&lt;=e;i++) a[i].x=x=red(),a[i].y=y=red(),a[i].w=z=red(),add(x,y,z,lnk1),add(y,x,z,lnk1); spfa(); for (int i=1;i&lt;=e;i++) b[i].x=frm[a[i].x],b[i].y=frm[a[i].y],b[i].w=dst[a[i].x]+dst[a[i].y]+a[i].w; sort(b+1,b+1+e); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++) if (getfa(b[i].x)!=getfa(b[i].y))&#123; fa[getfa(b[i].x)]=getfa(b[i].y); add(b[i].x,b[i].y,b[i].w,lnk2); add(b[i].y,b[i].x,b[i].w,lnk2); &#125; cl(vis,0); for (int i=1;i&lt;=s;i++) if (!vis[c[i]]) f[c[i]][0]=0,g[c[i]][0]=0,dfs(c[i]); DP(); q=red(); while (q--)&#123; int x=red(),y=red(),d=red(); if (getfa(x)!=getfa(y)) puts(\"NIE\");else puts(LCA(x,y)&lt;=d?\"TAK\":\"NIE\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"BZOJ4542 [Hnoi2016]大数","slug":"BZOJ4542","date":"2018-10-05T10:41:35.000Z","updated":"2018-10-05T10:54:20.000Z","comments":true,"path":"posts/BZOJ4542/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4542/","excerpt":"","text":"题面在这里 ​ 记前缀\\(\\overline{s_1 s_2\\dots s_i}\\ Mod\\ p=S_i\\) 考虑一个子区间\\([l,r]\\)被计入答案需要满足的条件： \\[ (S_r-S_{l-1}\\cdot 10^{r-l+1})Mod\\ p=0 \\\\ S_r\\cdot 10^r\\equiv S_{l-1}\\cdot 10^{l-1} \\] 那么就转化为在区间内统计相同值的二元组个数 莫队即可 注意特判\\(p=2\\)和\\(p=5\\)的情况 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005;int n,q,p,m,h[maxn];char S[maxn];ll s[maxn],inv[maxn],w[maxn],b[maxn],cnt[maxn],ans[maxn],now=0;ll power(ll a,int b)&#123; ll res=1,w=a%p; while (b)&#123; if (b&amp;1) (res*=w)%=p; (w*=w)%=p; b&gt;&gt;=1; &#125; return res;&#125;inline void blocker()&#123; int k=sqrt(n); for (int i=1;i&lt;=n;i++) h[i]=(i-1)/k+1;&#125;struct data&#123; int l,r,id; bool operator&lt;(const data&amp;b)const&#123; if (h[l]==h[b.l]) return r&lt;b.r; return l&lt;b.l; &#125;&#125;a[maxn];#define c2(x) ((x)*((x)-1)/2)inline void update(int x,int d)&#123; now-=c2(cnt[w[x]]); cnt[w[x]]+=d; now+=c2(cnt[w[x]]);&#125;ll c[maxn],num;int main()&#123; scanf(\"%d%s%d\",&amp;p,S+1,&amp;q); n=strlen(S+1); for (int i=1;i&lt;=n;i++) s[i]=(s[i-1]*10+S[i]-'0')%p; if (p==2||p==5)&#123; for (int i=1;i&lt;=n;i++) c[i]=c[i-1]+(s[i]==0)*i,cnt[i]=cnt[i-1]+(s[i]==0); for (int i=1;i&lt;=q;i++)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%lld\\n\",c[r]-c[l-1]-(cnt[r]-cnt[l-1])*(l-1)); &#125; return 0; &#125; inv[0]=1;inv[1]=power(10,p-2); for (int i=2;i&lt;=n;i++) inv[i]=(inv[i-1]*inv[1])%p; for (int i=0;i&lt;=n;i++) w[i]=b[i]=inv[i]*s[i]%p; sort(b,b+1+n); m=unique(b,b+1+n)-b-1; for (int i=0;i&lt;=n;i++) w[i]=lower_bound(b,b+1+m,w[i])-b; blocker(); for (int i=1;i&lt;=q;i++) scanf(\"%d%d\",&amp;a[i].l,&amp;a[i].r),a[i].id=i,a[i].l--; sort(a+1,a+1+q); int L=1,R=1; update(1,1); for (int i=1;i&lt;=q;i++)&#123; while (L&gt;a[i].l) update(--L,1); while (L&lt;a[i].l) update(L++,-1); while (R&gt;a[i].r) update(R--,-1); while (R&lt;a[i].r) update(++R,1); ans[a[i].id]=now; &#125; for (int i=1;i&lt;=q;i++) printf(\"%lld\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"莫队","slug":"莫队","permalink":"http://oi.linkfqy.top/tags/莫队/"}]},{"title":"【Manacher+贪心】BZOJ3790 神奇项链","slug":"BZOJ3790","date":"2018-10-05T06:03:50.000Z","updated":"2018-10-05T06:07:24.000Z","comments":true,"path":"posts/BZOJ3790/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3790/","excerpt":"","text":"题面在这里 ​ 可以发现题目意思就是把\\(S\\)用最少的回文串覆盖 那么先\\(Manacher\\)把所有极大回文子串找出来 就变成用一些线段覆盖\\([1,n]\\) 贪心即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define mp make_pair#define X first#define Y secondusing namespace std;const int maxn=100005;int n,p[maxn];char t[maxn],s[maxn];pair&lt;int,int&gt; a[maxn];void manacher(char *s)&#123; int pos=0,R=0; for (int i=1;i&lt;=n;i++)&#123; if (i&lt;R) p[i]=min(p[2*pos-i],R-i); else p[i]=1; while (1&lt;=i-p[i]&amp;&amp;i+p[i]&lt;=n&amp;&amp;s[i-p[i]]==s[i+p[i]]) p[i]++; if (i+p[i]&gt;R) pos=i,R=i+p[i]; a[i]=mp(i-p[i]+1,i+p[i]-1); &#125;&#125;int main()&#123; while (~scanf(\"%s\",t+1))&#123; n=0; for (int i=1;t[i];i++) s[++n]='#',s[++n]=t[i]; s[++n]='#'; manacher(s); sort(a+1,a+1+n); int ans=0; for (int i=1,j=1,MX=0;i&lt;=n;)&#123; while (j&lt;=n&amp;&amp;a[j].X&lt;=i) MX=max(MX,a[j++].Y); i=MX+1;ans++; &#125; printf(\"%d\\n\",ans-1); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"Manacher","slug":"Manacher","permalink":"http://oi.linkfqy.top/tags/Manacher/"}]},{"title":"BZOJ4832 [Lydsy1704月赛]抵制克苏恩","slug":"BZOJ4832","date":"2018-10-05T05:56:17.000Z","updated":"2018-10-05T05:59:40.000Z","comments":true,"path":"posts/BZOJ4832/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4832/","excerpt":"","text":"题面在这里 ​ 直接DP即可 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))int tst,K,A,B,C;double f[55][10][10][10],g[55][10][10][10];bool vis[55][10][10][10];int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d%d%d\",&amp;K,&amp;A,&amp;B,&amp;C); cl(f,0);cl(g,0);cl(vis,0); vis[K][A][B][C]=1;g[K][A][B][C]=1; for (int i=K;i&gt;=1;i--) for (int a=0;a&lt;=7;a++) for (int b=0;b&lt;=7;b++) for (int c=0;c&lt;=7;c++)&#123; if (!vis[i][a][b][c]||a+b+c&gt;7) continue; g[i-1][a][b][c]+=g[i][a][b][c]/(a+b+c+1); f[i-1][a][b][c]+=(f[i][a][b][c]+g[i][a][b][c])/(a+b+c+1); vis[i-1][a][b][c]=1; if (c) if (a+b+c&lt;7)&#123; g[i-1][a][b+1][c]+=g[i][a][b][c]*c/(a+b+c+1); f[i-1][a][b+1][c]+=f[i][a][b][c]*c/(a+b+c+1); vis[i-1][a][b+1][c]=1; &#125; else&#123; g[i-1][a][b+1][c-1]+=g[i][a][b][c]*c/(a+b+c+1); f[i-1][a][b+1][c-1]+=f[i][a][b][c]*c/(a+b+c+1); vis[i-1][a][b+1][c-1]=1; &#125; if (b) if (a+b+c&lt;7)&#123; g[i-1][a+1][b-1][c+1]+=g[i][a][b][c]*b/(a+b+c+1); f[i-1][a+1][b-1][c+1]+=f[i][a][b][c]*b/(a+b+c+1); vis[i-1][a+1][b-1][c+1]=1; &#125; else&#123; g[i-1][a+1][b-1][c]+=g[i][a][b][c]*b/(a+b+c+1); f[i-1][a+1][b-1][c]+=f[i][a][b][c]*b/(a+b+c+1); vis[i-1][a+1][b-1][c]=1; &#125; if (a)&#123; g[i-1][a-1][b][c]+=g[i][a][b][c]*a/(a+b+c+1); f[i-1][a-1][b][c]+=f[i][a][b][c]*a/(a+b+c+1); vis[i-1][a-1][b][c]=1; &#125; &#125; double ans=0; for (int a=0;a&lt;=7;a++) for (int b=0;b&lt;=7;b++) for (int c=0;c&lt;=7;c++) if (vis[0][a][b][c]&amp;&amp;a+b+c&lt;=7) ans+=f[0][a][b][c]; printf(\"%.2lf\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"期望DP","slug":"期望DP","permalink":"http://oi.linkfqy.top/tags/期望DP/"},{"name":"概率DP","slug":"概率DP","permalink":"http://oi.linkfqy.top/tags/概率DP/"}]},{"title":"BZOJ4143 [AMPPZ2014]The Lawyer","slug":"BZOJ4143","date":"2018-10-04T13:07:08.000Z","updated":"2018-10-04T13:09:00.000Z","comments":true,"path":"posts/BZOJ4143/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4143/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=25;int n,m,l[maxn],r[maxn],lid[maxn],rid[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); cl(r,63); for (int i=1;i&lt;=n;i++)&#123; int li,ri,d;scanf(\"%d%d%d\",&amp;li,&amp;ri,&amp;d); if (l[d]&lt;li) l[d]=li,lid[d]=i; if (r[d]&gt;ri) r[d]=ri,rid[d]=i; &#125; for (int i=1;i&lt;=m;i++) if (r[i]&lt;l[i]) printf(\"TAK %d %d\\n\",rid[i],lid[i]); else puts(\"NIE\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"入门BZOJ3004 [Noi2016十连测第一场]访问计划","slug":"begin_BZOJ3004","date":"2018-10-03T13:01:28.000Z","updated":"2018-10-03T13:05:58.000Z","comments":true,"path":"posts/begin_BZOJ3004/","link":"","permalink":"http://oi.linkfqy.top/posts/begin_BZOJ3004/","excerpt":"","text":"题面在这里 ​ 如果没有传送的话，每条边的贡献是两倍边权 考虑一次传送，其实是把一条路径上的边权和用c代替 每条边至少走一次，所以路径不能有交 那么问题就转化为求一棵树选K条路径，使得边权和最大 树形背包即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x)) using namespace std;const int maxn=2005,INF=0x3f3f3f3f;struct edge&#123;int to,w,nt;&#125;s[maxn*2];int n,cnt,cost,num,h[maxn],sz[maxn];int f[maxn][maxn][2],g[maxn][2],ans;inline void add(int x,int y,int w)&#123; s[++num]=(edge)&#123;y,w,h[x]&#125;,h[x]=num;s[++num]=(edge)&#123;x,w,h[y]&#125;,h[y]=num;&#125;inline void DP(int x,int fa,int sum)&#123; bool mk=1;sz[x]=1; for (int i=h[x];i;i=s[i].nt) if (s[i].to!=fa)&#123; DP(s[i].to,x,s[i].w),sz[x]+=sz[s[i].to]; if (mk) for (int k=0;k&lt;=sz[s[i].to];k++)&#123; f[x][k][0]=min(f[x][k][0],f[s[i].to][k][0]); f[x][k][1]=min(f[x][k][1],f[s[i].to][k][1]); if (k+1&lt;=cnt) f[x][k+1][0]=min(f[x][k+1][0],f[s[i].to][k][1]); &#125; else&#123; cl(g,63); for (int xk=0;xk&lt;=sz[x];++xk)&#123; if (f[x][xk][0]!=INF)&#123; int base=f[x][xk][0],lim=min(cnt-xk,sz[s[i].to]); for (int tk=0;tk&lt;=lim;++tk)&#123; g[xk+tk][0]=min(g[xk+tk][0],base+f[s[i].to][tk][0]); g[xk+tk][1]=min(g[xk+tk][1],base+f[s[i].to][tk][1]); if (xk+tk+1&lt;=cnt) g[xk+tk+1][0]=min(g[xk+tk+1][0],base+f[s[i].to][tk][1]); &#125; &#125; if (f[x][xk][1]!=INF)&#123; int base=f[x][xk][1],lim=min(cnt-xk,sz[s[i].to]); for (int tk=0;tk&lt;=lim;++tk)&#123; g[xk+tk][1]=min(g[xk+tk][1],base+f[s[i].to][tk][0]); if (xk+tk+1&lt;=cnt)&#123; g[xk+tk+1][0]=min(g[xk+tk+1][0],base+f[s[i].to][tk][1]-cost); g[xk+tk+1][1]=min(g[xk+tk+1][1],base+f[s[i].to][tk][1]); &#125; &#125; &#125; &#125; for (int k=0;k&lt;=cnt;k++) f[x][k][0]=g[k][0],f[x][k][1]=g[k][1]; &#125; mk=0; &#125; if (mk) f[x][0][0]=sum&lt;&lt;1,f[x][0][1]=cost+sum; else &#123; for (int k=0;k&lt;=cnt;k++) f[x][k][1]=min(f[x][k][1],f[x][k][0]+cost); for (int k=0;k&lt;=cnt;k++) for (int j=0;j&lt;=1;j++) f[x][k][j]+=(2-j)*sum,f[x][k][j]=min(f[x][k][j],INF); &#125;&#125;int main()&#123; while (~scanf(\"%d%d%d\",&amp;n,&amp;cnt,&amp;cost))&#123; cl(h,0);cl(f,63); num=0,ans=INF; for (int i=1,x,y,w;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w),++x,++y,add(x,y,w); DP(1,0,0); for (int i=0;i&lt;=cnt;i++) ans=min(ans,f[1][i][0]); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树形DP","slug":"树形DP","permalink":"http://oi.linkfqy.top/tags/树形DP/"}]},{"title":"入门BZOJ3003 [Noi2016十连测第一场]奥义商店","slug":"begin_BZOJ3003","date":"2018-10-03T12:50:16.000Z","updated":"2018-10-03T13:01:14.000Z","comments":true,"path":"posts/begin_BZOJ3003/","link":"","permalink":"http://oi.linkfqy.top/posts/begin_BZOJ3003/","excerpt":"","text":"题面在这里 ​ 考虑从k开始，向两边的每个数出现的概率 \\(a_{k-i\\cdot d}\\)对应的概率为\\(\\Pi_{j=1}^i \\frac {m-j+1}{n-j}\\) 这个东西很快就会比精度还小，所以最多算500项就够了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;const double eps=1e-6;int n,q;double v[maxn],f[105][maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%lf\",&amp;v[i]); for (int j=1;j&lt;=100;j++) f[j][i%j]+=v[i]; &#125; while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1)&#123; int x,w;scanf(\"%d%d\",&amp;x,&amp;w); for (int i=1;i&lt;=100;i++) f[i][x%i]+=w-v[x]; v[x]=w; &#125;else&#123; int t,k,d;scanf(\"%d%d%d\",&amp;t,&amp;k,&amp;d); if (t==1)&#123; int x;scanf(\"%d\",&amp;x); if (d&lt;=100) printf(\"%.6lf\\n\",f[d][k%d]);else&#123; double ans=v[k]; for (int i=k+d;i&lt;=n;i+=d) ans+=v[i]; for (int i=k-d;i&gt;=1;i-=d) ans+=v[i]; printf(\"%.6lf\\n\",ans); &#125; &#125;else&#123; int m=2e9,x; double ans=v[k],rate=1; while (t--) scanf(\"%d\",&amp;x),m=min(m,x); for (int i=1;i&lt;=500&amp;&amp;k+i*d&lt;=n;i++) rate*=1.0*(m-i+1)/(n-i),ans+=1.0*v[k+i*d]*rate; rate=1; for (int i=1;i&lt;=500&amp;&amp;k-i*d&gt;=1;i++) rate*=1.0*(m-i+1)/(n-i),ans+=1.0*v[k-i*d]*rate; printf(\"%.6lf\\n\",ans); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【扫描线+网络流+线段树优化建图】Codeforces 793G Oleg and chess","slug":"CF793G","date":"2018-10-01T13:59:00.000Z","updated":"2018-10-01T14:19:42.000Z","comments":true,"path":"posts/CF793G/","link":"","permalink":"http://oi.linkfqy.top/posts/CF793G/","excerpt":"","text":"题面在这里 题意：\\(N\\times N\\)的棋盘，问最多能放几个互不攻击的车，有\\(q\\)个矩形障碍不能放车，障碍不影响车的攻击范围 ​ 好题，好题 一个朴素的想法是建立二分图：若\\((x,y)\\)是空位，连边\\((x,y)\\) 最大匹配就是答案 然后发现如果在一个矩形区域\\((x_1,y_1,x_2,y_2)\\)内都是空位，等价于\\([x_1,x_2]\\)，\\([y_1,y_2]\\)两个区间所有点各自连边 这个可以用线段树优化建图 剩下的事情就是扫描线找出所有的空矩形 维护一系列有开口的矩形，遇到障碍分裂之 ​ 之前学了假的Dinic，狂TLE不止 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=80005,maxe=3000005,maxs=80005,INF=0x3f3f3f3f;int n,q,N,m,S,T,a[maxn];struct event&#123; int x,l,r,f; event(int _x=0,int _l=0,int _r=0,int _f=0):x(_x),l(_l),r(_r),f(_f) &#123;&#125; bool operator&lt;(const event&amp;b)const&#123; return x&lt;b.x||x==b.x&amp;&amp;f&gt;b.f; &#125;&#125;E[maxs];int son[maxe],nxt[maxe],lnk[maxn],flw[maxe],cap[maxe],tot=1;inline void add(int x,int y,int f)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int d[maxn],que[maxn],pos[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; que[1]=S;d[S]=0; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==INF&amp;&amp;flw[j]&lt;cap[j]) d[que[++til]=son[j]]=d[x]+1; &#125; return d[T]!=INF;&#125;int dfs(int x,int flow)&#123; if (x==T||flow==0) return flow; int res=0,f; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f; flw[j^1]-=f; res+=f; flow-=f; if (flow==0) break; &#125; return res;&#125;int dinic()&#123; int ans=0; while (bfs())&#123; memcpy(pos,lnk,sizeof(lnk)); ans+=dfs(S,INF); &#125; return ans;&#125;int ls[maxs],rs[maxs],Rx,Ry;void build(int &amp;x,int l,int r,int d)&#123; x=++N; if (l==r)&#123; if (d) add(x,T,1);else add(S,x,1); return; &#125; int mid=l+r&gt;&gt;1; build(ls[x],l,mid,d);build(rs[x],mid+1,r,d); if (d) add(x,ls[x],INF),add(x,rs[x],INF); else add(ls[x],x,INF),add(rs[x],x,INF);&#125;void qry(int x,int l,int r,int ql,int qr,int z,int d)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr)&#123; if (d) add(z,x,INF);else add(x,z,INF); return; &#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; qry(ls[x],l,mid,ql,qr,z,d);qry(rs[x],mid+1,r,ql,qr,z,d);&#125;void cover(int x,int l,int r)&#123; for (int i=l;i&lt;=r;i++) a[i]=x;&#125;void work(int x,int l,int r)&#123; for (int i=l,j=l;i&lt;=r;i=j)&#123; while (j&lt;=r&amp;&amp;a[i]==a[j]) j++; N++;//printf(\"%d %d %d %d\\n\",a[i]+1,i,x,j-1); qry(Rx,1,n,a[i]+1,x,N,0); qry(Ry,1,n,i,j-1,N,1); &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=q;i++)&#123; int x,y,xx,yy;scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;xx,&amp;yy); E[++m]=event(x-1,y,yy,0); E[++m]=event(xx,y,yy,1); &#125; S=++N;T=++N; build(Rx,1,n,0);build(Ry,1,n,1); sort(E+1,E+1+m); for (int i=1;i&lt;=m;i++) if (E[i].f) cover(E[i].x,E[i].l,E[i].r);else work(E[i].x,E[i].l,E[i].r); work(n,1,n); printf(\"%d\",dinic()); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"扫描线","slug":"扫描线","permalink":"http://oi.linkfqy.top/tags/扫描线/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"51Nod 1084 矩阵取数问题 V2","slug":"51Nod1084","date":"2018-10-01T02:40:00.000Z","updated":"2018-10-01T02:43:22.000Z","comments":true,"path":"posts/51Nod1084/","link":"","permalink":"http://oi.linkfqy.top/posts/51Nod1084/","excerpt":"","text":"题面在这里 ​ 比较简单的费用流模型。 把每个点拆成两个，连上两条边\\((1,a_{i,j})\\)和\\((1,0)\\) 网格中连边\\((1,0)\\) 源点到\\(a_{1,1}\\)连边\\((2,0)\\)，\\(a_{n,m}\\)到汇点连边\\((2,0)\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=80005,maxe=320005,INF=0x3f3f3f3f;int n,N,S,T,m,a[205][205],id[205][205];int son[maxe],nxt[maxe],lnk[maxn],tot=1,flw[maxe],cap[maxe],w[maxe];inline void add(int x,int y,int f,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;int dst[maxn],que[maxn],fa[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(vis,0);cl(dst,192); int hed=0,til=1; que[1]=S;dst[S]=0; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (flw[j]&lt;cap[j]&amp;&amp;dst[son[j]]&lt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; fa[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125; return dst[T]!=dst[0];&#125;int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); S=1,T=2;N=2; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; scanf(\"%d\",&amp;a[i][j]); id[i][j]=(N+=2); &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++)&#123; add(id[i][j],id[i][j]^1,1,0); add(id[i][j],id[i][j]^1,1,a[i][j]); if (i&gt;1) add(id[i-1][j]^1,id[i][j],1,0); if (j&gt;1) add(id[i][j-1]^1,id[i][j],1,0); &#125; add(S,id[1][1],2,0); add(id[n][m]^1,T,2,0); int ans=0; while (spfa())&#123; int Min=INF; for (int x=T;x!=S;x=fa[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=fa[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; ans+=Min*dst[T]; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"51Nod","slug":"51Nod","permalink":"http://oi.linkfqy.top/tags/51Nod/"},{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"}]},{"title":"【最大权闭合子图】BZOJ4873 [Shoi2017]寿司餐厅","slug":"BZOJ4873","date":"2018-09-30T13:41:41.000Z","updated":"2018-09-30T13:54:44.000Z","comments":true,"path":"posts/BZOJ4873/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4873/","excerpt":"","text":"题面在这里 ​ 因为题中各种代价都只能算入一次，很适合用最大权闭合子图的模型解决 把区间\\((i,j)\\)和代号\\(a_i\\)看作一个点，建立点权图： 对于\\((i,j),i\\lt j\\)，点权为\\(d_{i,j}\\)，向\\((i+1,j),(i,j-1)\\)连边 取了一个区间，则其所有子区间都会有代价 对于\\((i,i)\\)，点权为\\(d_{i,i}-a_i\\)，向\\(a_i\\)连边 底层区间对应所取的寿司 对于\\(a_i\\)，点权为\\(-m\\cdot a_i^2\\) 还是为了满足关于代号的代价 直接套用最小割求解 注意\\(a_i\\)哪里不要搞出重边来，网络流最怕这个 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=11005,maxe=62005,INF=0x3f3f3f3f;int n,N,S,T,m,ans,a[105],d[105][105],id[105][105];int son[maxe],nxt[maxe],lnk[maxn],tot=1,flw[maxe],cap[maxe];inline void add(int x,int y,int f)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int pos[maxn],que[maxn],D[maxn];bool bfs()&#123; cl(D,63); int hed=0,til=1; que[1]=S;D[S]=0; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (D[son[j]]==INF&amp;&amp;flw[j]&lt;cap[j]) que[++til]=son[j],D[son[j]]=D[x]+1; &#125; return D[T]!=INF;&#125;int dfs(int x,int flow)&#123; if (x==T||flow==0) return flow; int res=0,f; for (int &amp;j=pos[x];j;j=nxt[j]) if (D[son[j]]==D[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f; flw[j^1]-=f; res+=f; flow-=f; &#125; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++) scanf(\"%d\",&amp;d[i][j]); S=++N;T=++N; for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++)&#123; id[i][j]=++N;int w=(i==j?d[i][j]-a[i]:d[i][j]); if (w&gt;0) add(S,N,w),ans+=w;else add(N,T,-w); &#125; for (int i=1;i&lt;=1000;i++) add(i+N,T,m*i*i); for (int i=1;i&lt;=n;i++) for (int j=i;j&lt;=n;j++) if (i==j) add(id[i][j],N+a[i],INF); else&#123; if (i&lt;n) add(id[i][j],id[i+1][j],INF); if (j&gt;1) add(id[i][j],id[i][j-1],INF); &#125; while (bfs())&#123; memcpy(pos,lnk,sizeof(lnk)); ans-=dfs(S,INF); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","permalink":"http://oi.linkfqy.top/tags/最大权闭合子图/"}]},{"title":"最大权闭合子图 学习笔记","slug":"Maximum_Weight_Closure_of_a_Graph","date":"2018-09-29T13:10:57.000Z","updated":"2018-09-29T13:47:48.000Z","comments":true,"path":"posts/Maximum_Weight_Closure_of_a_Graph/","link":"","permalink":"http://oi.linkfqy.top/posts/Maximum_Weight_Closure_of_a_Graph/","excerpt":"","text":"定义 一个有向图中，每个点有点权\\(w_i\\)（可负） 现在需要找到一个子图，满足： 对于所有边\\((u,v)\\)，点\\(u\\)在子图中则\\(v\\)必在子图中 子图的点权和最大 这个子图就是最大权闭合子图 解法 我们先给出最大权闭合子图的解法，之后给出证明 最大权闭合子图可以用最小割解决： 对于\\(w_i\\gt 0\\)的点\\(i\\)，连边\\((S,i,w_i)\\) 对于\\(w_i\\lt 0\\)的点\\(i\\)，连边\\((i,T,-w_i)\\) 对于原图边\\((u,v)\\)，连边\\((u,v,\\infty)\\) 答案就是所有正点权之和-最小割 证明 考虑以下两个命题： 最小割一定是简单割 简单割就是只割与\\(S\\)或\\(T\\)相连的边 显然成立，因为原图边都是无穷大 简单割与闭合子图一一对应 闭合子图和\\(S\\)构成集合\\(V_S\\)，其余点和\\(T\\)构成集合\\(V_T\\) 下面是一个示例，\\(V_S=\\{S,2,4,5\\}\\)： 证明略 那么最大权闭合子图的权\\(W\\)=\\(V_S\\)中正点权和-\\(V_S\\)中负点权的绝对值和 最小割\\(c(S,T)=\\)\\(V_T\\)中正点权和+\\(V_S\\)中负点权的绝对值和 则有\\(W+c(S,T)=\\)所有正点权之和 就是前面说的\\(W=\\)所有正点权之和\\(-c(S,T)\\) 例题 BZOJ1497 最大获利 BZOJ1565 植物大战僵尸 BZOJ4873 寿司餐厅","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"最大权闭合子图","slug":"最大权闭合子图","permalink":"http://oi.linkfqy.top/tags/最大权闭合子图/"}]},{"title":"【费用流/KM】BZOJ1937 [Shoi2004]Mst 最小生成树","slug":"BZOJ1937","date":"2018-09-29T10:46:51.000Z","updated":"2018-09-29T11:11:24.000Z","comments":true,"path":"posts/BZOJ1937/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1937/","excerpt":"","text":"题面在这里 ​ 首先非树边一定是加边权，树边一定是减边权的 考虑非树边\\(j\\)的两个端点\\(u,v\\)，则树上路径\\((u,v)\\)包含的树边\\(i\\)都应满足：\\(w_i-d_i\\le w_j+d_j\\) 所以\\(d_i+d_j\\ge w_i-w_j\\) 然后发现这个就是KM的顶标，最大费用流刷之 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define X first#define Y second#define mp make_pair#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=805,maxe=160005,INF=0x3f3f3f3f;int n,e,S,T,a[55][55],b[55][55],id[55][55],fa[maxn];pair&lt;int,int&gt; E[maxn];int tot=1,son[maxe],nxt[maxe],lnk[maxn],flw[maxe],cap[maxe],w[maxe];inline void add(int x,int y,int f,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=f;w[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;w[tot]=-z;&#125;void dfs(int x,int f)&#123; fa[x]=f; for (int j=1;j&lt;=n;j++) if (b[x][j]&amp;&amp;f!=j) dfs(j,x);&#125;int que[maxn],dst[maxn],ed[maxn];bool vis[maxn];bool spfa()&#123; cl(vis,0);cl(dst,192); int hed=0,til=1;que[1]=S;dst[S]=0;fa[S]=0; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (flw[j]&lt;cap[j]&amp;&amp;dst[son[j]]&lt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; fa[son[j]]=x; ed[son[j]]=j; if (!vis[son[j]]) vis[que[til=(til+1)%maxn]=son[j]]=1; &#125; &#125; return dst[T]!=dst[0];&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=e;i++)&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y);scanf(\"%d\",&amp;a[x][y]); a[y][x]=a[x][y]; id[x][y]=id[y][x]=i; E[i]=mp(x,y); &#125; for (int i=1;i&lt;n;i++)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); b[x][y]=b[y][x]=a[x][y]; a[x][y]=a[y][x]=0; &#125; for (int i=1;i&lt;=e;i++) if (a[E[i].X][E[i].Y])&#123; dfs(E[i].X,0); for (int x=E[i].Y;x!=E[i].X;x=fa[x]) if (b[fa[x]][x]&gt;a[E[i].X][E[i].Y]) add(id[fa[x]][x],i,1,b[fa[x]][x]-a[E[i].X][E[i].Y]); &#125; S=e+1;T=S+1; for (int i=1;i&lt;=e;i++) if (a[E[i].X][E[i].Y]) add(i,T,1,0);else add(S,i,1,0); int ans=0; while (spfa()&amp;&amp;dst[T]&gt;0)&#123; int Min=INF; for (int x=T;x!=S;x=fa[x]) Min=min(Min,cap[ed[x]]-flw[ed[x]]); for (int x=T;x!=S;x=fa[x]) flw[ed[x]]+=Min,flw[ed[x]^1]-=Min; ans+=Min*dst[T]; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"}]},{"title":"BZOJ2752 [HAOI2012]高速公路(road)","slug":"BZOJ2752","date":"2018-09-28T12:14:57.000Z","updated":"2018-09-28T12:22:46.000Z","comments":true,"path":"posts/BZOJ2752/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2752/","excerpt":"","text":"题面在这里 ​ 首先把题目转化为对长度为\\(n-1\\)的序列的操作 考虑询问区间\\([L,R]\\)，\\(i\\in [L,R]\\)，则\\(w_i\\)的贡献为： \\[ w_i(i-L+1)(R-i+1) \\] 整理得 \\[ -w_i\\cdot i^2+(L+R)w_i\\cdot i-(LR+L-R-1)w_i \\] 那么线段树维护\\(i,i^2,w_i,w_i\\cdot i,w_i\\cdot i^2\\)的和就好了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;typedef long long ll;const int maxn=100005,maxs=400005;int n,q; char s[10];ll w[maxs],wi[maxs],wii[maxs],i[maxs],ii[maxs],ad[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x)&#123; w[x]=w[ls]+w[rs]; wi[x]=wi[ls]+wi[rs]; wii[x]=wii[ls]+wii[rs]; i[x]=i[ls]+i[rs]; ii[x]=ii[ls]+ii[rs];&#125;inline void addad(int x,ll v,int l,int r)&#123; w[x]+=v*(r-l+1); wi[x]+=v*i[x]; wii[x]+=v*ii[x]; ad[x]+=v;&#125;inline void pushdown(int x,int l,int mid,int r)&#123; if (ad[x]) addad(ls,ad[x],l,mid),addad(rs,ad[x],mid+1,r),ad[x]=0;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;i[x]=l;ii[x]=(ll)l*l;return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,int v)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addad(x,v,l,r);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x,l,mid,r); ist(ls,l,mid,ql,qr,v);ist(rs,mid+1,r,ql,qr,v); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return (ql+qr)*wi[x]-wii[x]-w[x]*((ll)ql*qr+ql-qr-1); if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x,l,mid,r); return qry(ls,l,mid,ql,qr)+qry(rs,mid+1,r,ql,qr);&#125;ll gcd(ll x,ll y) &#123;return y==0?x:gcd(y,x%y);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); build(1,1,n); while (q--)&#123; scanf(\"%s\",s); if (s[0]=='C')&#123; int l,r,v;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;v);r--; ist(1,1,n,l,r,v); &#125;else&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r);r--; ll k=r-l+1,a=qry(1,1,n,l,r),b=k*(k+1)/2; ll t=gcd(a,b); a/=t;b/=t; printf(\"%lld/%lld\\n\",a,b); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"【线段树+扫描线】BZOJ2161 布娃娃","slug":"BZOJ2161","date":"2018-09-28T06:47:02.000Z","updated":"2018-09-28T06:53:06.000Z","comments":true,"path":"posts/BZOJ2161/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2161/","excerpt":"","text":"题面在这里 ​ 直接扫描线，不解释 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define X first#define Y second#define mp make_pairusing namespace std;typedef long long ll;const int maxn=100005,maxs=400005,MOD=19921228;int n,m,M,b[maxn*2],p[maxn],l[maxn],r[maxn],c[maxn];void init(int *a,int add,int first,int mod,int prod)&#123; a[1]=first%mod; for (int i=2;i&lt;=n;i++) a[i]=((ll)a[i-1]*prod+add+i)%mod;&#125;pair&lt;int,int&gt; ev[maxn*2],q[maxn];int s[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1void ist(int x,int l,int r,int k,int w)&#123; if (l==r) &#123;s[x]+=w;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls,l,mid,k,w);else ist(rs,mid+1,r,k,w); s[x]=s[ls]+s[rs];&#125;int qry(int x,int l,int r,int k)&#123; if (l==r) return l; int t=s[rs],mid=l+r&gt;&gt;1; if (t&gt;=k) return qry(rs,mid+1,r,k);else return qry(ls,l,mid,k-t);&#125;int main()&#123; scanf(\"%d\",&amp;n); int Padd,Pfirst,Pmod,Pprod,Cadd,Cfirst,Cmod,Cprod,Ladd,Lfirst,Lmod,Lprod,Radd,Rfirst,Rmod,Rprod; scanf(\"%d%d%d%d\",&amp;Padd,&amp;Pfirst,&amp;Pmod,&amp;Pprod); init(p,Padd,Pfirst,Pmod,Pprod); scanf(\"%d%d%d%d\",&amp;Cadd,&amp;Cfirst,&amp;Cmod,&amp;Cprod); init(c,Cadd,Cfirst,Cmod,Cprod); scanf(\"%d%d%d%d\",&amp;Ladd,&amp;Lfirst,&amp;Lmod,&amp;Lprod); init(l,Ladd,Lfirst,Lmod,Lprod); scanf(\"%d%d%d%d\",&amp;Radd,&amp;Rfirst,&amp;Rmod,&amp;Rprod); init(r,Radd,Rfirst,Rmod,Rprod); for (int i=1;i&lt;=n;i++) if (l[i]&gt;=r[i]) swap(l[i],r[i]); memcpy(b,c,sizeof(c)); sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=1;i&lt;=n;i++)&#123; c[i]=lower_bound(b+1,b+1+m,c[i])-b; q[i]=mp(p[i],i); ev[++M]=mp(l[i],c[i]); ev[++M]=mp(r[i]+1,-c[i]); &#125; sort(ev+1,ev+1+M);sort(q+1,q+1+n); int ans=0; for (int i=1,j=1;i&lt;=n;i++)&#123; while (j&lt;=M&amp;&amp;ev[j].X&lt;=q[i].X) if (ev[j].Y&gt;0) ist(1,1,m,ev[j++].Y,1);else ist(1,1,m,-ev[j++].Y,-1); if (s[1]&gt;=q[i].Y) (ans+=b[qry(1,1,m,q[i].Y)])%=MOD; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"扫描线","slug":"扫描线","permalink":"http://oi.linkfqy.top/tags/扫描线/"}]},{"title":"【小清新线段树】HDU5306 Gorgeous Sequence","slug":"HDU5306","date":"2018-09-27T13:11:01.000Z","updated":"2018-09-27T13:20:28.000Z","comments":true,"path":"posts/HDU5306/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU5306/","excerpt":"","text":"题面在这里 ​ 吉利论文题…… 维护区间最大值\\(mx\\)，严格次大值\\(sd\\)，最大值个数\\(t\\)，区间和\\(s\\) 设取\\(min\\)的数是\\(w\\)，如下讨论： \\(mx\\le w\\)：直接退出 \\(sd\\lt w \\lt mx\\)：添加懒标记表示把mx改为w \\(w\\le sd\\)：分别处理左右子区间 复杂度\\(O(qlogn)\\)，证明见论文 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005,maxs=4000005;int tst,n,q,a[maxn];int mx[maxs],sd[maxs],t[maxs],tg[maxs];ll s[maxs];#define ls x&lt;&lt;1#define rs x&lt;&lt;1|1inline void pushup(int x)&#123; s[x]=s[ls]+s[rs]; if (mx[ls]&lt;mx[rs]) mx[x]=mx[rs],t[x]=t[rs],sd[x]=max(mx[ls],sd[rs]);else if (mx[ls]&gt;mx[rs]) mx[x]=mx[ls],t[x]=t[ls],sd[x]=max(mx[rs],sd[ls]);else mx[x]=mx[ls],t[x]=t[ls]+t[rs],sd[x]=max(sd[ls],sd[rs]);&#125;inline void addtg(int x,int w)&#123; if (w&gt;=mx[x]) return; s[x]+=(ll)t[x]*(w-mx[x]);mx[x]=w;tg[x]=w;&#125;inline void pushdown(int x)&#123; if (tg[x]&gt;=0) addtg(ls,tg[x]),addtg(rs,tg[x]),tg[x]=-1;&#125;void build(int x,int l,int r)&#123; tg[x]=-1; if (l==r) &#123;mx[x]=s[x]=a[l];t[x]=1;sd[x]=-1;return;&#125; int mid=l+r&gt;&gt;1; build(ls,l,mid);build(rs,mid+1,r); pushup(x);&#125;void istmin(int x,int l,int r,int ql,int qr,int w)&#123; if (qr&lt;l||r&lt;ql||mx[x]&lt;=w) return; if (ql&lt;=l&amp;&amp;r&lt;=qr&amp;&amp;sd[x]&lt;w) &#123;addtg(x,w);return;&#125; int mid=l+r&gt;&gt;1; pushdown(x); istmin(ls,l,mid,ql,qr,w);istmin(rs,mid+1,r,ql,qr,w); pushup(x);&#125;ll qrys(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return qrys(ls,l,mid,ql,qr)+qrys(rs,mid+1,r,ql,qr);&#125;int qrymx(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return max(qrymx(ls,l,mid,ql,qr),qrymx(rs,mid+1,r,ql,qr));&#125;int main()&#123; tst=red(); while (tst--)&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); build(1,1,n); while (q--)&#123; int c=red(); if (c==0)&#123; int l=red(),r=red(),w=red(); istmin(1,1,n,l,r,w); &#125;else if (c==1)&#123; int l=red(),r=red(); printf(\"%d\\n\",qrymx(1,1,n,l,r)); &#125;else&#123; int l=red(),r=red(); printf(\"%lld\\n\",qrys(1,1,n,l,r)); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"Codeforces 490F Treeland Tour","slug":"CF490F","date":"2018-09-27T10:51:26.000Z","updated":"2018-09-27T10:54:24.000Z","comments":true,"path":"posts/CF490F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF490F/","excerpt":"","text":"题面在这里 ​ 直接枚举LIS的起点就好了，DFS时撤销操作，总复杂度\\(O(n^2logn)\\) 当然也有\\(O(nlogn)\\)的做法： 考虑一条路径可以在LCA处被统计 那么用线段树维护子树的LIS和LDS，线段树合并就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=6005,maxe=12005;int n,w[maxn],ans;int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int que[maxn],til;void dfs(int x,int fa)&#123; int pos=-1,old; if (!til||que[til]&lt;w[x]) que[++til]=w[x];else&#123; pos=lower_bound(que+1,que+1+til,w[x])-que; old=que[pos]; que[pos]=w[x]; &#125; ans=max(ans,til); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x); if (pos&lt;0) til--;else que[pos]=old;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); for (int i=1;i&lt;=n;i++) til=0,dfs(i,i); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"LIS","slug":"LIS","permalink":"http://oi.linkfqy.top/tags/LIS/"}]},{"title":"Codeforces 558E A Simple Task","slug":"CF558E","date":"2018-09-26T23:07:25.000Z","updated":"2018-09-26T23:10:58.000Z","comments":true,"path":"posts/CF558E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF558E/","excerpt":"","text":"题面在这里 ​ 开26棵线段树，在第i棵中，比i小的字母为0否则为1 这样排序就可以转化为0和1的区间覆盖了 关于答案：在这个位置上出现的最后一个1就是答案 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;const int maxn=100005,maxs=400005;int n,q; char str[maxn];int s[26][maxs],cv[26][maxs];inline void pushup(int x,int t) &#123;s[t][x]=s[t][x&lt;&lt;1]+s[t][x&lt;&lt;1|1];&#125;void build(int x,int l,int r,int t) &#123; cv[t][x]=-1; if (l==r) &#123;s[t][x]=(str[l]&gt;=t);return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid,t);build(x&lt;&lt;1|1,mid+1,r,t); pushup(x,t);&#125;inline void addcv(int x,int l,int r,int w,int t) &#123;s[t][x]=w*(r-l+1),cv[t][x]=w;&#125;inline void pushdown(int x,int l,int mid,int r,int t)&#123; if (cv[t][x]&gt;=0) addcv(x&lt;&lt;1,l,mid,cv[t][x],t),addcv(x&lt;&lt;1|1,mid+1,r,cv[t][x],t),cv[t][x]=-1;&#125;void ist(int x,int l,int r,int ql,int qr,int w,int t)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addcv(x,l,r,w,t);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x,l,mid,r,t); ist(x&lt;&lt;1,l,mid,ql,qr,w,t);ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w,t); pushup(x,t);&#125;int qry(int x,int l,int r,int ql,int qr,int t)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[t][x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x,l,mid,r,t); return qry(x&lt;&lt;1,l,mid,ql,qr,t)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr,t);&#125;int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;q,str+1); for (int i=1;i&lt;=n;i++) str[i]-='a'; for (int i=0;i&lt;26;i++) build(1,1,n,i); while (q--)&#123; int l,r,c;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;c); for (int i=0;i&lt;26;i++)&#123; int w=qry(1,1,n,l,r,i); if (c) ist(1,1,n,l,r-w,0,i),ist(1,1,n,r-w+1,r,1,i); else ist(1,1,n,l,l+w-1,1,i),ist(1,1,n,l+w,r,0,i); &#125; &#125; for (int i=0;i&lt;26;i++)&#123; for (int j=1;j&lt;=n;j++) printf(\"%d \",qry(1,1,n,j,j,i)); putchar('\\n'); &#125; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;26;j++) if (!qry(1,1,n,i,i,j))&#123; putchar(j-1+'a');break; &#125;else if (j==25) putchar('z'); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【小清新线段树】Codeforces 438D The Child and Sequence","slug":"CF438D","date":"2018-09-26T12:29:39.000Z","updated":"2018-09-26T12:32:58.000Z","comments":true,"path":"posts/CF438D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF438D/","excerpt":"","text":"题面在这里 ​ 如果x模一个比x小的数，至少会减半，所以单个点对答案的贡献是\\(log\\)的 如果一个区间最大值比模数w还小，就退出，这样保证复杂度 对于修改操作，因为是单点的，所以每次操作的贡献还是\\(log\\)的 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005,maxs=400005;int n,q,a[maxn];int mx[maxs];ll s[maxs];inline void pushup(int x) &#123;mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]);s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1];&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mx[x]=s[x]=a[l];return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void istmod(int x,int l,int r,int ql,int qr,int w)&#123; if (mx[x]&lt;w) return; if (qr&lt;l||r&lt;ql) return; if (l==r) &#123;mx[x]=s[x]=(s[x]%w);return;&#125; int mid=l+r&gt;&gt;1; istmod(x&lt;&lt;1,l,mid,ql,qr,w);istmod(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;void ist(int x,int l,int r,int k,int w)&#123; if (l==r) &#123;mx[x]=s[x]=w;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(x&lt;&lt;1,l,mid,k,w);else ist(x&lt;&lt;1|1,mid+1,r,k,w); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; return qry(x&lt;&lt;1,l,mid,ql,qr)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); build(1,1,n); while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%lld\\n\",qry(1,1,n,l,r)); &#125;else if (c==2)&#123; int l,r,w;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;w); istmod(1,1,n,l,r,w); &#125;else&#123; int k,w;scanf(\"%d%d\",&amp;k,&amp;w); ist(1,1,n,k,w); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 717H Pokermon League challenge","slug":"CF717H","date":"2018-09-26T11:18:45.000Z","updated":"2018-09-26T11:22:36.000Z","comments":true,"path":"posts/CF717H/","link":"","permalink":"http://oi.linkfqy.top/posts/CF717H/","excerpt":"","text":"题面在这里 ​ XJB随就好了，假装成功的概率是\\(\\frac1 2\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#define X first#define Y secondusing namespace std;const int maxn=100005,maxt=1000005;int n,e,T,t[maxn][21],belong[maxn],c[maxt];pair&lt;int,int&gt; a[maxn];bool work()&#123; for (int i=1;i&lt;=n;i++) belong[i]=t[i][rand()%t[i][0]+1]; for (int i=1;i&lt;=T;i++) c[i]=(rand()&amp;1); int res=0; for (int i=1;i&lt;=e;i++) res+=(c[belong[a[i].X]]!=c[belong[a[i].Y]]); return res*2&gt;=e;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=e;i++) scanf(\"%d%d\",&amp;a[i].X,&amp;a[i].Y); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;t[i][0]); for (int j=1;j&lt;=t[i][0];j++) scanf(\"%d\",&amp;t[i][j]),T=max(T,t[i][j]); &#125; while (!work()); for (int i=1;i&lt;=n;i++) printf(\"%d \",belong[i]);puts(\"\"); for (int i=1;i&lt;=T;i++) printf(\"%d \",c[i]+1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"随机","slug":"随机","permalink":"http://oi.linkfqy.top/tags/随机/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【小清新线段树】HDU5634 Rikka with Phi","slug":"HDU5634","date":"2018-09-26T09:57:15.000Z","updated":"2018-09-26T09:57:40.000Z","comments":true,"path":"posts/HDU5634/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU5634/","excerpt":"","text":"题面在这里 ​ 一个数\\(x\\)不断取\\(\\varphi\\)，变成1的复杂度是\\(O(logx)\\)的（奇数至少减一，偶数减半） 然后区间覆盖的操作也只会使不相同的数越来越少（每次操作对复杂度的贡献是\\(log\\)的） 那么用线段树维护一个区间是否完全相同，如果相同就直接做，不相同就分别做 总时间复杂度：\\(O(qlogn)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576#include&lt;cstdio&gt;typedef long long ll;const int maxn=300005,maxs=1200005,maxp=1e7+5;int tst,n,q,a[maxn],phi[maxp],p[maxp];bool vis[maxp];void makep(int n)&#123; phi[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i,phi[i]=i-1; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1; if (i%p[j]==0) &#123;phi[i*p[j]]=phi[i]*p[j];break;&#125;else phi[i*p[j]]=phi[i]*phi[p[j]]; &#125; &#125;&#125;ll s[maxs];int sm[maxs],cv[maxs];inline void pushup(int x)&#123; s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1]; if (sm[x&lt;&lt;1]==sm[x&lt;&lt;1|1]) sm[x]=sm[x&lt;&lt;1];else sm[x]=0;&#125;inline void addcv(int x,int l,int r,int w) &#123;s[x]=(ll)w*(r-l+1);sm[x]=w;cv[x]=w;&#125;inline void pushdown(int x,int l,int r,int mid)&#123; if (cv[x]) addcv(x&lt;&lt;1,l,mid,cv[x]),addcv(x&lt;&lt;1|1,mid+1,r,cv[x]),cv[x]=0;&#125;void build(int x,int l,int r)&#123; cv[x]=0; if (l==r) &#123;s[x]=sm[x]=a[l];return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr)&#123; if (sm[x]&amp;&amp;ql&lt;=l&amp;&amp;r&lt;=qr)&#123;addcv(x,l,r,phi[sm[x]]);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1;pushdown(x,l,r,mid); ist(x&lt;&lt;1,l,mid,ql,qr),ist(x&lt;&lt;1|1,mid+1,r,ql,qr); pushup(x);&#125;void change(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addcv(x,l,r,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1;pushdown(x,l,r,mid); change(x&lt;&lt;1,l,mid,ql,qr,w); change(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1;pushdown(x,l,r,mid); return qry(x&lt;&lt;1,l,mid,ql,qr)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int main()&#123; makep(1e7); scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); build(1,1,n); while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); ist(1,1,n,l,r); &#125;else if (c==2)&#123; int l,r,w;scanf(\"%d%d%d\",&amp;l,&amp;r,&amp;w); change(1,1,n,l,r,w); &#125;else&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%lld\\n\",qry(1,1,n,l,r)); &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"复杂度分析","slug":"复杂度分析","permalink":"http://oi.linkfqy.top/tags/复杂度分析/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【二分图匹配+强连通分量】BZOJ2140 稳定婚姻","slug":"BZOJ2140","date":"2018-09-25T11:30:37.000Z","updated":"2018-09-25T11:36:24.000Z","comments":true,"path":"posts/BZOJ2140/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2140/","excerpt":"","text":"题面在这里 ​ 考虑不安全的关系，就是二分图中能重新匹配的一个子集 这个子集中所有婚姻关系都是不安全的 考虑二分图匹配的过程：每次找一条交替的增广路，使匹配数+1 那么由增广路构成的回路其实就是上文提到的子集 婚姻关系：女连向男，交往关系：男连向女 同一个强连通分量的夫妻就是不安全的 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;map&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=8005,maxe=50005;int n,e,N;int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;map&lt;string,int&gt; id;int dfn[maxn],low[maxn],stk[maxn],SCC[maxn],times;bool instk[maxn];void Tarjan(int x)&#123; dfn[x]=low[x]=++times;instk[stk[++stk[0]]=x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]); else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (dfn[x]==low[x])&#123; SCC[0]++; while (stk[stk[0]]!=x) instk[stk[stk[0]]]=0,SCC[stk[stk[0]--]]=SCC[0]; instk[stk[stk[0]]]=0,SCC[stk[stk[0]--]]=SCC[0]; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n);N=0; for (int i=1;i&lt;=n;i++)&#123; string a,b;cin&gt;&gt;a&gt;&gt;b; id[a]=++N; id[b]=++N; add(id[b],id[a]); &#125; scanf(\"%d\",&amp;e); for (int i=1;i&lt;=e;i++)&#123; string a,b;cin&gt;&gt;a&gt;&gt;b; add(id[a],id[b]); &#125; for (int i=1;i&lt;=N;i++) if (!dfn[i]) Tarjan(i); for (int i=1;i&lt;=n;i++) if (SCC[i*2-1]==SCC[i*2]) puts(\"Unsafe\");else puts(\"Safe\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"强连通分量","slug":"强连通分量","permalink":"http://oi.linkfqy.top/tags/强连通分量/"}]},{"title":"【线段树+DP】Codeforces 573D Bear and Cavalry","slug":"CF573D","date":"2018-09-24T13:45:00.000Z","updated":"2018-09-24T22:44:08.000Z","comments":true,"path":"posts/CF573D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF573D/","excerpt":"","text":"题面在这里 ​ 显然如果没有限制，分别把两边排序一一对应是最优的 有一个很好的性质就是i和它匹配的马j距离不会超过3，即\\(|i-j|\\lt 3\\) 然后就可以DP了：\\(f_i\\)表示前i个人匹配了i头马的最大价值 然后可以用线段树维护左边有哪些点没被匹配（到区间外匹配），右边有几个 ​ 无耻地使用\\(O(nq)\\)卡常过了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=30005;int n,q,ban[maxn],ida[maxn],idb[maxn],rka[maxn],rkb[maxn];ll a[maxn],b[maxn],f[maxn],w1[maxn],w2[maxn],w3[maxn];inline bool cmpa(int i,int j) &#123;return a[i]&lt;a[j];&#125;inline bool cmpb(int i,int j) &#123;return b[i]&lt;b[j];&#125;void calc(int i)&#123; w1[i]=w2[i]=w3[i]=-1e18; if (i&gt;=1&amp;&amp;ban[i]!=i) w1[i]=a[i]*b[i]; if (i&gt;=2&amp;&amp;ban[i]!=i-1&amp;&amp;ban[i-1]!=i) w2[i]=a[i]*b[i-1]+a[i-1]*b[i]; if (i&gt;=3)&#123; if (ban[i]!=i-2&amp;&amp;ban[i-1]!=i&amp;&amp;ban[i-2]!=i-1) w3[i]=a[i]*b[i-2]+a[i-1]*b[i]+a[i-2]*b[i-1]; if (ban[i]!=i-1&amp;&amp;ban[i-1]!=i-2&amp;&amp;ban[i-2]!=i) w3[i]=max(w3[i],a[i]*b[i-1]+a[i-1]*b[i-2]+a[i-2]*b[i]); &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]),ida[i]=i; for (int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;b[i]),idb[i]=i; sort(ida+1,ida+1+n,cmpa);sort(idb+1,idb+1+n,cmpb); sort(a+1,a+1+n);sort(b+1,b+1+n); for (int i=1;i&lt;=n;i++) rka[ida[i]]=i,rkb[idb[i]]=i; for (int i=1;i&lt;=n;i++) ban[rka[i]]=rkb[i]; for (int i=1;i&lt;=n;i++) calc(i); while (q--)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); x=rka[x]; y=rka[y]; swap(ban[x],ban[y]); for (int i=max(1,x-5);i&lt;=min(n,x+5);i++) calc(i); for (int i=max(1,y-5);i&lt;=min(n,y+5);i++) calc(i); f[0]=0; for (int i=1;i&lt;=n;i++)&#123; f[i]=-1e16; if (i&gt;=1) f[i]=max(f[i],f[i-1]+w1[i]); if (i&gt;=2) f[i]=max(f[i],f[i-2]+w2[i]); if (i&gt;=3) f[i]=max(f[i],f[i-3]+w3[i]); &#125; printf(\"%lld\\n\",f[n]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ1443 [JSOI2009]游戏Game","slug":"BZOJ1443","date":"2018-09-24T09:17:30.000Z","updated":"2018-09-24T09:31:16.000Z","comments":true,"path":"posts/BZOJ1443/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1443/","excerpt":"","text":"题面在这里 ​ 很巧妙的一道题，利用了二分图的性质 考虑走一条长度为奇数的路径，先手是赢的 那么出发点就要满足出去的所有路径长度都为奇数 把每个点拆成两个点：先手走的点，后手走的点，然后相邻点连边 就得到了一个二分图 如果有完美匹配，先手是必败的 否则没匹配的那些点都可以作为起点（反证得） 事实上，所有可能没匹配的点都可以作为起点 那么刷完二分图匹配后对没匹配的点沿着增广路遍历到所有先手点都是答案 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=20005,maxe=80005,p[4][2]=&#123;&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;,&#123;-1,0&#125;&#125;;int n,m,N,id[105][105];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;char a[105][105]; bool ed[maxn],pi[maxn];int times,vis[maxn],con[maxn];bool find(int x)&#123; if (vis[x]==times) return 0; vis[x]=times; for (int j=lnk[x];j;j=nxt[j])&#123; int k=con[son[j]];con[son[j]]=x; if (!k||find(k)) return 1; con[son[j]]=k; &#125; return 0;&#125;void dfs(int x)&#123; vis[x]=times; if (x&lt;=N)&#123; ed[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (vis[son[j]]!=times) dfs(son[j]); &#125;else if (con[x]&amp;&amp;vis[con[x]]!=times) dfs(con[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); N=0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%s\",a[i]+1); for (int j=1;j&lt;=m;j++) if (a[i][j]=='.') id[i][j]=++N; &#125; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (a[i][j]=='.') for (int t=0;t&lt;4;t++)&#123; int x=i+p[t][0],y=j+p[t][1]; if (x&lt;1||x&gt;n||y&lt;1||y&gt;m) continue; if (a[x][y]=='#') continue; add(id[i][j],id[x][y]+N);add(id[x][y]+N,id[i][j]); &#125; int ans=0; for (int i=1;i&lt;=N;i++) times++,ans+=find(i); if (ans==N) puts(\"LOSE\");else&#123; puts(\"WIN\"); times++; for (int i=1;i&lt;=N;i++) pi[con[i+N]]=1; for (int i=1;i&lt;=N;i++) if (!pi[i]&amp;&amp;vis[i]!=times) dfs(i); for (int i=1;i&lt;=N;i++) if (ed[i])&#123; for (int x=1;x&lt;=n;x++) for (int y=1;y&lt;=m;y++) if (id[x][y]==i) printf(\"%d %d\\n\",x,y); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"}]},{"title":"Codeforces 794F Leha and security system","slug":"CF794F","date":"2018-09-23T15:13:04.000Z","updated":"2018-09-23T15:17:12.000Z","comments":true,"path":"posts/CF794F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF794F/","excerpt":"","text":"题面在这里 ​ 线段树维护10个数码的权 打lazy标记：x节点数码i变为\\(to[x][i]\\) 很考验线段树理解程度的一道题 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxs=400005;int n,q,a[maxn][10];ll s[maxs][10]; int to[maxs][10];inline void pushup(int x)&#123; for (int i=0;i&lt;=9;i++) s[x][i]=s[x&lt;&lt;1][i]+s[x&lt;&lt;1|1][i];&#125;void build(int x,int l,int r)&#123; for (int i=0;i&lt;=9;i++) to[x][i]=i; if (l==r)&#123; for (int i=0;i&lt;=9;i++) s[x][i]=a[l][i]; return; &#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;inline void addto(int x,int *tg)&#123; static ll tmp[10]; cl(tmp,0); for (int i=0;i&lt;=9;i++) tmp[i]=tg[to[x][i]]; for (int i=0;i&lt;=9;i++) to[x][i]=tmp[i]; cl(tmp,0); for (int i=0;i&lt;=9;i++) tmp[tg[i]]+=s[x][i]; for (int i=0;i&lt;=9;i++) s[x][i]=tmp[i];&#125;inline void pushdown(int x)&#123; bool suc=1; for (int i=0;i&lt;=9;i++) if (to[x][i]!=i) suc=0; if (suc) return; addto(x&lt;&lt;1,to[x]);addto(x&lt;&lt;1|1,to[x]); for (int i=0;i&lt;=9;i++) to[x][i]=i;&#125;void ist(int x,int l,int r,int ql,int qr,int *tg)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addto(x,tg);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,tg);ist(x&lt;&lt;1|1,mid+1,r,ql,qr,tg); pushup(x);&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr)&#123; ll res=0; for (int i=0;i&lt;=9;i++) res+=s[x][i]*i; return res; &#125; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return qry(x&lt;&lt;1,l,mid,ql,qr)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++)&#123; int x=red(),w=1; while (x) a[i][x%10]+=w,w*=10,x/=10; &#125; build(1,1,n); while (q--) if (red()==1)&#123; int l=red(),r=red(),x=red(),y=red(),t[10]; for (int i=0;i&lt;=9;i++) t[i]=i;t[x]=y; ist(1,1,n,l,r,t); &#125;else&#123; int l=red(),r=red(); printf(\"%lld\\n\",qry(1,1,n,l,r)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【线段树+并查集】Codeforces 811E Vladik and Entertaining Flags","slug":"CF811E","date":"2018-09-23T09:28:18.000Z","updated":"2018-09-23T09:30:48.000Z","comments":true,"path":"posts/CF811E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF811E/","excerpt":"","text":"题面在这里 ​ 一看n这么小，每次只询问区间，就可以用线段树搞 线段树每个节点维护区间左右两端属于哪个联通块，合并用并查集维护 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f; &#125;const int maxn=100005,maxs=400005;int n,m,q,A[11][maxn];struct node&#123; int s,l[11],r[11];&#125;T[maxs];int fa[45],id[45];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline node merge(const node&amp;a,const node&amp;b,int m)&#123; node c; c.s=a.s+b.s; for (int i=1;i&lt;=n;i++)&#123; fa[i]=a.l[i]; fa[i+n]=a.r[i]; fa[i+n*2]=b.l[i]+2*n; fa[i+n*3]=b.r[i]+2*n; &#125; for (int i=1;i&lt;=n;i++) if (A[i][m]==A[i][m+1]&amp;&amp;getfa(i+n)!=getfa(i+2*n)) fa[getfa(i+n)]=getfa(i+2*n),c.s--; cl(id,0); for (int i=1;i&lt;=n;i++)&#123; if (!id[getfa(i)]) id[getfa(i)]=i; if (!id[getfa(i+3*n)]) id[getfa(i+3*n)]=i+n; c.l[i]=id[getfa(i)]; c.r[i]=id[getfa(i+3*n)]; &#125; return c;&#125;void build(int x,int l,int r)&#123; if (l==r)&#123; for (int i=1;i&lt;=n;i++) T[x].l[i]=T[x].r[i]=(A[i][l]!=A[i-1][l])?T[x].s++,i:T[x].l[i-1]; return; &#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); T[x]=merge(T[x&lt;&lt;1],T[x&lt;&lt;1|1],mid);&#125;node qry(int x,int l,int r,int ql,int qr)&#123; if (ql==l&amp;&amp;r==qr) return T[x]; int mid=l+r&gt;&gt;1; if (qr&lt;=mid) return qry(x&lt;&lt;1,l,mid,ql,qr);else if (ql&gt; mid) return qry(x&lt;&lt;1|1,mid+1,r,ql,qr);else return merge(qry(x&lt;&lt;1,l,mid,ql,mid),qry(x&lt;&lt;1|1,mid+1,r,mid+1,qr),mid);&#125;int main()&#123; n=red(),m=red(),q=red(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) A[i][j]=red(); build(1,1,m); while (q--)&#123; int l=red(),r=red(); printf(\"%d\\n\",qry(1,1,m,l,r).s); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【LCT缩环+并查集】BZOJ2959 长跑","slug":"BZOJ2959","date":"2018-09-23T05:02:45.000Z","updated":"2018-09-23T05:22:26.000Z","comments":true,"path":"posts/BZOJ2959/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2959/","excerpt":"","text":"题面在这里 ​ 显然一个边双联通分量里的值可以同时取到 那么把边双缩成点，就可以用LCT维护了 并查集用于维护每个点被缩到哪个点上 注意LCT维护连通性，getrt后一定要splay(x)！！不然复杂度是错的，T了一发查好久 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=150005;int n,q,f[maxn];//ff[maxn];inline int getf(int x) &#123;return f[x]==x?x:f[x]=getf(f[x]);&#125;//inline int getff(int x) &#123;return ff[x]==x?x:ff[x]=getff(ff[x]);&#125;int fa[maxn],s[maxn][2],sum[maxn],w[maxn],val[maxn];bool flp[maxn];#define fa(x) (getf(fa[x]))#define isroot(x) (s[fa(x)][0]!=x&amp;&amp;s[fa(x)][1]!=x)inline void pushup(int x) &#123;sum[x]=sum[s[x][0]]+sum[s[x][1]]+val[x];&#125;inline void addflip(int x) &#123;swap(s[x][0],s[x][1]),flp[x]^=1;&#125;inline void pushdown(int x) &#123;if (flp[x]) addflip(s[x][0]),addflip(s[x][1]),flp[x]^=1;&#125;inline void rotate(int x)&#123; int f=fa(x),g=fa(f),d= s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; s[x][d]=f; fa[f]=x; pushup(f); pushup(x);&#125;int stk[maxn],top;inline void splay(int x)&#123; stk[top=1]=x; for (int i=x;!isroot(i);i=fa(i)) stk[++top]=fa(i); while (top) pushdown(stk[top--]); while (!isroot(x))&#123; int f=fa(x),g=fa(f),d= s[f][0]==x,dd= s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x); else rotate(x),rotate(x); else rotate(x); &#125;&#125;inline void access(int x) &#123;for (int t=0;x;t=x,x=fa(x)) splay(x),s[x][1]=t,pushup(x);&#125;inline void mr(int x) &#123;access(x);splay(x);addflip(x);&#125;inline void link(int x,int y) &#123;mr(x);fa[x]=y;&#125;inline int getrt(int x) &#123;access(x);splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125;void dfs(int x,int rt)&#123; if (s[x][0]) val[rt]+=val[s[x][0]],dfs(s[x][0],rt); if (s[x][1]) val[rt]+=val[s[x][1]],dfs(s[x][1],rt); f[x]=rt;s[x][0]=s[x][1]=0;&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) val[i]=w[i]=red(),f[i]=i; while (q--)&#123; int c=red(),x=red(),y=red(); if (c==1)&#123; x=getf(x);y=getf(y); if (getrt(x)!=getrt(y)) link(x,y);else if (x!=y)&#123; mr(x);access(y);splay(x); dfs(x,x);pushup(x); &#125; &#125;else if (c==2)&#123; int fx=getf(x); mr(fx);access(fx);val[fx]+=y-w[x];w[x]=y;pushup(fx); &#125;else&#123; x=getf(x);y=getf(y); if (getrt(x)!=getrt(y)) puts(\"-1\"); else mr(x),access(y),splay(y),printf(\"%d\\n\",sum[y]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"双联通分量","slug":"双联通分量","permalink":"http://oi.linkfqy.top/tags/双联通分量/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"}]},{"title":"【线段树分治+二分图判定+并查集/LCT】BZOJ4025 二分图","slug":"BZOJ4025","date":"2018-09-22T14:03:45.000Z","updated":"2018-09-22T14:30:10.000Z","comments":true,"path":"posts/BZOJ4025/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4025/","excerpt":"","text":"题面在这里 ​ 这种与时间区间有关的问题可以线段树分治搞 其实就是利用线段树能把任意区间分成log段的特性 \\(solve(l,r,E)\\)表示当前处理\\([l,r]\\)时间，涉及这段时间的边集合为\\(E\\) 对于\\(E\\)中的每条边\\((u,v,s,t)\\)： \\(s=l,t=r\\)：加边，如果出现奇环则\\([l,r]\\)的答案都是NO \\(s\\le mid\\)：放到左子区间处理 \\(t\\gt mid\\)：放到右子区间处理 \\(\\text{otherwise}\\)分成两半处理 ​ 其实这题LCT也是一种很好的解法 所有边按时间排序，做扫描线 用LCT维护连通性和奇偶性，对于成环的边，保留消失时间大的 所以就是最大生成树了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;#define pb push_backusing namespace std;const int maxn=100005,maxe=200005,maxs=200005;int n,e,T;int fa[maxn],c[maxn],rk[maxn],rkk[maxs],X[maxs],Y[maxs],cc[maxs],len;inline void ufs_init()&#123; len=0; for (int i=1;i&lt;=n;i++) fa[i]=i,rk[i]=1;&#125;inline int getfa(int x) &#123;while (fa[x]!=x) x=fa[x];return x;&#125;inline int dis(int x)&#123; int res=0; while (fa[x]!=x) res^=c[x],x=fa[x]; return res;&#125;inline void merge(int x,int y,int w)&#123; x=getfa(x); y=getfa(y); if (x==y) return; if (rk[x]&lt;rk[y]) swap(x,y); len++; X[len]=x; Y[len]=y; rkk[len]=rk[x]; cc[len]=c[y]; fa[y]=x; rk[x]=max(rk[x],rk[y]+1); c[y]=w;&#125;inline void undo()&#123; rk[X[len]]=rkk[len]; c[Y[len]]=cc[len]; fa[Y[len]]=Y[len]; len--;&#125;struct data&#123; int x,y,s,t; data () &#123;&#125; data (int _x,int _y,int _s,int _t):x(_x),y(_y),s(_s),t(_t) &#123;&#125;&#125;;void solve(int l,int r,vector&lt;data&gt; &amp;v)&#123; vector&lt;data&gt; lv,rv; vector&lt;data&gt;:: iterator it; int mid=l+r&gt;&gt;1,tag=len; for (it=v.begin();it!=v.end();it++) if (it-&gt;s==l&amp;&amp;it-&gt;t==r)&#123; int w=dis(it-&gt;x)^dis(it-&gt;y)^1; if (getfa(it-&gt;x)!=getfa(it-&gt;y)) merge(it-&gt;x,it-&gt;y,w); else if (w&amp;1)&#123; for (int i=l;i&lt;=r;i++) puts(\"No\"); while (len&gt;tag) undo(); return; &#125; &#125;else if (it-&gt;t &lt;=mid) lv.pb(*it);else if (it-&gt;s &gt; mid) rv.pb(*it);else lv.pb(data(it-&gt;x,it-&gt;y,it-&gt;s,mid)),rv.pb(data(it-&gt;x,it-&gt;y,mid+1,it-&gt;t)); if (l==r) puts(\"Yes\"); else solve(l,mid,lv),solve(mid+1,r,rv); while (len&gt;tag) undo();&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;e,&amp;T); ufs_init(); vector&lt;data&gt; v; for (int i=1,x,y,s,t;i&lt;=e;i++)&#123; scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;s,&amp;t); s++; if (s&gt;t) continue; v.pb(data(x,y,s,t)); &#125; solve(1,T,v); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"},{"name":"线段树分治","slug":"线段树分治","permalink":"http://oi.linkfqy.top/tags/线段树分治/"}]},{"title":"Codeforces 723F st-Spanning Tree","slug":"CF723F","date":"2018-09-21T18:11:15.000Z","updated":"2018-09-21T23:19:34.000Z","comments":true,"path":"posts/CF723F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF723F/","excerpt":"","text":"题面在这里 题意：求一个无向连通图的生成树，使得S和T的度数分别不超过ds和dt ​ 首先把端点不为S或T的边做生成树 这样一个联通块只和S或T有边 只和S有边就连S，只和T有边就连T 和S，T都有边，挑度数满足要求的连 最后别忘了判断S和T之间的边 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define mp make_pair#define X first#define Y secondusing namespace std;const int maxn=200005,maxe=800005;int n,e,S,T,ds,dt,fa[maxn],top;pair&lt;int,int&gt; ans[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); scanf(\"%d%d%d%d\",&amp;S,&amp;T,&amp;ds,&amp;dt); for (int i=1;i&lt;=n;i++) if (i!=S&amp;&amp;i!=T) for (int j=lnk[i];j;j=nxt[j]) if (son[j]!=S&amp;&amp;son[j]!=T) if (getfa(i)!=getfa(son[j])) ans[++top]=mp(i,son[j]),fa[getfa(i)]=getfa(son[j]); int fs=0,ft=0; for (int i=1;i&lt;=n;i++) if (i!=S&amp;&amp;i!=T) for (int j=lnk[i];j;j=nxt[j]) if (son[j]==S)&#123; if (getfa(i)!=getfa(S)&amp;&amp;fs&lt;ds) ans[++top]=mp(i,S),fa[getfa(i)]=getfa(S),fs++; &#125;else if (son[j]==T)&#123; if (getfa(i)!=getfa(T)&amp;&amp;ft&lt;dt) ans[++top]=mp(i,T),fa[getfa(i)]=getfa(T),ft++; &#125; for (int j=lnk[S];j;j=nxt[j]) if (son[j]==T&amp;&amp;getfa(S)!=getfa(T)) ans[++top]=mp(S,T),fs++,ft++; if (fs&gt;ds||ft&gt;dt||top!=n-1) return puts(\"No\"),0; puts(\"Yes\"); for (int i=1;i&lt;n;i++) printf(\"%d %d\\n\",ans[i].X,ans[i].Y); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"构造","slug":"构造","permalink":"http://oi.linkfqy.top/tags/构造/"}]},{"title":"【二分图染色】Codeforces 547D Mike and Fish","slug":"CF547D","date":"2018-09-21T08:09:23.000Z","updated":"2018-09-21T13:18:12.000Z","comments":true,"path":"posts/CF547D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF547D/","excerpt":"","text":"题面在这里 题意：给平面上n个点黑白染色，使得每一行或每一列两种颜色数量差不超过1 ​ 考虑这样建图： 对每一行的相邻两个点连边，每一列相邻两个点连边 因为连的边都是平行于坐标轴的，所以不存在奇环，就一定是二分图了 然后二分图黑白染色就是一个可行答案 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,maxe=800005;int n;int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct data&#123; int x,y;&#125;a[maxn];vector&lt;int&gt; X[maxn],Y[maxn];bool vis[maxn],s[maxn];void dfs(int x)&#123; vis[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]) s[son[j]]=s[x]^1,dfs(son[j]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y),X[a[i].x].push_back(i),Y[a[i].y].push_back(i); for (int i=1;i&lt;=2e5;i++)&#123; for (int j=0;j&lt;X[i].size();j++) if ((j^1)&lt;X[i].size()) add(X[i][j^1],X[i][j]); for (int j=0;j&lt;Y[i].size();j++) if ((j^1)&lt;Y[i].size()) add(Y[i][j^1],Y[i][j]); &#125; for (int i=1;i&lt;=n;i++) if (!vis[i]) dfs(i); for (int i=1;i&lt;=n;i++) putchar(s[i]?'r':'b'); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【分治+并查集】Codeforces 603E Pastoral Oddities","slug":"CF603E","date":"2018-09-21T00:47:32.000Z","updated":"2018-09-21T07:26:48.000Z","comments":true,"path":"posts/CF603E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF603E/","excerpt":"","text":"题面在这里 ​ 首先“所有点度数为奇数”这个条件太难验证了，需要转化一下 观察可得，当且仅当每个联通块的点数为偶数时，存在一个子图使得所有点的度数为奇数 证明比较简单，此处略 ​ 然后发现答案是不增的，这样我们就可以分治了： \\(solve(ql,qr,l,r)\\)表示处理\\([ql,qr]\\)区间内的边和询问，答案区间为\\([l,r]\\) 如果我们得到了第\\(mid\\)个询问的答案\\(ans[mid]\\)，就可以分治\\(solve(ql,mid-1,ans[mid],r),solve(mid+1,r,l,ans[mid])\\) 注意这里权值为\\(ans[mid]\\)的边是两个子区间共用的，如果这样的边很多复杂度就不能保证 所以直接把边权排序后的编号作为边权 如何求\\(ans[mid]\\)？看下图： 横坐标为询问，纵坐标为边权 先加入DHYX内所有边，然后从小到大加入THGR，出现所有联通块都是偶数就得到了\\(ans[mid]\\) 用按秩合并并查集维护连通性和奇联通块个数，记得撤销加边 如果没有得到\\(ans[mid]\\)： 加入DXYH内所有边 \\(solve(mid+1,qr,l,r)\\) 得到了\\(ans[mid]\\)： 加入SEDT内所有边 \\(solve(ql,mid-1,ans[mid],r)\\) 加入DXYH内所有边 \\(solve(mid+1,qr,l,ans[mid])\\) 总时间复杂度\\(O(m\\cdot log^2m)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=300005;int n,e,ans[maxe];struct data&#123; int x,y,w,id; data () &#123;&#125; data (int _x,int _y,int _w):x(_x),y(_y),w(_w) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe],b[maxe];int fa[maxn],siz[maxn],dep[maxn],del[maxe],depp[maxe],X[maxe],Y[maxe],ji,len;inline int getfa(int x) &#123;return fa[x]==x?x:getfa(fa[x]);&#125;inline void merge(int x,int y)&#123; x=getfa(x);y=getfa(y); if (x==y) return; if (dep[x]&lt;dep[y]) swap(x,y); ++len; if ((siz[x]&amp;1)&amp;&amp;(siz[y]&amp;1)) del[len]=-2,ji-=2; else del[len]=0; X[len]=x;Y[len]=y; depp[len]=dep[y]; siz[x]+=siz[y];dep[x]=max(dep[x],dep[y]+1); fa[y]=x;&#125;inline void undo()&#123; ji-=del[len]; dep[X[len]]=depp[len]; siz[X[len]]-=siz[Y[len]]; fa[Y[len]]=Y[len]; len--;&#125;void solve(int ql,int qr,int l,int r)&#123; if (ql&gt;qr) return; int mid=ql+qr&gt;&gt;1,ans_mid=0; int t1=len; for (int i=ql;i&lt;=mid;i++) if (a[i].w&lt;l) merge(a[i].x,a[i].y); for (int i=l;i&lt;=r;i++)&#123; if (b[i].id&lt;=mid) merge(b[i].x,b[i].y); if (ji==0) &#123;ans_mid=i;break;&#125; &#125; while (len&gt;t1) undo(); if (!ans_mid)&#123; for (int i=ql;i&lt;=mid;i++)&#123; ans[i]=-1; if (a[i].w&lt;l) merge(a[i].x,a[i].y); &#125; solve(mid+1,qr,l,r); &#125;else&#123; ans[mid]=b[ans_mid].w; for (int i=l;i&lt;ans_mid;i++) if (b[i].id&lt;ql) merge(b[i].x,b[i].y); solve(ql,mid-1,ans_mid,r); while (len&gt;t1) undo(); for (int i=ql;i&lt;=mid;i++) if (a[i].w&lt;l) merge(a[i].x,a[i].y); solve(mid+1,qr,l,ans_mid); &#125; while (len&gt;t1) undo();&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); ji=n; for (int i=1;i&lt;=n;i++) fa[i]=i,dep[i]=siz[i]=1; for (int i=1;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w),a[i].id=i,b[i]=a[i]; sort(b+1,b+1+e); for (int i=1;i&lt;=e;i++) a[b[i].id].w=i; solve(1,e,1,e); for (int i=1;i&lt;=e;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"分治","slug":"分治","permalink":"http://oi.linkfqy.top/tags/分治/"}]},{"title":"【单调栈+主席树/扫描线+线段树】BZOJ4826 [Hnoi2017]影魔","slug":"BZOJ4826","date":"2018-09-20T11:31:46.000Z","updated":"2018-09-20T11:47:22.000Z","comments":true,"path":"posts/BZOJ4826/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4826/","excerpt":"","text":"题面在这里 ​ 首先i,j相邻会有\\(p_1\\)的贡献，可以很快得到 考虑三元组\\((i,k,j)\\)对应区间\\([i,j]\\)的最大值，次大值，第三大值 可以用单调栈处理左右第一个比\\(a_i\\)大的位置\\(L_i,R_i\\) \\(L_i,R_i\\)有\\(p_1\\)的贡献 \\(L_i,(i,R_i)\\)有\\(p_2\\)的贡献 \\((L_i,i),R_i\\)有\\(P_2\\)的贡献 抽象到二维平面就是一些点和线段，求矩阵和（套路） 扫描线+线段树或者直接主席树标记永久化即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=200005,maxs=20000005;int n,q,w1,w2,a[maxn];int ls[maxs],rs[maxs],len,Lrot[maxn],Rrot[maxn];ll s[maxs],ad[maxs];int ist(int pre,int l,int r,int ql,int qr,int w)&#123; ql=max(ql,l); qr=min(qr,r); int x=++len; ls[x]=ls[pre];rs[x]=rs[pre];s[x]=s[pre]+w*(qr-ql+1);ad[x]=ad[pre]; if (ql&lt;=l&amp;&amp;r&lt;=qr) return ad[x]+=w,x; int mid=l+r&gt;&gt;1; if (ql&lt;=mid) ls[x]=ist(ls[pre],l,mid,ql,qr,w); if (qr&gt;mid) rs[x]=ist(rs[pre],mid+1,r,ql,qr,w); return x;&#125;ll qry(int x,int l,int r,int ql,int qr)&#123; ql=max(ql,l); qr=min(qr,r); if (!x) return 0; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; int mid=l+r&gt;&gt;1; ll res=ad[x]*(qr-ql+1); if (ql&lt;=mid) res+=qry(ls[x],l,mid,ql,qr); if (qr&gt;mid) res+=qry(rs[x],mid+1,r,ql,qr); return res;&#125;int L[maxn],R[maxn],stk[maxn],top;struct data&#123; int l,r,w; data () &#123;&#125; data (int _l,int _r,int _w):l(_l),r(_r),w(_w) &#123;&#125;&#125;;vector&lt;data&gt; lv[maxn],rv[maxn];int main()&#123; scanf(\"%d%d%d%d\",&amp;n,&amp;q,&amp;w1,&amp;w2); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); stk[top=0]=0; for (int i=1;i&lt;=n;i++)&#123; while (top&amp;&amp;a[stk[top]]&lt;a[i]) top--; L[i]=stk[top]; stk[++top]=i; &#125; stk[top=0]=n+1; for (int i=n;i&gt;=1;i--)&#123; while (top&amp;&amp;a[stk[top]]&lt;a[i]) top--; R[i]=stk[top]; stk[++top]=i; &#125; for (int i=1;i&lt;=n;i++)&#123; if (L[i]+1&lt;=i-1&amp;&amp;R[i]&lt;=n) lv[R[i]].push_back(data(L[i]+1,i-1,w2)); if (i+1&lt;=R[i]-1&amp;&amp;L[i]&gt;=1) rv[L[i]].push_back(data(i+1,R[i]-1,w2)); if (1&lt;=L[i]&amp;&amp;R[i]&lt;=n) lv[R[i]].push_back(data(L[i],L[i],w1)); &#125; for (int i=1;i&lt;=n;i++)&#123; Lrot[i]=Lrot[i-1]; Rrot[i]=Rrot[i-1]; for (int j=0;j&lt;lv[i].size();j++) Lrot[i]=ist(Lrot[i],1,n,lv[i][j].l,lv[i][j].r,lv[i][j].w); for (int j=0;j&lt;rv[i].size();j++) Rrot[i]=ist(Rrot[i],1,n,rv[i][j].l,rv[i][j].r,rv[i][j].w); &#125; while (q--)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%lld\\n\",(y-x)*w1+qry(Rrot[y],1,n,x,y)-qry(Rrot[x-1],1,n,x,y)+qry(Lrot[y],1,n,x,y)-qry(Lrot[x-1],1,n,x,y)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【单调栈+线段树】Codeforces 407E k-d-sequence","slug":"CF407E","date":"2018-09-19T06:10:20.000Z","updated":"2018-09-19T11:31:38.000Z","comments":true,"path":"posts/CF407E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF407E/","excerpt":"","text":"题面在这里 题意：见BZOJ4527 ​ 显然只有模\\(d\\)同余的一段连续区间才可能作为答案 对于每一段分别处理： \\(\\lfloor \\frac{a_i} d \\rfloor\\)构成的数列公差为1，一个区间\\([L,R]\\)合法当且仅当 \\[ Max-Min+1\\le R-L+1 \\\\ \\Leftrightarrow Max-Min-R \\le k-L \\] 所以我们从大到小枚举\\(L\\)，用线段树维护不等式左边的值 相当于询问权值小于等于某个东西的最右位置，维护区间最小值就可以了 可以用单调栈维护当前\\(L\\)的\\(Max/Min\\)控制范围，出栈入栈时在线段树上修改就好了 ​ 注意几点： \\(d=0\\)时特判 区间内不能含有相同的元素 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005,maxs=800005,INF=0x3f3f3f3f;int n,K,d,a[maxn];struct data&#123; int l,r; data () &#123;&#125; data (int _l,int _r):l(_l),r(_r) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return r-l&gt;b.r-b.l||r-l==b.r-b.l&amp;&amp;l&lt;b.l;&#125;&#125;ans(1,1);int mn[maxs],ad[maxs],Ret;inline void pushup(int x) &#123;mn[x]=min(mn[x&lt;&lt;1],mn[x&lt;&lt;1|1]);&#125;inline void addad(int x,int w) &#123;mn[x]+=w;ad[x]+=w;&#125;inline void pushdown(int x) &#123;if (ad[x]) addad(x&lt;&lt;1,ad[x]),addad(x&lt;&lt;1|1,ad[x]),ad[x]=0;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mn[x]=-r;return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addad(x,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;void qry(int x,int l,int r,int K)&#123; if (l==r) &#123;Ret=l;return;&#125; int mid=l+r&gt;&gt;1; pushdown(x); if (mn[x&lt;&lt;1|1]&lt;=K) qry(x&lt;&lt;1|1,mid+1,r,K);else qry(x&lt;&lt;1,l,mid,K);&#125;void query(int x,int l,int r,int ql,int qr,int K)&#123; if (Ret) return; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;if (mn[x]&lt;=K) qry(x,l,r,K);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); query(x&lt;&lt;1|1,mid+1,r,ql,qr,K); query(x&lt;&lt;1,l,mid,ql,qr,K);&#125;map&lt;int,int&gt; nxt;int stk1[maxn],stk2[maxn],top1,top2,far;void solve(const int&amp;l,const int&amp;r)&#123; if (l==r) return; for (int i=l;i&lt;=r;i++) a[i]=(a[i]+1e9)/d+1; top1=top2=0; stk1[0]=stk2[0]=far=r+1; nxt.clear(); for (int i=r;i&gt;=l;i--)&#123; if (nxt.count(a[i])) far=min(far,nxt[a[i]]); nxt[a[i]]=i; while (top1&amp;&amp;a[stk1[top1]]&gt;=a[i])&#123; ist(1,1,n,stk1[top1],stk1[top1-1]-1,a[stk1[top1]]); top1--; &#125; stk1[++top1]=i; ist(1,1,n,stk1[top1],stk1[top1-1]-1,-a[i]); while (top2&amp;&amp;a[stk2[top2]]&lt;=a[i])&#123; ist(1,1,n,stk2[top2],stk2[top2-1]-1,-a[stk2[top2]]); top2--; &#125; stk2[++top2]=i; ist(1,1,n,stk2[top2],stk2[top2-1]-1,a[i]); Ret=0; query(1,1,n,i,far-1,K-i); ans=min(ans,data(i,Ret)); &#125;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;K,&amp;d); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); if (d==0)&#123; for (int i=1,j=1;i&lt;=n;i=j)&#123; while (j&lt;=n&amp;&amp;a[i]==a[j]) j++; ans=min(ans,data(i,j-1)); &#125; printf(\"%d %d\",ans.l,ans.r); return 0; &#125; build(1,1,n); for (int i=1,j=1;i&lt;=n;i=j)&#123; while (j&lt;=n&amp;&amp;(a[i]%d+d)%d==(a[j]%d+d)%d) j++; solve(i,j-1); &#125; printf(\"%d %d\",ans.l,ans.r); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"单调栈","slug":"单调栈","permalink":"http://oi.linkfqy.top/tags/单调栈/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ3316 JC loves Mkk","slug":"BZOJ3316","date":"2018-09-18T09:48:24.000Z","updated":"2018-09-18T09:53:38.000Z","comments":true,"path":"posts/BZOJ3316/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3316/","excerpt":"","text":"题面在这里 ​ 显然是分数规划的题，先二分答案 然后就转化为求是否有一个子区间的和大于0 这个区间满足长度为属于\\([L,R]\\)的偶数 单调队列维护即可 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;typedef long long ll;const int maxn=200005;const double eps=1e-4;int n,L,R,N,w[maxn];double a[maxn],s[maxn];ll X,Y,ansx=1,ansy=1,ws[maxn];ll gcd(ll x,ll y) &#123;return y==0?x:gcd(y,x%y);&#125;int que[2][maxn];bool check(double ww)&#123; for (int i=1;i&lt;=N;i++) a[i]=w[i]-ww,s[i]=s[i-1]+a[i]; int hed[2]=&#123;1,1&#125;,til[2]=&#123;1,0&#125;; que[0][1]=0; for (int i=1;i&lt;=N;i++)&#123; int t=i&amp;1; while (hed[t]&lt;=til[t]&amp;&amp;i-que[t][hed[t]]&gt;R) hed[t]++; if (i&gt;=L)&#123; int t=(i-L)&amp;1; while (hed[t]&lt;=til[t]&amp;&amp;s[que[t][til[t]]]&gt;=s[i-L]) til[t]--; que[t][++til[t]]=i-L; &#125; if (hed[t]&lt;=til[t]) if (L&lt;=i-que[t][hed[t]]&amp;&amp;i-que[t][hed[t]]&lt;=R) if (s[i]-s[que[t][hed[t]]]&gt;=eps) &#123;ansx=ws[i]-ws[que[t][hed[t]]];ansy=i-que[t][hed[t]];return 1;&#125; &#125; return 0;&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;L,&amp;R);N=2*n; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]),w[i+n]=w[i]; for (int i=1;i&lt;=N;i++) ws[i]=ws[i-1]+w[i]; check(3.5); double l=0,r=1e14; while (r-l&gt;=eps)&#123; double mid=(l+r)/2; if (check(mid)) l=mid;else r=mid; &#125; ll t=gcd(ansx,ansy);ansx/=t;ansy/=t; if (ansy==1) printf(\"%lld\",ansx);else printf(\"%lld/%lld\",ansx,ansy); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调队列","slug":"单调队列","permalink":"http://oi.linkfqy.top/tags/单调队列/"},{"name":"分数规划","slug":"分数规划","permalink":"http://oi.linkfqy.top/tags/分数规划/"}]},{"title":"Codeforces 810D Glad to see you!","slug":"CF810D","date":"2018-09-17T13:34:19.000Z","updated":"2018-09-17T13:37:10.000Z","comments":true,"path":"posts/CF810D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF810D/","excerpt":"","text":"题面在这里 ​ 先二分出一个答案，再在\\([1,x-1]\\)和\\([x+1,n]\\)里找第二个答案 对于二分区间\\([l,r]\\)询问\\(mid,mid+1\\)，缩小范围 ​ 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;const int maxn=100005;int n,K;bool qry(int x,int y)&#123; if (y&gt;n) return 1; printf(\"1 %d %d\\n\",x,y);fflush(stdout); char s[5]; scanf(\"%s\",s); return s[0]=='T';&#125;int work(int l,int r)&#123; if (l&lt;1||r&gt;n) return 0; int res=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (qry(mid,mid+1)) res=mid,r=mid-1;else l=mid+1; &#125; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); int x,y; x=work(1,n); y=work(1,x-1); if (!y) y=work(x+1,n); printf(\"2 %d %d\\n\",x,y);fflush(stdout); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"交互题","slug":"交互题","permalink":"http://oi.linkfqy.top/tags/交互题/"}]},{"title":"Codeforces 1041F Ray in the tube","slug":"CF1041F","date":"2018-09-17T12:41:37.000Z","updated":"2018-09-17T12:50:14.000Z","comments":true,"path":"posts/CF1041F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1041F/","excerpt":"","text":"题面在这里 题意：一根管道，上下边界分别有一些传感器，射出一条光线在管内反弹，问最多射到多少个传感器上 ​ 首先考虑出射点\\(x_a\\)和第一个反弹点\\(x_b\\)的横坐标差\\(d\\) 那么在\\(x_a\\)所在直线上的\\(x_a+d\\cdot 2k\\)位置会被射到 \\(x_b\\)所在直线上的\\(x_a+d\\cdot (2k+1)\\)位置会被射到 发现都是\\(d\\)的奇数/偶数倍 那么显然\\(d=2^l,(l\\gt 0)\\) 然后爆枚\\(d\\)，所有同余\\(2d\\)的位置都是同时被打到的 ​ 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;map&gt;using namespace std;const int maxn=100005;int n,m,a[maxn],b[maxn],ty,ans;map&lt;int,int&gt; numa,numb;void calc(int l)&#123; numa.clear(); numb.clear(); l++;int p=1; while (l--) p=p*2; for (int i=1;i&lt;=n;i++) numa[a[i]%p]++; for (int i=1;i&lt;=m;i++) numb[b[i]%p]++; for (int i=1;i&lt;=n;i++) ans=max(ans,numa[a[i]%p]+numb[(a[i]+p/2)%p]); for (int i=1;i&lt;=m;i++) ans=max(ans,numa[(a[i]+p/2)%p]+numb[a[i]%p]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;ty); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); scanf(\"%d%d\",&amp;m,&amp;ty); for (int i=1;i&lt;=m;i++) scanf(\"%d\",&amp;b[i]); ans=2; for (int i=0;i&lt;30;i++) calc(i); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://oi.linkfqy.top/tags/数学/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1041E Tree Reconstruction","slug":"CF1041E","date":"2018-09-16T13:33:11.000Z","updated":"2018-09-16T13:43:24.000Z","comments":true,"path":"posts/CF1041E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1041E/","excerpt":"","text":"题面在这里 题意：给定n-1个点对，分别表示树上一条边删去后两个联通块的编号最大值，构造一棵满足上述点对的树 ​ 首先注意到\\(n\\)一定在每个给出的点对中出现过 那么可以把\\(n\\)作为根，每个点对剩下那个数字就是一个子树的最大值 显然\\(n-1\\)出现次数就是深度 考虑\\(n-2\\)出现了\\(k\\)次，其对应着一条长为\\(k\\)的链，可以接在任意位置，就放在\\(n\\)上好了 其他同理，最后把所有没出现过的节点填到链上即可 注意只能填到大编号对应的链上，如果找不到就是无解 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,X[maxn],Y[maxn],dep[maxn],lst[maxn],len;pair&lt;int,int&gt; ans[maxn];int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;X[i],&amp;Y[i]); dep[X[i]]++;dep[Y[i]]++; &#125; if (dep[n]!=n-1) return puts(\"NO\"),0; for (int i=1;i&lt;=n;i++) if (dep[i]) lst[i]=n; for (int i=1;i&lt;=n;i++) if (dep[i]==0)&#123; int j; for (j=i+1;j&lt;n;j++) if (dep[j]&gt;1) break; if (j&gt;=n) return puts(\"NO\"),0; ans[++len]=make_pair(lst[j],i); dep[j]--;lst[j]=i; if (!dep[j]) ans[++len]=make_pair(i,n); &#125; for (int i=1;i&lt;=n;i++) if (dep[i]==1) ans[++len]=make_pair(lst[i],i); puts(\"YES\"); for (int i=1;i&lt;n;i++) printf(\"%d %d\\n\",ans[i].first,ans[i].second); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"构造","slug":"构造","permalink":"http://oi.linkfqy.top/tags/构造/"}]},{"title":"Codeforces 1041D Glider","slug":"CF1041D","date":"2018-09-16T13:28:26.000Z","updated":"2018-09-16T13:32:48.000Z","comments":true,"path":"posts/CF1041D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1041D/","excerpt":"","text":"题面在这里 ​ 显然蓝色部分可以缩成一条竖线，权值为区间长度 那么就相当于做一个长度为\\(h\\)的滑动窗口 ​ 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=200005;int n,h,a[maxn],w[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;h); int s=0; for (int i=1;i&lt;=n;i++)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); l-=s;r-=s; s+=r-l; a[i]=l;w[i]=r-l; &#125; int ans=0;s=0; for (int i=1,j=1;i&lt;=n;i++)&#123; while (j&lt;=n&amp;&amp;a[j]&lt;a[i]+h) s+=w[j++]; ans=max(ans,s); s-=w[i]; &#125; printf(\"%d\",ans+h); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces Round#509 (Div. 2)","slug":"CF_round509_div2","date":"2018-09-16T13:18:41.000Z","updated":"2018-09-17T12:50:38.000Z","comments":true,"path":"posts/CF_round509_div2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF_round509_div2/","excerpt":"","text":"比赛传送门 ​ A. Heist 排个序直接得到结果 1234567891011121314#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005;int n,a[maxn],ans;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); for (int i=1;i&lt;n;i++) ans+=a[i+1]-a[i]-1; printf(\"%d\",ans); return 0;&#125; B. Buying a TV Set \\(Min\\{\\lfloor \\frac a x \\rfloor,\\lfloor \\frac b y \\rfloor \\}\\) 注意\\(x,y\\)不互质的情况 12345678910111213#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;ll gcd(ll x,ll y) &#123;return y==0?x:gcd(y,x%y);&#125;int main()&#123; ll a,b,x,y; scanf(\"%lld%lld%lld%lld\",&amp;a,&amp;b,&amp;x,&amp;y); ll t=gcd(x,y);x/=t;y/=t; printf(\"%lld\",min(a/x,b/y)); return 0;&#125; C. Coffee Break 贪心，能往时间线上排就放上去 multiset真好用 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005;int n,m,d,a[maxn],when[maxn];struct data&#123; int x,id; data () &#123;&#125; data (int _x,int _id):x(_x),id(_id) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x;&#125;&#125;;multiset&lt;data&gt; S;typedef multiset&lt;data&gt;::iterator iter;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;d); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),S.insert(data(a[i],i)); int ans=0; while (S.size())&#123; int nxt=1;ans++; while (1)&#123; iter it=S.lower_bound(data(nxt,0)); if (it==S.end()) break;; when[(*it).id]=ans; nxt=(*it).x+d+1;S.erase(it); &#125; &#125; printf(\"%d\\n\",ans); for (int i=1;i&lt;=n;i++) printf(\"%d \",when[i]); return 0;&#125; D. Glider 看这里 E. Tree Reconstruction 看这里 F. Ray in the tube 看这里","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ2923 [Poi1998]The lightest language","slug":"BZOJ2923","date":"2018-09-16T06:15:18.000Z","updated":"2018-09-16T06:32:22.000Z","comments":true,"path":"posts/BZOJ2923/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2923/","excerpt":"","text":"题面在这里 ​ 想象一棵Trie树，就是要选n个权值最小的点，使得任意两点不存在祖先关系 然后维护每个叶子节点，往下扩展即可 实际操作时不用真的维护每个叶子结点，取其前n小的即可 得不到更优解时停止 ​ 示例程序： 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10005;int n,K,w[30],sum,ans;multiset&lt;int&gt; S;typedef set&lt;int&gt;::iterator iter;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1;i&lt;=K;i++) scanf(\"%d\",&amp;w[i]),S.insert(w[i]),sum+=w[i]; ans=0x7fffffff; while (1)&#123; if (S.size()&gt;=n)&#123; if (sum&gt;=ans) break;else ans=sum; &#125; int x=*S.begin();S.erase(S.begin());sum-=x; for (int i=1;i&lt;=K;i++) S.insert(x+w[i]),sum+=x+w[i]; while (S.size()&gt;n) sum-=*(--S.end()),S.erase(--S.end()); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"乱搞","slug":"乱搞","permalink":"http://oi.linkfqy.top/tags/乱搞/"}]},{"title":"Codeforces 799F Beautiful fountains rows","slug":"CF799F","date":"2018-09-15T14:26:01.000Z","updated":"2018-09-15T14:52:32.000Z","comments":true,"path":"posts/CF799F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF799F/","excerpt":"","text":"题面在这里 题意：有一\\(N\\times M\\)的01矩阵，第i行的\\([l_i,r_i]\\)为1，区间\\([L,R]\\)是合法的当且仅当每一行在\\([L,R]\\)中出现奇数次，求所有合法区间的长度和 ​ 首先考虑\\([L,R]\\)合法，每一行都需要出现奇数次 这个看起来可以用异或乱搞 给每行赋一个随机权值，看作许多在一维空间分布的带权线段 通过差分可以得到以下数组： \\(a[i]\\)：所有在i位置出现过奇数次的线段异或和 \\(s[i]\\)：\\(a[i]\\)的前缀异或和 \\(A[i]\\)：左端点为i的线段异或和 \\(d[i]\\)：\\(A[i]\\)的前缀异或和（左端点小于等于i的线段异或和） 对于区间\\([L,R]\\)，如果\\(s[R]\\text{^}s[L-1]=S\\)，其中S表示区间中出现过的线段异或和，就可以认为是合法的 \\(d[R]\\text{^}d[L]\\)表示\\(l_i \\in (L,R]\\)的线段异或和 那么\\(d[R]\\text{^}d[L]\\)比S少了\\(l_i\\le R,r_i\\ge L\\)的线段，其实少了\\(a[L]\\) 那么\\(S=d[R]\\text{^}d[L-1]\\text{^}a[L]=s[R]\\text{^}s[L-1]\\) 移相整理得\\(s[L]\\text{^}d[L]=s[R]\\text{^}d[R]\\) 用MAP搞之 ​ 注意这样统计其实会把没有线段的区间判定为合法 最后减去空区间即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;#define c(x) ((x)*((x)+1)/2)const int maxn=200005;int n,m;ull a[maxn],A[maxn],s[maxn],d[maxn],ans;map&lt;ull,ull&gt; num,sum;int main()&#123; srand(998244353); scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); ull w=(ull)rand()*rand()*rand()+(ull)rand()*rand()+rand(); a[x]^=w;a[y+1]^=w; A[x]^=w; &#125; for (int i=1;i&lt;=m;i++) a[i]^=a[i-1],s[i]=s[i-1]^a[i],d[i]=d[i-1]^A[i]; for (int i=1;i&lt;=m;i++)&#123; ull w=s[i]^d[i]; num[w]++;sum[w]+=i-1; ans+=num[w]*i-sum[w]; &#125; for (int i=1,j=0;i&lt;=m;i++) if (a[i]==0) ans-=c((ull)i-j); else j=i; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"差分","slug":"差分","permalink":"http://oi.linkfqy.top/tags/差分/"},{"name":"随机","slug":"随机","permalink":"http://oi.linkfqy.top/tags/随机/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ2228 [Zjoi2011]礼物(gift)","slug":"BZOJ2228","date":"2018-09-15T05:16:01.000Z","updated":"2018-09-15T05:19:52.000Z","comments":true,"path":"posts/BZOJ2228/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2228/","excerpt":"","text":"题面在这里 ​ 对于每个平面求每个位置的最大正方形 然后就相当于给一个序列，求区间最小值乘区间长度的最大值 单调栈即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=155;int p,q,r,ans,f[maxn][maxn][maxn],que[maxn],L[maxn],R[maxn];char s[maxn][maxn][maxn],t[maxn][maxn][maxn];void doit(int *a)&#123; int til=0; for (int i=1;i&lt;=r;i++)&#123; while (til&amp;&amp;a[que[til]]&gt;=a[i]) til--; if (!til) L[i]=1;else L[i]=que[til]+1; que[++til]=i; &#125; for (int i=r;i&gt;=1;i--)&#123; while (til&amp;&amp;a[que[til]]&gt;=a[i]) til--; if (!til) R[i]=r;else R[i]=que[til]-1; que[++til]=i; &#125; for (int i=1;i&lt;=r;i++) ans=max(ans,a[i]*(R[i]-L[i]+1));&#125;void work()&#123; for (int k=1;k&lt;=r;k++) for (int i=1;i&lt;=p;i++) for (int j=1;j&lt;=q;j++) if (s[i][j][k]=='N') f[i][j][k]=min(f[i-1][j-1][k],min(f[i][j-1][k],f[i-1][j][k]))+1; else f[i][j][k]=0; for (int i=1;i&lt;=p;i++) for (int j=1;j&lt;=q;j++) doit(f[i][j]);&#125;int main()&#123; scanf(\"%d%d%d\",&amp;q,&amp;p,&amp;r); for (int i=1;i&lt;=p;i++) for (int j=1;j&lt;=q;j++) scanf(\"%s\",s[i][j]+1); for (int z=1;z&lt;=3;z++)&#123; work(); for (int i=1;i&lt;=p;i++) for (int j=1;j&lt;=q;j++) for (int k=1;k&lt;=r;k++) t[j][k][i]=s[i][j][k]; int tt=p;p=q;q=r;r=tt; for (int i=1;i&lt;=p;i++) for (int j=1;j&lt;=q;j++) for (int k=1;k&lt;=r;k++) s[i][j][k]=t[i][j][k]; &#125; printf(\"%d\",ans*4); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调栈","slug":"单调栈","permalink":"http://oi.linkfqy.top/tags/单调栈/"}]},{"title":"BZOJ1345 [Baltic2007]序列问题Sequence","slug":"BZOJ1345","date":"2018-09-13T12:41:05.000Z","updated":"2018-09-13T12:42:56.000Z","comments":true,"path":"posts/BZOJ1345/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1345/","excerpt":"","text":"题面在这里 ​ 水*2…… ​ 示例程序： 123456789101112131415161718#include&lt;cstdio&gt;typedef long long ll;const int maxn=1000005;int n,stk[maxn];int main()&#123; scanf(\"%d\",&amp;n); int til=0; ll ans=0; for (int i=1;i&lt;=n;i++)&#123; int x; scanf(\"%d\",&amp;x); while (til&gt;=2&amp;&amp;stk[til-1]&lt;x) ans+=stk[til-1],til--; if (til&amp;&amp;stk[til]&lt;x) ans+=x,til--; stk[++til]=x; &#125; while (til&gt;=2) ans+=stk[til-1],til--; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调栈","slug":"单调栈","permalink":"http://oi.linkfqy.top/tags/单调栈/"}]},{"title":"BZOJ1113 [Poi2008]海报PLA","slug":"BZOJ1113","date":"2018-09-13T12:16:55.000Z","updated":"2018-09-13T12:20:54.000Z","comments":true,"path":"posts/BZOJ1113/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1113/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;const int maxn=250005;int n,stk[maxn];int main()&#123; scanf(\"%d\",&amp;n); int ans=0; for (int i=1;i&lt;=n;i++)&#123; int x,y; scanf(\"%d%d\",&amp;x,&amp;y); while (stk[0]&amp;&amp;stk[stk[0]]&gt;=y)&#123; if (stk[stk[0]]==y) ans++; stk[0]--; &#125; stk[++stk[0]]=y; &#125; printf(\"%d\",n-ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调栈","slug":"单调栈","permalink":"http://oi.linkfqy.top/tags/单调栈/"}]},{"title":"【二分图判定+树上差分】BZOJ4424 Cf19E Fairy","slug":"BZOJ4424","date":"2018-09-13T11:26:16.000Z","updated":"2018-09-13T11:37:58.000Z","comments":true,"path":"posts/BZOJ4424/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4424/","excerpt":"","text":"题面在这里 ​ 一个无向图是二分图的充要条件是：没有奇环 然后就可以判定：一条边只有存在于所有奇环中，且不在任何偶环内，就可以只删除这条边 一条边在几条奇环内可以由DFS树+树上差分维护 然后这题还有重边和自环，自环需要看做奇环，但是不能加入图中 自环和奇环的存在合法性需要大力讨论一波 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=1000005,maxe=2000005;int n,e,tag[maxn],dep[maxn],ans[maxe];int son[maxe],nxt[maxe],lnk[maxn],tot,id[maxe];bool vis[maxn];inline void add(int x,int y,int ID)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;id[tot]=ID;&#125;int ji,zi,nji,nzi;void dfs(int x,int pre)&#123; vis[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (id[j]!=pre) if (!vis[son[j]]) dep[son[j]]=dep[x]+1,dfs(son[j],id[j]),tag[x]+=tag[son[j]]; else if (dep[son[j]]&lt;dep[x]) if ((dep[x]-dep[son[j]]+1)&amp;1) tag[x]++,tag[son[j]]--,nji++,ji=id[j];else tag[x]--,tag[son[j]]++;&#125;void getans(int x,int pre)&#123; vis[x]=1; if (tag[x]==nji) ans[++ans[0]]=pre; for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]) getans(son[j],id[j]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); if (x==y) nzi++,zi=i; else add(x,y,i),add(y,x,i); &#125; for (int i=1;i&lt;=n;i++) if (!vis[i]) dep[i]=1,dfs(i,0); if (nji==0) if (nzi) if (nzi==1) return printf(\"1\\n%d\",zi),0; else return puts(\"0\"),0; else&#123; printf(\"%d\\n\",e); for (int i=1;i&lt;=e;i++) printf(\"%d \",i); return 0; &#125; if (nzi) return puts(\"0\"),0; if (nji==1) ans[++ans[0]]=ji; cl(vis,0); for (int i=1;i&lt;=n;i++) if (!vis[i]) getans(i,0); sort(ans+1,ans+1+ans[0]); printf(\"%d\\n\",ans[0]); for (int i=1;i&lt;=ans[0];i++) printf(\"%d \",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"二分图","slug":"二分图","permalink":"http://oi.linkfqy.top/tags/二分图/"},{"name":"差分","slug":"差分","permalink":"http://oi.linkfqy.top/tags/差分/"}]},{"title":"hihoCoder1461 Rikka with Number","slug":"hihoCoder1461","date":"2018-09-12T12:07:59.000Z","updated":"2018-09-12T12:16:50.000Z","comments":true,"path":"posts/hihoCoder1461/","link":"","permalink":"http://oi.linkfqy.top/posts/hihoCoder1461/","excerpt":"","text":"题面在这里 ​ 这个过程的逆过程是辗转相减 那么只需要随机一个\\(m\\in [1,n]\\)，使得n,m互质切步数不超过60即可 操作次数可以求gcd时算 ​ 示例程序： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;int tst,a,b,tot,stk[10000];#define brand() ((long long)rand()*rand())inline int gcd(int x,int y) &#123;return y==0?x:(tot+=x/y,gcd(y,x%y));&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;a); int MIN=999,t; for (int i=1;i&lt;=1000&amp;&amp;MIN&gt;60;i++)&#123; tot=0; if (gcd(a,t=brand()%(a-1)+1)==1) if (MIN&gt;tot) MIN=tot,b=t; &#125; stk[0]=0; while (a+b!=1) if (a&gt;b) a-=b,stk[++stk[0]]=0; else b-=a,stk[++stk[0]]=1; if (a==0&amp;&amp;b==1) while (stk[0]) printf(\"%d\",stk[stk[0]--]); else while (stk[0]) printf(\"%d\",1-stk[stk[0]--]); printf(\"\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"随机","slug":"随机","permalink":"http://oi.linkfqy.top/tags/随机/"},{"name":"hihoCoder","slug":"hihoCoder","permalink":"http://oi.linkfqy.top/tags/hihoCoder/"}]},{"title":"BZOJ4524 [Cqoi2016]伪光滑数","slug":"BZOJ4524","date":"2018-09-11T12:56:23.000Z","updated":"2018-09-11T13:22:08.000Z","comments":true,"path":"posts/BZOJ4524/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4524/","excerpt":"","text":"题面在这里 ​ 观察发现\\(K\\)比较小，可以依次求出前\\(K\\)大的N-伪光滑数 显然可以由\\(已经存在的数/最大质因数*较小质数\\)得到新的伪光滑数 记录四元组\\((x,p,t,pre)\\)分别表示当前数是x，最大质因数是p，次数t，能乘的最大质数 这样扩展，随着t减小，pre是递减的，做到了不重不漏 初始当然是对每个小于128的质数都放入1次,2次,3次…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=130;ll n,k;struct data&#123; ll x;int p,t,pre; data () &#123;&#125; data (ll _x,int _p,int _t,int _pre):x(_x),t(_t),pre(_pre),p(_p) &#123;&#125; inline bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x;&#125;&#125;;priority_queue&lt;data&gt; Q;int p[maxn]; bool vis[maxn];void makep(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1; if (i%p[j]==0) break; &#125; &#125;&#125;int main()&#123; scanf(\"%lld%lld\",&amp;n,&amp;k);k--; makep(128); for (int i=1;i&lt;=p[0];i++)&#123; int t=1;ll x=p[i]; while (x&lt;=n) Q.push(data(x,p[i],t,i-1)),x*=p[i],t++; &#125; while (k--)&#123; data m=Q.top();Q.pop(); if (m.t==1) continue; for (int i=1;i&lt;=m.pre;i++) Q.push(data(m.x/m.p*p[i],m.p,m.t-1,i)); &#125; printf(\"%lld\",Q.top().x); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"堆","slug":"堆","permalink":"http://oi.linkfqy.top/tags/堆/"}]},{"title":"【hash+DP】51Nod 1055 最长等差数列","slug":"51Nod1055","date":"2018-09-11T11:46:22.000Z","updated":"2018-09-11T11:58:18.000Z","comments":true,"path":"posts/51Nod1055/","link":"","permalink":"http://oi.linkfqy.top/posts/51Nod1055/","excerpt":"","text":"题面在这里 ​ 因为所求数列只跟给的值有关，先排序再说 定义\\(f_{i,j}\\)表示等差数列最后一项为\\(a_j\\)，倒数第二项为\\(a_i\\) \\(f_{i,j}=f_{k,i}+1\\) 然后这个\\(a_k\\)是可以算出来的，直接用MAP记录每个值最后出现的位置就好了 ​ 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10005;int n,a[maxn];short f[maxn][maxn];map&lt;int,int&gt; M;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); int ans=2; for (int i=1;i&lt;=n;i++)&#123; int tem=0; for (int j=i+1;j&lt;=n;j++) if (2*a[i]-a[j]&gt;0&amp;&amp;(tem=M[2*a[i]-a[j]])) f[i][j]=f[tem][i]+1,ans=max(ans,(int)f[i][j]); else f[i][j]=2; M[a[i]]=i; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"51Nod","slug":"51Nod","permalink":"http://oi.linkfqy.top/tags/51Nod/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"BZOJ4236 JOIOJI","slug":"BZOJ4236","date":"2018-09-11T10:50:58.000Z","updated":"2018-09-11T10:54:16.000Z","comments":true,"path":"posts/BZOJ4236/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4236/","excerpt":"","text":"题面在这里 ​ 直接MAPXJB乱搞 ​ 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=200005;int n;char s[maxn];struct data&#123; int x,y,z; data () &#123;&#125; data (int _x,int _y,int _z):x(_x),y(_y),z(_z) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y||x==b.x&amp;&amp;y==b.y&amp;&amp;z&lt;b.z;&#125;&#125;;map&lt;data,int&gt; M;int main()&#123; scanf(\"%d%s\",&amp;n,s+1); int ans=0; data t(0,0,0),tt; M[t]=0; for (int i=1;i&lt;=n;i++)&#123; if (s[i]=='J') t.x++;else if (s[i]=='O') t.y++;else t.z++; tt=data(0,t.y-t.x,t.z-t.x); if (M.find(tt)==M.end()) M[tt]=i;else ans=max(ans,i-M[tt]); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"}]},{"title":"【LCT+树状数组】HDU5333 Undirected Graph","slug":"HDU5333","date":"2018-09-10T22:57:13.000Z","updated":"2018-09-11T03:38:04.000Z","comments":true,"path":"posts/HDU5333/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU5333/","excerpt":"","text":"题面在这里 题意：给一个无向图，q次询问所有\\(u,v\\in [L_i,R_i]\\)的边构成的子图中有多少个联通块 ​ 方便起见，边\\((u,v)\\)满足\\(u\\le v\\) 首先可以离线处理所有询问，这样就只用考虑\\(u\\ge L_i\\)的边了 如果两条边对答案的贡献相同，可以只保留\\(u\\)较大的 对于询问的联通性，只要两条边在同一环上，对答案的贡献就是完全等价的 这样把\\(u\\)看做边权，只需维护最大生成树即可，LCT经典应用 那么答案就是n-LCT中大于等于Li的边数，树状数组维护之 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxe=200005,maxs=300005;int n,e,q,ans[maxn];struct edge&#123; int x,y,id; bool operator&lt;(const edge&amp;b)const &#123;return y&lt;b.y;&#125;&#125;a[maxe],Q[maxn];int s[maxs][2],fa[maxs],w[maxs],mn[maxs],ID[maxs];bool flp[maxs];#define isroot(x) (s[fa[x]][0]!=x&amp;&amp;s[fa[x]][1]!=x)inline void addflip(int x) &#123;swap(s[x][0],s[x][1]);flp[x]^=1;&#125;inline void pushup(int x)&#123; ID[x]=x;mn[x]=w[x]; if (mn[s[x][0]]&lt;mn[x]) ID[x]=ID[s[x][0]],mn[x]=mn[s[x][0]]; if (mn[s[x][1]]&lt;mn[x]) ID[x]=ID[s[x][1]],mn[x]=mn[s[x][1]];&#125;inline void pushdown(int x) &#123;if (flp[x]) flp[x]=0,addflip(s[x][0]),addflip(s[x][1]);&#125;inline void rotate(int x)&#123; int f=fa[x],g=fa[f],d=s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; s[x][d]=f; fa[f]=x; pushup(f); pushup(x);&#125;int top,stk[maxs];inline void splay(int x)&#123; stk[top=1]=x; for (int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x))&#123; int f=fa[x],g=fa[f],d=s[f][0]==x,dd=s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x);else rotate(x),rotate(x);else rotate(x); &#125;&#125;inline void access(int x) &#123;for (int t=0;x;t=x,x=fa[x]) splay(x),s[x][1]=t,pushup(x);&#125;inline void mr(int x) &#123;access(x);splay(x);addflip(x);&#125;inline void link(int x,int y) &#123;mr(x);fa[x]=y;&#125;inline void cut(int x,int y) &#123;mr(x);access(y);splay(y);s[y][0]=fa[x]=0;&#125;inline int getrt(int x) &#123;access(x);splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125;int BIT[maxn];#define lowbit(x) ((x)&amp;-(x))void ist(int x,int w)&#123; for (int i=x;i&lt;=n;i+=lowbit(i)) BIT[i]+=w;&#125;int qry(int x)&#123; int res=0; for (int i=x;i;i-=lowbit(i)) res+=BIT[i]; return res;&#125;void add(const edge&amp;E)&#123; if (getrt(E.x)==getrt(E.y))&#123; mr(E.x);access(E.y);splay(E.y); int id=ID[E.y]; if (w[id]&gt;=E.x) return; cut(id,a[id-n].x);cut(id,a[id-n].y); ist(a[id-n].x,-1); &#125; int id=E.id+n; mn[id]=w[id]=E.x;ID[id]=id; link(id,E.x);link(id,E.y); ist(E.x,1);&#125;int main()&#123; while (~scanf(\"%d%d%d\",&amp;n,&amp;e,&amp;q))&#123; cl(fa,0);cl(s,0);cl(BIT,0);cl(flp,0); for (int i=1;i&lt;=e;i++)&#123; scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y); if (a[i].x&gt;a[i].y) swap(a[i].x,a[i].y); &#125; for (int i=1;i&lt;=q;i++) scanf(\"%d%d\",&amp;Q[i].x,&amp;Q[i].y),Q[i].id=i; sort(a+1,a+1+e);sort(Q+1,Q+1+q); for (int i=1;i&lt;=e;i++) a[i].id=i; cl(w,63);cl(mn,63); for (int i=1,j=1;i&lt;=q;i++)&#123; while (j&lt;=e&amp;&amp;a[j].y&lt;=Q[i].y) add(a[j++]); ans[Q[i].id]=n-(qry(n)-qry(Q[i].x-1)); &#125; for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"},{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"},{"name":"离线","slug":"离线","permalink":"http://oi.linkfqy.top/tags/离线/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ4817 [Sdoi2017]树点涂色","slug":"BZOJ4817","date":"2018-09-10T11:35:32.000Z","updated":"2018-09-10T11:51:22.000Z","comments":true,"path":"posts/BZOJ4817/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4817/","excerpt":"","text":"题面在这里 ​ 如果把同一个\\(\\text{Splay}\\)里的点看成同颜色，那么\\(\\text{Access}\\)操作就对应了操作1 维护每个点到根路径上的颜色数\\(val\\) 因为所有颜色都是连续出现的，对于询问2，答案是\\(val(x)+val(y)-2val(lca)+1\\) 考虑\\(\\text{Access}\\)过程中，每一条被断开的\\(\\text{Preferred Edge}\\)对应的子树\\(val\\)都+1，每一条新连的\\(\\text{Preferred Edge}\\)对应子树\\(val\\)都-1 用线段树维护权值即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005,maxs=400005;int n,q;int tot,son[maxe],lnk[maxn],nxt[maxe];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int H_son[maxn],siz[maxn],f[maxn],dep[maxn],in[maxn],out[maxn],times,top[maxn],id[maxn];void getdep(int x)&#123; dep[x]=dep[f[x]]+1;siz[x]=1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=f[x])&#123; f[son[j]]=x; getdep(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int pre)&#123; in[x]=++times;top[x]=pre;id[times]=x; if (H_son[x]) dfs(H_son[x],pre); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=f[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;int LCA(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=f[top[x]]; &#125; if (dep[x]&gt;dep[y]) swap(x,y); return x;&#125;int mx[maxs],ad[maxs];inline void pushup(int x) &#123;mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]);&#125;inline void addad(int x,int w) &#123;mx[x]+=w;ad[x]+=w;&#125;inline void pd(int x) &#123;if (ad[x]) addad(x&lt;&lt;1,ad[x]),addad(x&lt;&lt;1|1,ad[x]),ad[x]=0;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mx[x]=dep[id[l]];return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addad(x,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pd(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pd(x); return max(qry(x&lt;&lt;1,l,mid,ql,qr),qry(x&lt;&lt;1|1,mid+1,r,ql,qr));&#125;int s[maxn][2],fa[maxn];bool flp[maxn];#define isroot(x) (s[fa[x]][0]!=x&amp;&amp;s[fa[x]][1]!=x)inline void addflip(int x) &#123;swap(s[x][0],s[x][1]);flp[x]^=1;&#125;inline void pushdown(int x) &#123;if (flp[x]) addflip(s[x][0]),addflip(s[x][1]),flp[x]=0;&#125;inline void rotate(int x)&#123; int f=fa[x],g=fa[f],d=s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; s[x][d]=f; fa[f]=x;&#125;int stk[maxn];inline void splay(int x)&#123; stk[stk[0]=1]=x; for (int i=x;!isroot(i);i=fa[i]) stk[++stk[0]]=fa[i]; while (stk[0]) pushdown(stk[stk[0]--]); while (!isroot(x))&#123; int f=fa[x],g=fa[f],d=s[f][0]==x,dd=s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x);else rotate(x),rotate(x);else rotate(x); &#125;&#125;inline void work(int x,int w)&#123; if (!x) return; while (s[x][0]) x=s[x][0]; ist(1,1,n,in[x],out[x],w);&#125;inline void access(int x)&#123; for (int t=0;x;t=x,x=fa[x])&#123;splay(x);work(s[x][1],1);work(t,-1);s[x][1]=t;&#125;&#125;#define val(x) qry(1,1,n,in[x],in[x])int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); f[1]=1;getdep(1);dfs(1,1); build(1,1,n); for (int i=2;i&lt;=n;i++) fa[i]=f[i]; while (q--)&#123; int c,x,y;scanf(\"%d%d\",&amp;c,&amp;x); if (c==1) access(x);else if (c==2)&#123; scanf(\"%d\",&amp;y); printf(\"%d\\n\",val(x)+val(y)-2*val(LCA(x,y))+1); &#125;else printf(\"%d\\n\",qry(1,1,n,in[x],out[x])); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"},{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"}]},{"title":"BZOJ3874 [Ahoi2014&Jsoi2014]宅男计划","slug":"BZOJ3874","date":"2018-09-08T12:17:03.000Z","updated":"2018-09-08T12:27:48.000Z","comments":true,"path":"posts/BZOJ3874/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3874/","excerpt":"","text":"题面在这里 ​ 首先发现有一些食物是没用的（贵一些，保质期反而短），去掉 这样剩下都是\\(s\\)随\\(p\\)递增的 同时考虑到每次叫外卖是独立的过程，那么每次点的食物应该是一样的 如果知道叫k次外卖，显然能取便宜食物就取，贪心得到最多天数 然后这个天数应该是关于k的一个单峰函数，三分即可 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=205;int n,N; ll m,f;struct data&#123; ll s,p; inline bool operator&lt;(const data&amp;b)const &#123;return s&lt;b.s;&#125;&#125;a[maxn],b[maxn];ll calc(ll k)&#123; ll M=m-k*f,res=0,day=0,t; for (int i=1;i&lt;=n;i++)&#123; if (a[i].s&gt;=day) t=min(a[i].s-day+1,M/a[i].p/k),day+=t,res+=t*k,M-=t*k*a[i].p; if (a[i].s&gt;=day) t=M/a[i].p,day++,res+=t,M-=t*a[i].p; &#125; return res;&#125;int main()&#123; scanf(\"%lld%lld%d\",&amp;m,&amp;f,&amp;N); for (int i=1;i&lt;=N;i++) scanf(\"%lld%lld\",&amp;b[i].p,&amp;b[i].s); for (int i=1;i&lt;=N;i++)&#123; bool suc=1; for (int j=1;j&lt;=N;j++) if (b[i].p&gt;b[j].p&amp;&amp;b[i].s&lt;b[j].s) &#123;suc=0;break;&#125; if (suc) a[++n]=b[i]; &#125; sort(a+1,a+1+n); ll l=1,r=m/f,ans=0; while (l&lt;=r)&#123; ll mid1=l+(r-l)/3,mid2=r-(r-l)/3,c1=calc(mid1),c2=calc(mid2); ans=max(ans,max(c1,c2)); if (c1&lt;c2) l=mid1+1;else r=mid2-1; &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"三分","slug":"三分","permalink":"http://oi.linkfqy.top/tags/三分/"}]},{"title":"BZOJ4423 [AMPPZ2013]Bytehattan","slug":"BZOJ4423","date":"2018-09-08T02:50:28.000Z","updated":"2018-09-08T02:54:06.000Z","comments":true,"path":"posts/BZOJ4423/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4423/","excerpt":"","text":"题面在这里 ​ 由于只询问删除边的两个端点是否联通 其实就是问是否构成了环形割 建对偶图，删边=连边，用并查集判环 ​ 示例程序： 12345678910111213141516171819202122#include&lt;cstdio&gt;const int maxn=1505,maxs=maxn*maxn;int n,N,q,fa[maxs];inline int id(int x,int y) &#123;return (x-1)*(n-1)+y;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); N=(n-1)*(n-1); for (int i=0;i&lt;=N;i++) fa[i]=i; int t=0; while (q--)&#123; char s[2][5];int x[2],y[2],xx,yy; scanf(\"%d%d%s%d%d%s\",&amp;x[0],&amp;y[0],s[0],&amp;x[1],&amp;y[1],s[1]); if (s[t][0]=='N') xx=x[t]-1,yy=y[t];else xx=x[t],yy=y[t]-1; int idx,idy; if (xx&lt;1||yy&lt;1) idx=0;else idx=id(xx,yy); if (x[t]&gt;=n||y[t]&gt;=n) idy=0;else idy=id(x[t],y[t]); t=(getfa(idx)==getfa(idy));fa[getfa(idx)]=getfa(idy); puts(t?\"NIE\":\"TAK\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"}]},{"title":"BZOJ4243 交朋友","slug":"BZOJ4243","date":"2018-09-07T13:28:17.000Z","updated":"2018-09-07T13:33:00.000Z","comments":true,"path":"posts/BZOJ4243/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4243/","excerpt":"","text":"题面在这里 ​ 发现所有由双向边连接的联通块都能构成一个完全子图 那么先把原图中能开的会议都开了 此时，任意一个联通块中的点的出边都可以合并至该联通块 BFS即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;const int maxn=100005,maxe=200005;int n,e,fa[maxn],siz[maxn],f[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;inline bool fd(int x,int y) &#123;for (int j=lnk[x];j;j=nxt[j]) if (son[j]==y) return 1;return 0;&#125;int que[maxn];bool vis[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),f[x]++; for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (fd(son[j],i)) fa[getfa(i)]=getfa(son[j]); for (int i=1;i&lt;=n;i++)&#123; int lst=-1; for (int j=lnk[i];j;lst=son[j],j=nxt[j]) if (lst&gt;0) fa[getfa(lst)]=getfa(son[j]); &#125; for (int i=1;i&lt;=n;i++) siz[getfa(i)]++; int hed=0,til=0; for (int i=1;i&lt;=n;i++) if (siz[getfa(i)]&gt;1) que[++til]=i,vis[i]=1; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j])&#123; fa[getfa(son[j])]=getfa(x); if (!vis[son[j]]) vis[que[++til]=son[j]]=1; &#125; &#125; cl(siz,0);for (int i=1;i&lt;=n;i++) siz[getfa(i)]++; ll ans=0; for (int i=1;i&lt;=n;i++) if (getfa(i)==i) ans+=siz[i]&gt;1?(ll)siz[i]*(siz[i]-1):f[i]; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"BFS","slug":"BFS","permalink":"http://oi.linkfqy.top/tags/BFS/"}]},{"title":"BZOJ1483 [HNOI2009]梦幻布丁","slug":"BZOJ1483","date":"2018-09-06T13:47:56.000Z","updated":"2018-09-06T13:50:22.000Z","comments":true,"path":"posts/BZOJ1483/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1483/","excerpt":"","text":"题面在这里 ​ 对每个颜色用vector搞出所有位置 修改颜色就是启发式合并，同时修正答案 ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1000005;int n,q,a[maxn],f[maxn],ans;vector&lt;int&gt; V[maxn];void merge(int x,int y)&#123; if (V[f[x]].size()&gt;V[f[y]].size()) swap(f[x],f[y]); int fx=f[x],fy=f[y]; if (fx==fy) return; for (int i=0;i&lt;V[fx].size();i++) ans-=(a[V[fx][i]+1]==fy)+(a[V[fx][i]-1]==fy); for (int i=0;i&lt;V[fx].size();i++) a[V[fx][i]]=fy,V[fy].push_back(V[fx][i]); V[fx].clear();&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=1e6;i++) f[i]=i; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),ans+=(a[i]!=a[i-1]),V[a[i]].push_back(i); while (q--)&#123; int x,y;scanf(\"%d\",&amp;x); if (x==1) scanf(\"%d%d\",&amp;x,&amp;y),merge(x,y);else printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"启发式合并","slug":"启发式合并","permalink":"http://oi.linkfqy.top/tags/启发式合并/"}]},{"title":"BZOJ1124 [POI2008]枪战Maf","slug":"BZOJ1124","date":"2018-09-06T12:33:23.000Z","updated":"2018-09-06T12:40:56.000Z","comments":true,"path":"posts/BZOJ1124/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1124/","excerpt":"","text":"题面在这里 ​ 考虑最大值，对于每个联通块： 单点：死1人 环：死\\(size-1\\)人 基环内向树：死\\(size-leaf\\)人 ​ 考虑最小值，首先叶子结点不会死 那么叶子结点瞄准的目标一定会死，先打死再说 这时如果导致有新的叶子产生，就又加入队列 最后剩下的每个环，死亡人数为\\(\\lceil \\frac{size}2 \\rceil\\) ​ 示例程序： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;const int maxn=1000005;int n,to[maxn],f[maxn],fa[maxn],s[maxn],sum[maxn],MAX,MIN,que[maxn];bool vis[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;to[i]),fa[i]=i,f[to[i]]++; for (int i=1;i&lt;=n;i++) fa[getfa(to[i])]=getfa(i); for (int i=1;i&lt;=n;i++) s[getfa(i)]+=(f[i]==0),sum[getfa(i)]++; for (int i=1;i&lt;=n;i++) if (getfa(i)==i)&#123; if (sum[i]==1) MAX++;else if (s[i]==0) MAX+=sum[i]-1;else MAX+=sum[i]-s[i]; &#125; int hed=0,til=0; for (int i=1;i&lt;=n;i++) if (!f[i]) que[++til]=i,vis[i]=1; while (hed!=til)&#123; int x=que[++hed]; if (!vis[to[x]]) vis[to[x]]=1,MIN++,f[to[to[x]]]--; if (!vis[to[to[x]]]&amp;&amp;!f[to[to[x]]]) que[++til]=to[to[x]],vis[to[to[x]]]=1; &#125; for (int i=1;i&lt;=n;i++) fa[i]=i,s[i]=0; for (int i=1;i&lt;=n;i++) if (!vis[i]&amp;&amp;!vis[to[i]]) fa[getfa(to[i])]=getfa(i); for (int i=1;i&lt;=n;i++) if (!vis[i]) s[getfa(i)]++; for (int i=1;i&lt;=n;i++) if (getfa(i)==i) MIN+=s[i]+1&gt;&gt;1; printf(\"%d %d\",MIN,MAX); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"}]},{"title":"BZOJ4551 [Tjoi2016&Heoi2016]树","slug":"BZOJ4551","date":"2018-09-05T10:32:13.000Z","updated":"2018-09-05T10:35:12.000Z","comments":true,"path":"posts/BZOJ4551/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4551/","excerpt":"","text":"题面在这里 ​ 离线倒着做，用并查集维护最近的标记祖先 每次删除一个标记就把它与祖先相连 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;const int maxn=100005,maxe=200005;int n,q,ans[maxn],tag[maxn],f[maxn],fa[maxn];int tot,lnk[maxn],nxt[maxe],son[maxe];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct data&#123; char ty;int x;&#125;Q[maxn]; char s[25];void dfs(int x)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=f[x]) f[son[j]]=x,dfs(son[j]);&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); for (int i=1;i&lt;=q;i++)&#123; scanf(\"%s%d\",s,&amp;Q[i].x); Q[i].ty=s[0]; if (Q[i].ty=='C') tag[Q[i].x]++; &#125; f[1]=1;dfs(1); for (int i=1;i&lt;=n;i++) if (tag[i]) fa[i]=i;else fa[i]=f[i]; for (int i=q;i&gt;=1;i--) if (Q[i].ty=='Q') ans[i]=getfa(Q[i].x);else&#123; tag[Q[i].x]--; if (!tag[Q[i].x]) fa[Q[i].x]=f[Q[i].x]; &#125; for (int i=1;i&lt;=q;i++) if (Q[i].ty=='Q') printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"离线","slug":"离线","permalink":"http://oi.linkfqy.top/tags/离线/"}]},{"title":"BZOJ1800 [Ahoi2009]fly 飞行棋","slug":"BZOJ1800","date":"2018-09-04T11:49:48.000Z","updated":"2018-09-04T11:51:26.000Z","comments":true,"path":"posts/BZOJ1800/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1800/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920#include&lt;cstdio&gt;const int maxn=25;int n,S,a[maxn];int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++)&#123; int x;scanf(\"%d\",&amp;x); a[i]=a[i-1]+x;S+=x; &#125; int ans=0; for (int i=1;i&lt;=n;i++) for (int j=i+1;j&lt;=n;j++) for (int ii=1;ii&lt;=n;ii++) for (int jj=ii+1;jj&lt;=n;jj++) if (i!=ii&amp;&amp;i!=jj&amp;&amp;j!=ii&amp;&amp;j!=jj) if ((a[j]-a[i])*2==S&amp;&amp;(a[jj]-a[ii])*2==S) ans++; printf(\"%d\",ans/2); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ1110 [POI2007]砝码Odw","slug":"BZOJ1110","date":"2018-09-04T11:09:42.000Z","updated":"2018-09-04T11:21:32.000Z","comments":true,"path":"posts/BZOJ1110/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1110/","excerpt":"","text":"题面在这里 ​ 首先把所有容器都拆成砝码进制，相加 然后肯定是能放小砝码就放小砝码 如果当前位没有了，就拿更高位补 ​ 示例程序： 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,m,M,a[maxn],b[maxn],c[maxn],num[maxn];bool calc(int x)&#123; for (int i=x+1;i&lt;=M;i++) if (num[i]) return num[x]+=c[i]/c[x],num[i]--,1; return 0;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=m;i++) scanf(\"%d\",&amp;b[i]); sort(b+1,b+1+m); for (int i=1;i&lt;=m;i++) if (b[i]!=b[i-1]) c[++M]=b[i]; for (int i=1;i&lt;=n;i++)&#123; int x=a[i]; for (int j=M;j&gt;=1;j--) num[j]+=x/c[j],x%=c[j]; &#125; for (int i=1,j=1;i&lt;=m;i++)&#123; while (b[i]&gt;c[j]) j++; if (num[j]) num[j]--;else if (calc(j)) num[j]--;else return printf(\"%d\",i-1),0; &#125; printf(\"%d\",m); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"}]},{"title":"BZOJ1301 [LLH邀请赛]参观路线","slug":"BZOJ1301","date":"2018-09-04T08:51:38.000Z","updated":"2018-09-04T08:53:08.000Z","comments":true,"path":"posts/BZOJ1301/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1301/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 1234567891011121314151617181920212223242526#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,e,lst[maxn],nxt[maxn];vector&lt;int&gt; V[maxn];void dfs(int x)&#123; printf(\"%d\\n\",x); int l=lst[x],r=nxt[x]; nxt[l]=r;lst[r]=l; for (int i=nxt[0];i&lt;=n;i=nxt[i])&#123; vector&lt;int&gt;::iterator it=lower_bound(V[x].begin(),V[x].end(),i); if (it==V[x].end()||*it!=i) return (void)dfs(i); &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),V[x].push_back(y),V[y].push_back(x); for (int i=1;i&lt;=n;i++) sort(V[i].begin(),V[i].end()),lst[i]=i-1,nxt[i]=i+1; nxt[n+1]=n+1;lst[0]=0; dfs(1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"链表","slug":"链表","permalink":"http://oi.linkfqy.top/tags/链表/"}]},{"title":"【线段树动态开点】NOIP2017 列队","slug":"NOIP2017_D2T3","date":"2018-08-29T11:18:08.000Z","updated":"2018-08-29T11:35:08.000Z","comments":true,"path":"posts/NOIP2017_D2T3/","link":"","permalink":"http://oi.linkfqy.top/posts/NOIP2017_D2T3/","excerpt":"","text":"题面自取 ​ 由于对齐的操作很难实现，可以把离队的人的位置空出来 因为操作次数是有限的，直接把加入的人放在末尾 用线段树维护区间内被删除的位置个数，询问就是找第y个没被删除的位置 这样每行开一个线段树，最后一列也开一个线段树，动态开点。 要注意不断操作后序列是乱的，如果询问得到的位置小于m，可以直接计算出这个位置的编号 否则大于m的部分用vector记录每个位置编号 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=300005,maxs=12000005;int n,m,q,M;int s[maxs],ls[maxs],rs[maxs],Rot[maxn],len;inline void pushup(int x) &#123;s[x]=s[ls[x]]+s[rs[x]];&#125;void ist(int &amp;x,int l,int r,int k)&#123; if (!x) x=++len; if (l==r) return (void)(s[x]=1,x); int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k);else ist(rs[x],mid+1,r,k); pushup(x);&#125;int qry(int x,int l,int r,int k)&#123; if (l==r) return l; int mid=l+r&gt;&gt;1,tem=mid-l+1 - s[ls[x]]; if (k&lt;=tem) return qry(ls[x],l,mid,k);else return qry(rs[x],mid+1,r,k-tem);&#125;vector&lt;ll&gt; V[maxn];ll work0(int x,ll w)&#123; int p=qry(Rot[0],1,M,x); ist(Rot[0],1,M,p); ll res=(p&lt;=n)?(ll)p*m:V[0][p-n-1]; V[0].push_back(w?w:res); return res;&#125;ll work1(int x,int y)&#123; int p=qry(Rot[x],1,M,y); ist(Rot[x],1,M,p); ll res=(p&lt;m)?((ll)x-1)*m+p:V[x][p-m]; V[x].push_back(work0(x,res)); return res;&#125;int main()&#123; n=red(),m=red();q=red();M=max(n,m)+q; while (q--)&#123; int x=red(),y=red(); printf(\"%lld\\n\",y==m?work0(x,0):work1(x,y)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"BZOJ2743 [HEOI2012]采花","slug":"BZOJ2743","date":"2018-08-28T08:29:57.000Z","updated":"2018-08-28T08:36:28.000Z","comments":true,"path":"posts/BZOJ2743/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2743/","excerpt":"","text":"题面在这里 ​ 可以离线搞…… 这里有个小技巧就是考虑每个点对答案的贡献： 令\\(nxt[i]\\)表示i位置的颜色下一次出现在哪里 那么i对所有左端点小于等于i且右端点属于\\([nxt[i],nxt[nxt[i]-1]]\\)的询问有贡献 把所有询问按照左端点排序，用树状数组差分维护贡献即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005;int n,c,q,BIT[maxn],a[maxn],nxt[maxn],cc[maxn],ans[maxn];struct data&#123; int X,Y,id; bool operator&lt;(const data&amp;b)const &#123;return X&lt;b.X;&#125;&#125;Q[maxn];#define lowbit(x) ((x)&amp;-(x))inline void ist(int x,int w)&#123; for (int i=x;i&lt;=n;i+=lowbit(i)) BIT[i]+=w;&#125;inline int qry(int x)&#123; int res=0; for (int i=x;i&gt;=1;i-=lowbit(i)) res+=BIT[i]; return res;&#125;int main()&#123; n=red(),c=red(),q=red(); for (int i=1;i&lt;=c;i++) cc[i]=n+1;nxt[n+1]=n+1; for (int i=1;i&lt;=n;i++) a[i]=red(); for (int i=n;i;i--) nxt[i]=cc[a[i]],cc[a[i]]=i; for (int i=1;i&lt;=q;i++) Q[i].X=red(),Q[i].Y=red(),Q[i].id=i; sort(Q+1,Q+1+q); for (int i=1;i&lt;=n;i++) ist(nxt[i],1),ist(nxt[nxt[i]],-1); for (int i=1,l=1;i&lt;=q;i++)&#123; while (l&lt;Q[i].X) ist(nxt[l],-1),ist(nxt[nxt[l]],1),l++; ans[Q[i].id]=qry(Q[i].Y); &#125; for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"BZOJ3931 [CQOI2015]网络吞吐量","slug":"BZOJ3931","date":"2018-08-28T06:41:40.000Z","updated":"2018-08-28T06:43:38.000Z","comments":true,"path":"posts/BZOJ3931/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3931/","excerpt":"","text":"题面在这里 ​ 显然只有可能在最短路上的边才会走 具体就是满足三角不等式取等的边，用这些边刷最大流即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=1005,maxe=500005,INF=0x3f3f3f3f;int n,e,S,T;int tot,son[maxe],nxt[maxe],pos[maxn],lnk[maxn],flw[maxe],cap[maxe];inline void add(int x,int y,int z)&#123; //printf(\"%d %d %d\\n\",x,y,z); son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=z; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int cst[maxn][maxn]; ll dst[maxn];bool vis[maxn];void DIJ()&#123; cl(dst,63); dst[1]=0; for (int i=1;i&lt;=n;i++)&#123; int k;ll MIN=INF; for (int j=1;j&lt;=n;j++) if (!vis[j]&amp;&amp;dst[j]&lt;MIN) MIN=dst[k=j]; vis[k]=1; for (int j=1;j&lt;=n;j++) dst[j]=min(dst[j],dst[k]+cst[k][j]); &#125;&#125;int d[maxn],que[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; d[S]=0;que[1]=S; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==INF&amp;&amp;flw[j]&lt;cap[j]) que[++til]=son[j],d[son[j]]=d[x]+1; &#125; return d[T]!=INF;&#125;ll dfs(int x,ll flow)&#123; if (x==T||flow==0) return flow; ll res=0,f; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,(ll)cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f; flw[j^1]-=f; res+=f; flow-=f; &#125; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); S=1+n,T=n; cl(cst,63); for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),cst[x][y]=cst[y][x]=min(cst[x][y],z); DIJ(); tot=1; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (dst[i]+cst[i][j]==dst[j]) add(i+n,j,INF); for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),add(i,i+n,x),add(i+n,i,x); ll ans=0; while (bfs())&#123; memcpy(pos,lnk,sizeof(lnk)); ans+=dfs(S,1e18); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"Codeforces Round#493 (Div. 2)","slug":"CF_round493_div2","date":"2018-08-28T03:24:43.000Z","updated":"2018-08-28T03:55:28.000Z","comments":true,"path":"posts/CF_round493_div2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF_round493_div2/","excerpt":"","text":"比赛传送门 ​ A. Balloons 暴搜即可 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=15;int sum,n,a[maxn],ans[maxn],suc;void dfs(int stp,int s)&#123; if (suc) return; if (stp&gt;n)&#123; if (s!=0&amp;&amp;sum-s!=0&amp;&amp;s!=sum-s)&#123; suc=1; printf(\"%d\\n\",ans[0]); for (int i=1;i&lt;=ans[0];i++) printf(\"%d \",ans[i]); &#125; return; &#125; dfs(stp+1,s); ans[++ans[0]]=stp; dfs(stp+1,s+a[stp]); ans[0]--;&#125;int main()&#123; scanf(\"%d\",&amp;n); if (n==1) return puts(\"-1\"),0; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),sum+=a[i]; dfs(1,0); if (!suc) puts(\"-1\"); return 0;&#125; B. Cutting 记录奇数和偶数出现的次数，显然只有相等时才可以切割 然后贪心取代价小的切割即可 12345678910111213141516171819202122#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105,maxv=105;int n,N,V,a[maxn],w[maxn],f[maxn];inline int Abs(int x) &#123;return x&gt;0?x:-x;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;V); int s=0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d\",&amp;a[i]); if (i!=1&amp;&amp;s==0) w[++N]=Abs(a[i]-a[i-1]); if (a[i]&amp;1) s++;else s--; &#125; sort(w+1,w+1+N); int ans=0; for (int i=1;i&lt;=N;i++) if (w[i]&lt;=V) V-=w[i],ans++; printf(\"%d\",ans); return 0;&#125; C. Convert to Ones 设连续0的段数为\\(cnt\\)，则用\\(cnt-1\\)次操作就可以把所有0放到一起 答案为\\(\\max \\{ cnt\\cdot y,(cnt-1)x+y \\}\\) 123456789101112131415#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;char s[300005];int main()&#123; int n,x,y;ll cnt=0; scanf(\"%d%d%d%s\",&amp;n,&amp;x,&amp;y,s+1); s[0]='1'; for (int i=1;i&lt;=n;i++) cnt+=(s[i-1]=='1'&amp;&amp;s[i]=='0'); if (cnt==0) return puts(\"0\"),0; printf(\"%lld\",min(cnt*y,(cnt-1)*x+y)); return 0;&#125; D. Roman Digits 看这里 E. Sky Full of Stars 看这里","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 998D Roman Digits","slug":"CF998D","date":"2018-08-28T03:18:57.000Z","updated":"2018-08-28T03:24:12.000Z","comments":true,"path":"posts/CF998D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF998D/","excerpt":"","text":"题面在这里 题意：四种罗马数字\\(\\text{I,V,X,L}\\)，填在n个位置上，问加和有多少钟不同取值 ​ zz题……先暴搜找到规律：11项以后是公差为49的等差数列 打表即可 ​ 示例程序： 12345678910111213#include &lt;cstdio&gt;typedef long long ll;using namespace std;const int a[12]=&#123;0,4,10,20,35,56,83,116,155,198,244,292&#125;;int n;ll ans;int main()&#123; scanf(\"%d\",&amp;n); if (n&lt;=11) ans=a[n]; else ans=a[11]+((ll)n-11)*49; printf(\"%lld\", ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【容斥计数】Codeforces 998E Sky Full of Stars","slug":"CF998E","date":"2018-08-28T02:40:27.000Z","updated":"2018-08-28T03:18:52.000Z","comments":true,"path":"posts/CF998E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF998E/","excerpt":"","text":"题面在这里 题意：用3种颜色涂满\\(n\\times n\\)的矩阵，求至少一行或一列颜色相同的方案数 ​ 先考虑至少一列同色，方案为\\(3^{n^2}-(3^n-3)^n\\) 再加上至少一行同色，这里有些方案是重复的，这些方案只可能是所有同色行的颜色相同（如果不同就不会有同色列了） 用容斥处理，枚举有\\(i\\)个同色行，则： 所有同色行颜色相同：那么每一列都不能是这种颜色的同色列，\\(3 {n\\choose i}(3^{n-i}-1)^n\\) 其他：不会有同色列产生，答案是\\({n \\choose i}(3^i-3)3^{n(n-i)}\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;typedef long long ll;const int maxn=1000005,MOD=998244353;int n; ll fac[maxn],inv[maxn];inline ll ksm(ll a,ll b)&#123; ll res=1,w=a; while (b)&#123; if (b&amp;1) (res*=w)%=MOD; (w*=w)%=MOD; b&gt;&gt;=1; &#125; return res;&#125;inline ll C(ll x,ll y)&#123; return fac[x]*inv[y]%MOD*inv[x-y]%MOD;&#125;int main()&#123; scanf(\"%d\",&amp;n); fac[0]=1;for (int i=1;i&lt;=n;i++) fac[i]=(fac[i-1]*i)%MOD; inv[n]=ksm(fac[n],MOD-2);for (int i=n;i;i--) inv[i-1]=(inv[i]*i)%MOD; ll ans=(ksm(3,(ll)n*n)-ksm(ksm(3,n)-3,n))%MOD; for (int i=1;i&lt;=n;i++)&#123; ll del=3*C(n,i)%MOD*ksm(ksm(3,n-i)-1,n)%MOD+C(n,i)*(ksm(3,i)-3)%MOD*ksm(3,(ll)n*(n-i))%MOD;del%=MOD; if (i&amp;1) (ans+=del)%=MOD;else (ans-=del)%=MOD; &#125; printf(\"%lld\",(ans+MOD)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"容斥","slug":"容斥","permalink":"http://oi.linkfqy.top/tags/容斥/"},{"name":"计数题","slug":"计数题","permalink":"http://oi.linkfqy.top/tags/计数题/"}]},{"title":"BZOJ1969 [Ahoi2005]LANE 航线规划","slug":"BZOJ1969","date":"2018-08-27T02:01:02.000Z","updated":"2018-08-27T02:07:26.000Z","comments":true,"path":"posts/BZOJ1969/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1969/","excerpt":"","text":"题面在这里 ​ 直接离线倒序加边，一开始一定有一棵树 不断加入非树边构成双联通分量 答案就是两点之间不在环上的边的条数 用树链剖分维护边的情况即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=30005,maxe=100005,maxs=120005;int n,e,q,fa[maxn],ans[maxe];bool dmg[maxe];struct edge&#123; int x,y; edge () &#123;&#125; edge (int _x,int _y):x(_x),y(_y) &#123;&#125; bool operator&lt;(const edge&amp;b)const &#123;return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y;&#125;&#125;a[maxe];struct ask&#123; int x,y,c;&#125;Q[maxe];int son[maxe],lnk[maxn],nxt[maxe],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int dep[maxn],siz[maxn],Hson[maxn],top[maxn],dfn[maxn],times;void getdep(int x)&#123; siz[x]=1;dep[x]=dep[fa[x]]+1;Hson[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x; getdep(son[j]); siz[x]+=siz[son[j]]; if (!Hson[x]||siz[Hson[x]]&lt;siz[son[j]]) Hson[x]=son[j]; &#125; &#125;void dfs(int x,int lst)&#123; top[x]=lst;dfn[x]=++times; if (Hson[x]) dfs(Hson[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=Hson[x]&amp;&amp;son[j]!=fa[x]) dfs(son[j],son[j]);&#125;int s[maxs],cv[maxs];inline void pushup(int x) &#123;s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1];&#125;inline void addcv(int x,int l,int r) &#123;s[x]=r-l+1,cv[x]=1;&#125;inline void pushdown(int x,int l,int r,int mid)&#123;if (cv[x]) addcv(x&lt;&lt;1,l,mid),addcv(x&lt;&lt;1|1,mid+1,r),cv[x]=0;&#125;void ist(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return addcv(x,l,r); if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x,l,r,mid); ist(x&lt;&lt;1,l,mid,ql,qr); ist(x&lt;&lt;1|1,mid+1,r,ql,qr); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return s[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x,l,r,mid); return qry(x&lt;&lt;1,l,mid,ql,qr)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;void insert(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); ist(1,1,n,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if (dfn[x]&gt;dfn[y]) swap(x,y); ist(1,1,n,dfn[x]+1,dfn[y]);&#125;int query(int x,int y)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=dfn[x]-dfn[top[x]]+1-qry(1,1,n,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if (dfn[x]&gt;dfn[y]) swap(x,y); return res+dfn[y]-dfn[x]-qry(1,1,n,dfn[x]+1,dfn[y]);&#125;int main()&#123; n=red(),e=red(); for (int i=1;i&lt;=e;i++)&#123; a[i].x=red(),a[i].y=red(); if (a[i].x&gt;a[i].y) swap(a[i].x,a[i].y); &#125; sort(a+1,a+1+e); for (int c=red();c!=-1;c=red())&#123; q++;Q[q].x=red(),Q[q].y=red(),Q[q].c=c; if (Q[q].x&gt;Q[q].y) swap(Q[q].x,Q[q].y); if (c==0) dmg[lower_bound(a+1,a+1+e,edge(Q[q].x,Q[q].y))-a]=1; &#125; for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++) if (!dmg[i]&amp;&amp;getfa(a[i].x)!=getfa(a[i].y))&#123; fa[getfa(a[i].x)]=getfa(a[i].y); add(a[i].x,a[i].y); add(a[i].y,a[i].x); dmg[i]=1; &#125; fa[1]=1;getdep(1);dfs(1,1); for (int i=1;i&lt;=e;i++) if (!dmg[i]) insert(a[i].x,a[i].y); for (int i=q;i&gt;=1;i--) if (Q[i].c) ans[i]=query(Q[i].x,Q[i].y);else insert(Q[i].x,Q[i].y); for (int i=1;i&lt;=q;i++) if (Q[i].c) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"【乱搞】BZOJ3578 GTY的人类基因组计划2","slug":"BZOJ3578","date":"2018-08-26T13:47:05.000Z","updated":"2018-08-26T13:50:32.000Z","comments":true,"path":"posts/BZOJ3578/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3578/","excerpt":"","text":"题面在这里 ​ 给每个人赋一个随机编号，一个集合的hash值就是xor和 用map记录哪些集合被统计过，set维护可能产生答案的房间 询问时暴力删除即可，因为集合数是\\(O(q)\\)的 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstdlib&gt;#include&lt;map&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int N,n,q,w[maxn],a[maxn],where[maxn],num[maxn];#define brand() ((rand()&lt;&lt;16)|(rand()&lt;&lt;1)|(rand()&amp;1))map&lt;int,bool&gt; usd;set&lt;int&gt; S;char s[20];int main()&#123; srand(998244353); scanf(\"%d%d%d\",&amp;N,&amp;n,&amp;q); for (int i=1;i&lt;=N;i++) w[i]=brand(),a[where[i]=1]^=w[i]; S.insert(1);num[1]=N; while (q--)&#123; scanf(\"%s\",s); if (s[0]=='C')&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); S.erase(where[x]);S.erase(y); a[where[x]]^=w[x]; a[y]^=w[x]; if (!usd[a[where[x]]]) S.insert(where[x]); if (!usd[a[y]]) S.insert(y); num[where[x]]--;num[y]++; where[x]=y; &#125;else&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); set&lt;int&gt;::iterator it=S.lower_bound(l); int res=0; while (it!=S.end()&amp;&amp;(*it)&lt;=r)&#123; res+=num[*it]; usd[a[*it]]=1; S.erase(it); it=S.lower_bound(l); &#125; printf(\"%d\\n\",res); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"}]},{"title":"【贪心+并查集缩点】Codeforces 1023F Mobile Phone Network","slug":"CF1023F","date":"2018-08-26T01:52:33.000Z","updated":"2018-08-26T02:06:18.000Z","comments":true,"path":"posts/CF1023F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1023F/","excerpt":"","text":"题面在这里 题意：给n个点，K条待定边权的特殊边（不构成环），m条有边权边，要使最小生成树包含所有K条边，问K条边边权和最大是多少 ​ 因为要包含所有K条边，所以先把K条边加入最小生成树，剩下\\(\\text{kruskal}\\)得到一棵完整的树 考虑每一条非树边，一定是环上的最大值，则这个环上的特殊边边权必须小于等于这个值 其实就是对树上路径取min，可以用LCT\\(O(nlogn)\\)或者树链剖分+线段树\\(O(nlog^2n)\\)维护 但是这根本没有必要，直接按边权把所有非树边排序，第一次被覆盖的权值就是特殊边的最终权值 用并查集暴力缩点即可，因为每个点最多被缩一次，复杂度\\(O(n\\alpha(n))\\) ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxe=1000005;int n,K,e,fa[maxn],f[maxn],g[maxn],dep[maxn];bool usd[maxn];struct edge&#123; int x,y,w; inline bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;void dfs(int x)&#123; dep[x]=dep[f[x]]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=f[x]) f[son[j]]=x,g[son[j]]=w[j],dfs(son[j]);&#125;int main()&#123; n=red(),K=red(),e=red(); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1,x,y;i&lt;=K;i++) x=red(),y=red(),add(x,y,-1),add(y,x,-1), fa[getfa(x)]=getfa(y); for (int i=1;i&lt;=e;i++) a[i].x=red(),a[i].y=red(),a[i].w=red(); sort(a+1,a+1+e); for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y))&#123; fa[getfa(a[i].x)]=getfa(a[i].y); add(a[i].x,a[i].y,a[i].w),add(a[i].y,a[i].x,a[i].w); usd[i]=1; &#125; f[1]=1;dfs(1); for (int i=1;i&lt;=n;i++) fa[i]=i; ll ans=0; for (int i=1;i&lt;=e;i++) if (!usd[i])&#123; int x=getfa(a[i].x),y=getfa(a[i].y),w=a[i].w; while (x!=y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); if (g[x]&lt;0) ans+=w,g[x]=w; fa[x]=getfa(f[x]); x=getfa(x); &#125; &#125; for (int i=2;i&lt;=n;i++) if (g[i]&lt;0) return puts(\"-1\"),0; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ2081 [Poi2010]Beads","slug":"BZOJ2081","date":"2018-08-25T13:33:18.000Z","updated":"2018-08-25T13:34:22.000Z","comments":true,"path":"posts/BZOJ2081/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2081/","excerpt":"","text":"题面在这里 ​ 水博客*3 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int maxn=200005,tt=19260817;int n,a[maxn],ans[maxn]; ull hsh[2][maxn],pw[maxn];inline ull get(int d,int l,int r)&#123; return hsh[d][r]-hsh[d][l-1]*pw[r-l+1];&#125;set&lt;ull&gt; S;int calc(int k)&#123; S.clear(); int res=0; for (int i=k;i&lt;=n;i+=k)&#123; ull t1=get(0,i-k+1,i),t2=get(1,n-i+1,n-i+k); if (S.count(t1)||S.count(t2)) continue; res++; S.insert(t1); &#125; return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); pw[0]=1; for (int i=1;i&lt;=n;i++) hsh[0][i]=hsh[0][i-1]*tt+a[i],pw[i]=pw[i-1]*tt, hsh[1][i]=hsh[1][i-1]*tt+a[n-i+1]; int MAX=0; for (int k=1;k&lt;=n;k++)&#123; int t=calc(k); if (MAX&lt;t) MAX=t,ans[ans[0]=1]=k;else if (MAX==t) ans[++ans[0]]=k; &#125; printf(\"%d %d\\n\",MAX,ans[0]); for (int i=1;i&lt;=ans[0];i++) printf(\"%d \",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"}]},{"title":"BZOJ1102 [POI2007]山峰和山谷Grz","slug":"BZOJ1102","date":"2018-08-25T12:55:49.000Z","updated":"2018-08-25T12:56:40.000Z","comments":true,"path":"posts/BZOJ1102/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1102/","excerpt":"","text":"题面在这里 ​ 水博客*2 ​ 12345678910111213141516171819202122232425262728293031323334#include&lt;cctype&gt;#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005,t1[8]=&#123;1,0,-1,0,1,1,-1,-1&#125;,t2[8]=&#123;0,1,0,-1,1,-1,1,-1&#125;;int n,ans1,ans2,w[maxn][maxn],f[maxn][maxn],q[maxn*maxn][2];void bfs(int sx,int sy)&#123; int l=0,r=1,f1=1,f2=1; q[1][0]=sx,q[1][1]=sy,f[sx][sy]=true; while (l&lt;r)&#123; int xx=q[++l][0],yy=q[l][1]; for (int i=0;i&lt;8;i++)&#123; int x=xx+t1[i],y=yy+t2[i]; if (x&amp;&amp;x&lt;=n&amp;&amp;y&amp;&amp;y&lt;=n) if (w[xx][yy]&gt;w[x][y]) f1=0; else if (w[xx][yy]==w[x][y]&amp;&amp;!f[x][y])&#123; q[++r][0]=x,q[r][1]=y,f[x][y]=true; &#125; else if (w[xx][yy]&lt;w[x][y]) f2=0; &#125; &#125; if (!f1&amp;&amp;f2) ans1++; if (f1&amp;&amp;!f2) ans2++;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) scanf(\"%d\",&amp;w[i][j]); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) if (!f[i][j]) bfs(i,j); if (!ans1&amp;&amp;!ans2) ans1=ans2=1; return printf(\"%d %d\\n\",ans1,ans2),0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ3916 [Baltic2014]friends","slug":"BZOJ3916","date":"2018-08-25T12:47:38.000Z","updated":"2018-08-25T12:48:26.000Z","comments":true,"path":"posts/BZOJ3916/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3916/","excerpt":"","text":"题面在这里 ​ 水博客…… ​ 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;typedef unsigned long long ull;const int maxn=2000005;int n,N; ull hsh[maxn],pw[maxn];char s[maxn];inline ull geth(int l,int r)&#123; return hsh[r]-hsh[l-1]*pw[r-l+1];&#125;int main()&#123; scanf(\"%d%s\",&amp;N,s+1); if (N%2==0) return puts(\"NOT POSSIBLE\"),0; n=N&gt;&gt;1;pw[0]=1; for (int i=1;i&lt;=N;i++) hsh[i]=hsh[i-1]*31+s[i]-'A'+1,pw[i]=pw[i-1]*31; int cnt=0,ans=0; ull ss=0; for (int i=1;i&lt;=N;i++)&#123; ull L,R; if (i==n+1) L=geth(1,i-1),R=geth(i+1,N);else if (i&lt;n+1) L=geth(1,i-1)*pw[n+1-i]+geth(i+1,n+1),R=geth(n+2,N);else if (i&gt;n+1) L=geth(1,n),R=geth(n+1,i-1)*pw[N-i]+geth(i+1,N); if (L==R) if (ss!=L) cnt++,ans=i,ss=L; &#125; if (!cnt) return puts(\"NOT POSSIBLE\"),0; if (cnt&gt;1) return puts(\"NOT UNIQUE\"),0; for (int i=1,c=0;i&lt;=N&amp;&amp;c&lt;n;i++)&#123; if (ans!=i) putchar(s[i]),c++; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"}]},{"title":"Codeforces Round#495 (Div. 2)","slug":"CF_round495_div2","date":"2018-08-24T11:39:23.000Z","updated":"2018-08-24T12:06:26.000Z","comments":true,"path":"posts/CF_round495_div2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF_round495_div2/","excerpt":"","text":"比赛传送门 ​ A. Sonya and Hotels 枚举每两个相邻位置，计算对答案的贡献即可 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=105;int n,d,a[maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;d); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); int ans=2; for (int i=2;i&lt;=n;i++) if (a[i]-a[i-1]==2*d) ans++;else if (a[i]-a[i-1]&gt;2*d) ans+=2; printf(\"%d\",ans); return 0;&#125; B. Sonya and Exhibition 一开始想了好久，后来发现直接010101……就好了 1234567#include&lt;cstdio&gt;int main()&#123; int n;scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) putchar('0'+(i&amp;1)); return 0;&#125; C. Sonya and Robots 枚举第一个机器人走的位置，看第二个机器人有多少个合法位置 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=200005;int n,a[maxn],N;bool vis[maxn];struct data&#123; int x,ty; data (int _x=0,int _ty=0):x(_x),ty(_ty) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return x&lt;b.x;&#125;&#125;b[maxn];int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1;i&lt;=n;i++) if (!vis[a[i]]) b[++N]=data(i,0),vis[a[i]]=1; cl(vis,0); int m=0; for (int i=n;i&gt;=1;i--) if (!vis[a[i]]) m++,b[++N]=data(i,1),vis[a[i]]=1; sort(b+1,b+1+N); ll ans=0; for (int i=1,j;i&lt;=N;i=j)&#123; int num[2]; num[0]=num[1]=0; for (j=i;j&lt;=N&amp;&amp;b[i].x==b[j].x;j++) num[b[j].ty]++; m-=num[1]; ans+=num[0]*m; &#125; printf(\"%lld\",ans); return 0;&#125; D. Sonya and Matrix 看这里 E. Sonya and Ice Cream 看这里","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【SET求直径】Codeforces 1004E Sonya and Ice Cream","slug":"CF1004E","date":"2018-08-24T11:27:51.000Z","updated":"2018-08-24T11:42:08.000Z","comments":true,"path":"posts/CF1004E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1004E/","excerpt":"","text":"题面在这里 题意：给一棵带边权的树，求一条不超过k个点的链，使得所有点到链的距离的最大值最小 ​ 显然链在直径上，直接求直径，在直径上做滑动窗口即可 …… 然而还有更妙的解法： 考虑每次删除一个叶子结点，最后得到一条链 要使这个最大值最小，每次删除的点对答案的贡献一定要最小 由于对答案贡献一定是递增的，所以贪心的正确性显然 用一个SET维护所有叶子结点，权值是子树中点到父亲的最大距离，即对答案的贡献 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132#include&lt;cstdio&gt; #include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005;int n,K,f[maxn];struct data&#123; int x,w; data () &#123;&#125; data (int _x,int _w):x(_x),w(_w) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return w&lt;b.w||w==b.w&amp;&amp;x&lt;b.x;&#125;&#125;;set&lt;data&gt; d[maxn],S;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1,x,y,z;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z), d[x].insert(data(y,z)),d[y].insert(data(x,z)), f[x]++,f[y]++; for (int i=1;i&lt;=n;i++) if (f[i]==1) S.insert(data(i,(*d[i].begin()).w)); int ans=0; while (n&gt;K||S.size()&gt;2)&#123; int x=(*S.begin()).x,fa=(*d[x].begin()).x,w=(*d[x].begin()).w; ans=(*S.begin()).w; S.erase(S.begin()); n--; f[fa]--; d[fa].erase(d[fa].find(data(x,w))); if (f[fa]==1) S.insert(data(fa,(*d[fa].begin()).w+ans)); &#125; printf(\"%d\",ans); return 0; &#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1004D Sonya and Matrix","slug":"CF1004D","date":"2018-08-24T11:11:23.000Z","updated":"2018-08-24T11:27:24.000Z","comments":true,"path":"posts/CF1004D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1004D/","excerpt":"","text":"题面在这里 题意：有一种矩阵只有一个位置是0，其他位置的值是到0的曼哈顿距离，给\\(t\\)个数字，求能组成的这种矩阵（任意解） ​ 此题粗看很复杂，方便起见，我们规定0距离左上角较近 发现如果矩阵无限大，数字\\(i(i&gt;0)\\)出现的次数为\\(4i\\) 如果第一次发现数字\\(x\\)不满足这个等差数列，一定是触碰了边界，则令0的横坐标为\\(x\\) 考虑出现最大的数字\\(b\\)，满足\\(n-x+m-y=b\\)（x,y是0的坐标） \\(b\\)是已知的，由\\(b\\)得到\\(y=n-x+m-b\\) 此时只有\\(n\\)和\\(m\\)未知，枚举\\(t\\)的因子即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005;int t,num[maxn],cnt[maxn],x,y,n,m,a,b;inline int Abs(int x) &#123;return x&gt;0?x:-x;&#125;int main()&#123; t=red(); for (int i=1;i&lt;=t;i++) num[red()]++; if (num[0]!=1) return puts(\"-1\"),0; for (int i=1;i&lt;=1e6;i++) if (num[i]) b=i; for (int i=1;i&lt;=1e6;i++) if (num[i]!=4*i) &#123;x=i;break;&#125; for (n=1;n&lt;=t;n++) if (t%n==0)&#123; m=t/n; y=n+m-x-b; cl(cnt,0); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) cnt[Abs(i-x)+Abs(j-y)]++; bool suc=1; for (int i=0;i&lt;=n+m;i++) if (cnt[i]!=num[i]) suc=0; if (suc) return printf(\"%d %d\\n%d %d\",n,m,x,y),0; &#125; return puts(\"-1\"),0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces Round#499 (Div. 2)","slug":"CF_round499_div2","date":"2018-08-23T12:10:34.000Z","updated":"2018-08-23T12:17:16.000Z","comments":true,"path":"posts/CF_round499_div2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF_round499_div2/","excerpt":"","text":"比赛传送门 ​ A. Stages 直接贪心尽量取小字母就好了 12345678910111213141516171819#include&lt;cstdio&gt;int n,k,num[30];char s[55];int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;k,s); for (int i=0;i&lt;n;i++) num[s[i]-'a'+1]++; int lst=-1,ans=0; while (k)&#123; int i;bool suc=0; for (i=lst+2;i&lt;=26;i++) if (num[i]) &#123;suc=1;break;&#125; if (!suc) break; ans+=i;lst=i;k--; &#125; if (k) return puts(\"-1\"),0; printf(\"%d\",ans); return 0;&#125; B. Planning The Expedition 二分天数，看总共是否够n个人吃 1234567891011121314151617181920#include&lt;cstdio&gt;const int maxn=105;int n,m,num[maxn];bool check(int day)&#123; int tot=0; for (int i=1;i&lt;=100;i++) tot+=num[i]/day; return tot&gt;=n;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1,x;i&lt;=m;i++) scanf(\"%d\",&amp;x),num[x]++; int l=1,r=10000,ans=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (check(mid)) ans=mid,l=mid+1;else r=mid-1; &#125; printf(\"%d\",ans); return 0;&#125; C. Fly 显然油带得多不会影响飞行，所以二分油量即可 此题卡精度差评…… 123456789101112131415161718192021222324252627282930#include&lt;cstdio&gt;const int maxn=1005;const long double eps=1e-9;int n,m,a[maxn],b[maxn];bool check(long double fuel)&#123; for (int i=2;i&lt;=n+1;i++)&#123; double del=(fuel+m)/a[i-1]; if (del-fuel&gt;=eps) return 0; fuel-=del; del=(fuel+m)/b[i]; if (del-fuel&gt;=eps) return 0; fuel-=del; &#125; return 1;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); long double ans=-1,l=0,r=1e9; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),l+=(double)m/a[i]; for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;b[i]),l+=(double)m/b[i]; a[n+1]=a[1],b[n+1]=b[1]; while (r-l&gt;=eps)&#123; long double mid=(l+r)/2; if (check(mid)) ans=mid,r=mid;else l=mid; &#125; if (ans&lt;0) return puts(\"-1\"),0; printf(\"%.10lf\",(double)ans); return 0;&#125; D. Rocket 看这里 E. Border 看这里 F. Mars rover 看这里","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1011F Mars rover","slug":"CF1011F","date":"2018-08-23T12:01:53.000Z","updated":"2018-08-23T12:09:06.000Z","comments":true,"path":"posts/CF1011F/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1011F/","excerpt":"","text":"题面在这里 题意：一棵有根树，叶子节点是输入值0/1，其他节点是运算符\\(\\text{And Or Xor Not}\\)，分别询问每个叶子的输入值改变后，根的值变成什么 ​ 考虑到一个点的值不变，它到根路径上的值都不变 令\\(f_i\\)表示点i的值变化，根的值是否变化 初始\\(f_1=true\\)然后按照运算类型讨论一波就好了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758#include&lt;cstdio&gt;const int maxn=1000006;int n,son[maxn][2];char s[maxn][5];bool w[maxn],f[maxn];void getw(int x)&#123; if (s[x][0]=='A')&#123; getw(son[x][0]); getw(son[x][1]); w[x]=(w[son[x][0]]&amp;&amp;w[son[x][1]]); &#125;else if (s[x][0]=='O')&#123; getw(son[x][0]); getw(son[x][1]); w[x]=(w[son[x][0]]||w[son[x][1]]); &#125;else if (s[x][0]=='X')&#123; getw(son[x][0]); getw(son[x][1]); w[x]=(w[son[x][0]]^w[son[x][1]]); &#125;else if (s[x][0]=='N')&#123; getw(son[x][0]); w[x]=(!w[son[x][0]]); &#125;&#125;void dp(int x)&#123; if (!f[x]) return; if (s[x][0]=='A')&#123; if (w[son[x][0]]) f[son[x][1]]=1; if (w[son[x][1]]) f[son[x][0]]=1; dp(son[x][0]); dp(son[x][1]); &#125;else if (s[x][0]=='O')&#123; if (!w[son[x][0]]) f[son[x][1]]=1; if (!w[son[x][1]]) f[son[x][0]]=1; dp(son[x][0]); dp(son[x][1]); &#125;else if (s[x][0]=='X')&#123; f[son[x][1]]=1;f[son[x][0]]=1; dp(son[x][0]); dp(son[x][1]); &#125;else if (s[x][0]=='N')&#123; f[son[x][0]]=1; dp(son[x][0]); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x;i&lt;=n;i++)&#123; scanf(\"%s\",s[i]); if (s[i][0]=='I') scanf(\"%d\",&amp;x),w[i]=(x==1);else if (s[i][0]=='N') scanf(\"%d\",&amp;son[i][0]);else scanf(\"%d%d\",&amp;son[i][0],&amp;son[i][1]); &#125; getw(1); f[1]=1; dp(1); for (int i=1;i&lt;=n;i++) if (s[i][0]=='I') putchar((f[i]^w[1])?'1':'0'); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"树形DP","slug":"树形DP","permalink":"http://oi.linkfqy.top/tags/树形DP/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1011E Border","slug":"CF1011E","date":"2018-08-23T08:25:34.000Z","updated":"2018-08-23T08:53:14.000Z","comments":true,"path":"posts/CF1011E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1011E/","excerpt":"","text":"题面在这里 题意：求\\(\\sum\\limits_{i=1}^n a_ix_i\\text{ mod k}\\)的所有取值，\\(x_i\\)为任意自然数 ​ 考虑裴蜀定理的一般形式： \\[ \\sum_{i=1}^n a_ix_i=C\\ 有解，当且仅当\\gcd\\limits_{i=1}^na_i | C \\] 那么令\\(\\gcd\\limits_{i=1}^na_i=G\\)，所有\\(G\\)的倍数就是能取到的值了 ​ 示例程序： 1234567891011121314#include&lt;cstdio&gt;const int maxn=100005;int n,K,a[maxn];inline int gcd(int x,int y) &#123;return y==0?x:gcd(y,x%y);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); int g=K; for (int i=1;i&lt;=n;i++) g=gcd(g,a[i]); printf(\"%d\\n\",K/g); for (int i=0;i&lt;K;i+=g) printf(\"%d \",i); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://oi.linkfqy.top/tags/数学/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1011D Rocket","slug":"CF1011D","date":"2018-08-23T08:22:35.000Z","updated":"2018-08-23T08:24:24.000Z","comments":true,"path":"posts/CF1011D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1011D/","excerpt":"","text":"题面在这里 题意：交互题，猜一个数，会回答偏大偏小正确，但是有一个说谎序列，回答按照说谎序列循环，说谎回答完全相反，不超过60次询问 ​ 考虑到n很小，直接询问n次1，就知道说谎序列了 然后直接二分 ​ 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstdlib&gt;int n,m;bool fake[50];inline int ask(int x)&#123; printf(\"%d\\n\",x);fflush(stdout); scanf(\"%d\",&amp;x);return x;&#125;int main()&#123; scanf(\"%d%d\",&amp;m,&amp;n); for (int i=1;i&lt;=n;i++)&#123; int x=ask(1); if (x==0) return 0; fake[i]=(x&lt;0); &#125; int l=2,r=m,times=0; while (l&lt;=r)&#123; times=times%n+1; int mid=l+r&gt;&gt;1,x=ask(mid); if (fake[times]) x=-x; if (x==0) return 0; if (x&gt;0) l=mid+1;else r=mid-1; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"交互题","slug":"交互题","permalink":"http://oi.linkfqy.top/tags/交互题/"}]},{"title":"BZOJ4500 矩阵","slug":"BZOJ4500","date":"2018-08-22T02:38:51.000Z","updated":"2018-08-22T02:43:38.000Z","comments":true,"path":"posts/BZOJ4500/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4500/","excerpt":"","text":"题面在这里 ​ 考虑每个限制其实是\\(x_i+y_j=c\\)，即： \\[ \\begin{cases} x_i-(-y_j)\\ge c \\\\ x_i-(-y_j)\\le c \\end{cases} \\] SPFA判无解即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=2005,maxe=2005;int tst,n,m,e;int son[maxe],lnk[maxn],nxt[maxe],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int que[maxn],dst[maxn],num[maxn];bool vis[maxn];bool spfa()&#123; cl(vis,0);cl(dst,63);cl(num,0); int hed=0,til=n+m; for (int i=1;i&lt;=n+m;i++) que[i]=i,dst[i]=0,vis[i]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]])&#123; vis[son[j]]=1;que[til=(til+1)%maxn]=son[j]; if (++num[son[j]]&gt;n) return 0; &#125; &#125; &#125; return 1;&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;e); cl(lnk,0);tot=0; for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(y+n,x,z),add(x,y+n,-z); puts(spfa()?\"Yes\":\"No\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"差分约束系统","slug":"差分约束系统","permalink":"http://oi.linkfqy.top/tags/差分约束系统/"}]},{"title":"BZOJ3531 [Sdoi2014]旅行","slug":"BZOJ3531","date":"2018-08-21T13:20:43.000Z","updated":"2018-08-21T13:22:12.000Z","comments":true,"path":"posts/BZOJ3531/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3531/","excerpt":"","text":"题面在这里 ​ 树链剖分+动态开点线段树…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005,maxs=4000005;int n,q,w[maxn],c[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int dep[maxn],siz[maxn],fa[maxn],H_son[maxn],dfn[maxn],top[maxn],times;void getdep(int x)&#123; dep[x]=dep[fa[x]]+1;siz[x]=1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x; getdep(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst; dfn[x]=++times; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]);&#125;int sum[maxs],mx[maxs],ls[maxs],rs[maxs],Rot[maxn],len=1;inline void pushup(int x) &#123;sum[x]=sum[ls[x]]+sum[rs[x]];mx[x]=max(mx[ls[x]],mx[rs[x]]);&#125;#define newnode() (mx[len]=sum[len]=ls[len]=rs[len]=0,len++)void ist(int &amp;x,int l,int r,int k,int w)&#123; if (!x) x=newnode(); if (l==r) return (void)(sum[x]=mx[x]=w); int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k,w);else ist(rs[x],mid+1,r,k,w); pushup(x);&#125;int qrymx(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; return max(qrymx(ls[x],l,mid,ql,qr),qrymx(rs[x],mid+1,r,ql,qr));&#125;int qrys(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return sum[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; return qrys(ls[x],l,mid,ql,qr)+qrys(rs[x],mid+1,r,ql,qr);&#125;int querymx(int x,int y,int c)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=max(res,qrymx(Rot[c],1,n,dfn[top[x]],dfn[x])); x=fa[top[x]]; &#125; if (dfn[x]&gt;dfn[y]) swap(x,y); return max(res,qrymx(Rot[c],1,n,dfn[x],dfn[y]));&#125;int querys(int x,int y,int c)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=qrys(Rot[c],1,n,dfn[top[x]],dfn[x]); x=fa[top[x]]; &#125; if (dfn[x]&gt;dfn[y]) swap(x,y); return res+qrys(Rot[c],1,n,dfn[x],dfn[y]);&#125;char s[20];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;w[i],&amp;c[i]); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); fa[1]=1;getdep(1);dfs(1,1); for (int i=1;i&lt;=n;i++) ist(Rot[c[i]],1,n,dfn[i],w[i]); while (q--)&#123; scanf(\"%s\",s); if (s[1]=='C')&#123; int x,cc;scanf(\"%d%d\",&amp;x,&amp;cc); ist(Rot[c[x]],1,n,dfn[x],0); c[x]=cc; ist(Rot[c[x]],1,n,dfn[x],w[x]); &#125;else if (s[1]=='W')&#123; int x,ww;scanf(\"%d%d\",&amp;x,&amp;ww); ist(Rot[c[x]],1,n,dfn[x],w[x]=ww); &#125;else if (s[1]=='S')&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",querys(x,y,c[x])); &#125;else&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",querymx(x,y,c[x])); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"Codeforces Round#500 (Div. 2) [based on EJOI]","slug":"CF_round500_div2","date":"2018-08-21T06:04:00.000Z","updated":"2018-08-21T10:39:52.000Z","comments":true,"path":"posts/CF_round500_div2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF_round500_div2/","excerpt":"","text":"比赛传送门 ​ A. Piles With Stones 看sum1是否大于sum2即可 123456789101112#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;int n,ans1,ans2;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),ans1+=x; for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),ans2+=x; return puts(ans1&lt;ans2?\"No\":\"Yes\"),0;&#125; B. And 答案只可能是0,1,2,-1 依次判断即可 注意\\(a_i \\&amp; x\\)可能为0，贡献了两发WA…… 123456789101112131415161718#include&lt;cstdio&gt;const int maxn=100005;int n,x,a[maxn],num[2][maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;x); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),num[0][a[i]]++,num[1][a[i]&amp;x]++; for (int i=0;i&lt;=100000;i++) if (num[0][i]&gt;1) return puts(\"0\"),0; for (int i=1;i&lt;=n;i++)&#123; num[0][a[i]]--; if (num[0][a[i]&amp;x]) return puts(\"1\"),0; num[0][a[i]]++; &#125; for (int i=0;i&lt;=100000;i++) if (num[1][i]&gt;1) return puts(\"2\"),0; return puts(\"-1\"),0;&#125; C. Photo of The Sky 考虑把所有数字排序，第一个和最后一个一定是x/y坐标的最大/最小值 如果第一个和最后一个都是x坐标，枚举一段连续的n个作为y坐标即可 如果分属x/y坐标，显然前n个是x坐标，后n个是y坐标 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=200005;int n,N,a[maxn];int main()&#123; scanf(\"%d\",&amp;n);N=2*n; for (int i=1;i&lt;=N;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+N); ll ans=((ll)a[n]-a[1])*(a[N]-a[n+1]); for (int i=2;i&lt;=n;i++) ans=min(ans,((ll)a[N]-a[1])*(a[i+n-1]-a[i])); printf(\"%lld\",ans); return 0;&#125; D. Chemical table 看这里 E. Hills 看这里","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1013E Hills","slug":"CF1013E","date":"2018-08-21T03:33:00.000Z","updated":"2018-08-21T03:33:52.000Z","comments":true,"path":"posts/CF1013E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1013E/","excerpt":"","text":"题面在这里 题意：长度为n的高度序列，房子只能造在比相邻位置高的地方，可以花费1的代价将任意位置高度-1，问造\\(k(k=1\\dots \\lceil \\frac n 2 \\rceil)\\)座房子的最小代价 ​ 定义\\(f_{i,j,0/1}\\)表示前i个位置，造了j个房子，第i个位置有没有造房子 然后就好了 ​ 示例程序： 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=5005;int n,a[maxn],f[maxn][maxn][2];inline int w(int x,int y)&#123; return max(0,x-y);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); cl(f,63); f[0][0][0]=0; for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=i;j++)&#123; f[i][j][0]=min(f[i-1][j][0],f[i-1][j][1]); if (i==1&amp;&amp;j&gt;0) f[i][j][1]=w(a[i+1],a[i]-1); if (i&gt;1&amp;&amp;j&gt;0) f[i][j][1]=min(f[i-2][j-1][0]+w(a[i-1],a[i]-1),f[i-2][j-1][1]+w(min(a[i-2]-1,a[i-1]),a[i]-1))+w(a[i+1],a[i]-1); &#125; for (int i=1;i&lt;=(n+1)/2;i++) printf(\"%d \",min(f[n][i][0],f[n][i][1])); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 1013D Chemical table","slug":"CF1013D","date":"2018-08-21T03:23:00.000Z","updated":"2018-08-21T03:31:30.000Z","comments":true,"path":"posts/CF1013D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1013D/","excerpt":"","text":"题面在这里 题意：\\(n\\times m\\)的矩阵，初始有一些点，任意矩形的三个角有点，第四个角就自动生成点，可以在中途加点，问最终把矩阵填满需要至少加几个点 ​ 很巧妙的转化…… 考虑每个点连接了它所在的行和列 用并查集维护 那么有矩形的三个顶点，就会把两行两列合并到同一个联通块，相当于有第四个顶点 在同一个集合的行和列，他们的交点就有数字 那么最后答案就是联通块个数-1 ​ 示例程序： 12345678910111213141516171819#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=400005;int n,m,q,fa[maxn];int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;q); for (int i=1;i&lt;=n+m;i++) fa[i]=i; for (int i=1;i&lt;=q;i++)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y);y+=n; fa[getfa(x)]=getfa(y); &#125; int ans=-1; for (int i=1;i&lt;=n+m;i++) if (fa[i]==i) ans++; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ2588 Spoj 10628. Count on a tree","slug":"BZOJ2588","date":"2018-08-20T12:43:47.000Z","updated":"2018-08-20T12:45:14.000Z","comments":true,"path":"posts/BZOJ2588/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2588/","excerpt":"","text":"题面在这里 ​ 主席树按照fa建…… x+y-lca-fa(lca)就是答案…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=40005,maxe=80005,maxs=2000005;int n,m,q,w[maxn],b[maxn],f[maxn][18],dep[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int ls[maxs],rs[maxs],s[maxs],len,Rot[maxn];inline void pushup(int x) &#123;s[x]=s[ls[x]]+s[rs[x]];&#125;int build(int l,int r)&#123; int x=++len; ls[x]=rs[x]=s[x]=0; if (l==r) return x; int mid=l+r&gt;&gt;1; ls[x]=build(l,mid); rs[x]=build(mid+1,r); return x;&#125;int ist(int lst,int l,int r,int k)&#123; int x=++len; ls[x]=ls[lst]; rs[x]=rs[lst]; s[x]=s[lst]; if (l==r) return s[x]++,x; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ls[x]=ist(ls[lst],l,mid,k);else rs[x]=ist(rs[lst],mid+1,r,k); pushup(x); return x;&#125;int qry(int a,int b,int c,int d,int l,int r,int k)&#123; if (l==r) return l; int tem=s[ls[a]]+s[ls[b]]-s[ls[c]]-s[ls[d]],mid=l+r&gt;&gt;1; if (k&lt;=tem) return qry(ls[a],ls[b],ls[c],ls[d],l,mid,k); else return qry(rs[a],rs[b],rs[c],rs[d],mid+1,r,k-tem);&#125;void dfs(int x,int fa)&#123; f[x][0]=fa; dep[x]=dep[fa]+1; Rot[x]=ist(Rot[fa],1,m,w[x]); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x);&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=17;~j;j--) if (dep[f[x][j]]&gt;=dep[y]) x=f[x][j]; if (x==y) return x; for (int j=17;~j;j--) if (f[x][j]!=f[y][j]) x=f[x][j],y=f[y][j]; return f[x][0];&#125;int main()&#123; n=red(),q=red(); for (int i=1;i&lt;=n;i++) b[i]=w[i]=red(); sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=1;i&lt;=n;i++) w[i]=lower_bound(b+1,b+1+m,w[i])-b; for (int i=1,x,y;i&lt;n;i++) x=red(),y=red(),add(x,y),add(y,x); Rot[0]=build(1,m);dfs(1,0); for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; int lastans=0; while (q--)&#123; int x=lastans^red(),y=red(),k=red(),lca=LCA(x,y),fl=f[lca][0]; printf(\"%d\\n\",lastans=b[qry(Rot[x],Rot[y],Rot[lca],Rot[fl],1,m,k)]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"主席树","slug":"主席树","permalink":"http://oi.linkfqy.top/tags/主席树/"}]},{"title":"Codeforces 1025D Recovering BST","slug":"CF1025D","date":"2018-08-20T01:24:16.000Z","updated":"2018-08-20T01:30:04.000Z","comments":true,"path":"posts/CF1025D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF1025D/","excerpt":"","text":"题面在这里 题意：给一个序列，问是否能构成这样的二叉搜索树，满足相邻节点gcd大于1 ​ 区间DP…… 考虑一个区间代表一棵子树，那么区间\\([l,r]\\)的父亲一定是\\(l-1\\)或\\(r+1\\) \\(f_{l,r,0/1}\\)表示区间\\([l,r]\\)，这棵树是左子树还是右子树 枚举一个根，转移即可 ​ 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;const int maxn=705;int n,a[maxn],f[maxn][maxn][2];bool cst[maxn][maxn];int gcd(int x,int y) &#123;return !y?x:gcd(y,x%y);&#125;bool dfs(int l,int r,int d)&#123; if (l&gt;r) return 1; if (f[l][r][d]&gt;=0) return f[l][r][d]; int fa=(d?r+1:l-1); for (int i=l;i&lt;=r;i++) if (cst[fa][i]&amp;&amp;dfs(l,i-1,1)&amp;&amp;dfs(i+1,r,0)) return f[l][r][d]=1; return f[l][r][d]=0;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),cst[i][0]=cst[0][i]=1; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) cst[i][j]=(gcd(a[i],a[j])&gt;1); memset(f,-1,sizeof(f)); if (dfs(1,n,0)) puts(\"Yes\");else puts(\"No\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"BZOJ3306 树","slug":"BZOJ3306","date":"2018-08-17T13:28:26.000Z","updated":"2018-08-17T13:29:10.000Z","comments":true,"path":"posts/BZOJ3306/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3306/","excerpt":"","text":"题面在这里 ​ 水…… ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxs=4*maxn,maxe=maxn,INF=0x3f3f3f3f;int n,q,Root,id[maxn],in[maxn],out[maxn],w[maxn],times,dep[maxn],f[maxn][18];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x)&#123; in[x]=++times;id[times]=x; dep[x]=dep[f[x][0]]+1; for (int j=lnk[x];j;j=nxt[j]) f[son[j]][0]=x,dfs(son[j]); out[x]=times;&#125;int mn[maxs];inline void pushup(int x) &#123;mn[x]=min(mn[x&lt;&lt;1],mn[x&lt;&lt;1|1]);&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mn[x]=w[id[l]];return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int k,int w)&#123; if (l==r) &#123;mn[x]=w;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(x&lt;&lt;1,l,mid,k,w);else ist(x&lt;&lt;1|1,mid+1,r,k,w); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mn[x]; if (qr&lt;l||r&lt;ql) return INF; int mid=l+r&gt;&gt;1; return min(qry(x&lt;&lt;1,l,mid,ql,qr),qry(x&lt;&lt;1|1,mid+1,r,ql,qr));&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x;i&lt;=n;i++) scanf(\"%d%d\",&amp;x,&amp;w[i]),add(x,i); f[1][0]=1;dfs(1); Root=1; build(1,1,n); for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; while (q--)&#123; char s[20];scanf(\"%s\",s); if (s[0]=='V')&#123; int x,w;scanf(\"%d%d\",&amp;x,&amp;w); ist(1,1,n,in[x],w); &#125;else if (s[0]=='E') scanf(\"%d\",&amp;Root);else&#123; int x,res;scanf(\"%d\",&amp;x); if (x==Root) res=mn[1];else if (in[x]&lt;=in[Root]&amp;&amp;out[Root]&lt;=out[x])&#123; int v=Root; for (int j=17;~j;j--) if (dep[f[v][j]]&gt;dep[x]) v=f[v][j]; res=min(qry(1,1,n,1,in[v]-1),qry(1,1,n,out[v]+1,n)); &#125;else res=qry(1,1,n,in[x],out[x]); printf(\"%d\\n\",res); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"BZOJ4653 [Noi2016]区间","slug":"BZOJ4653","date":"2018-08-17T12:33:52.000Z","updated":"2018-08-17T12:39:38.000Z","comments":true,"path":"posts/BZOJ4653/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4653/","excerpt":"NOI竟然有如此水题……","text":"NOI竟然有如此水题…… ​ 题面在这里 ​ 直接按代价排序，\\(\\text{two-pointer}\\)走一波存在单点覆盖m条线段 用线段树维护…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxs=8*maxn,INF=0x3f3f3f3f;int n,m,b[maxn*2],N;struct data&#123; int l,r,w; inline bool operator&lt;(const data&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxn];int mx[maxs],ad[maxs];inline void pushup(int x) &#123;mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]);&#125;inline void addad(int x,int w) &#123;mx[x]+=w;ad[x]+=w;&#125;inline void pushdown(int x) &#123;if (ad[x])&#123;addad(x&lt;&lt;1,ad[x]);addad(x&lt;&lt;1|1,ad[x]);ad[x]=0;&#125;&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addad(x,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return max(qry(x&lt;&lt;1,l,mid,ql,qr),qry(x&lt;&lt;1|1,mid+1,r,ql,qr));&#125;int main()&#123; n=red(),m=red(); for (int i=1;i&lt;=n;i++) b[++N]=a[i].l=red(),b[++N]=a[i].r=red(),a[i].w=a[i].r-a[i].l; sort(b+1,b+1+N); N=unique(b+1,b+1+N)-b-1; for (int i=1;i&lt;=n;i++) a[i].l=lower_bound(b+1,b+1+N,a[i].l)-b,a[i].r=lower_bound(b+1,b+1+N,a[i].r)-b; sort(a+1,a+1+n); int ans=INF; for (int i=1,j=0;i&lt;=n;i++)&#123; while (mx[1]&lt;m&amp;&amp;j&lt;n) j++,ist(1,1,N,a[j].l,a[j].r,1); if (mx[1]&gt;=m) ans=min(ans,a[j].w-a[i].w); ist(1,1,N,a[i].l,a[i].r,-1); &#125; if (ans==INF) return puts(\"-1\"),0; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"two-pointers","slug":"two-pointers","permalink":"http://oi.linkfqy.top/tags/two-pointers/"}]},{"title":"【备忘录】差分约束系统","slug":"System_of_Difference_Constraints","date":"2018-08-17T09:47:02.000Z","updated":"2018-08-17T10:02:18.000Z","comments":true,"path":"posts/System_of_Difference_Constraints/","link":"","permalink":"http://oi.linkfqy.top/posts/System_of_Difference_Constraints/","excerpt":"","text":"三角不等式 刷完最短路对于任意边\\((u,v)\\)，满足\\(dist_u+w(u,v)\\ge dist_v\\) 差分约束系统 一组形如\\(x_a-x_b\\le c\\)的不等式 形式恰好与三角不等式相同，因此可以用最短路算法求解 可以连一条边权为\\(c\\)的边\\((b,a)\\)，将\\(dist_a-dist_b\\)限制在\\(c\\)的范围内 当边\\((u,v)\\)属于最短路径时，\\(dist_a-dist_b\\le c\\)取到等号，即\\(dist_a-dist_b\\)取到最大值 所以\\(\\le\\)型的不等式刷最短路，得到最大值 同理\\(\\ge\\)型的不等式刷最长路，得到最小值 根据题意将所有等式化成一样的形式，刷最短/长路即可 Tips 负环/正环：无解（SPFA入队N次） 图不连通怎么办？ 直接将所有点入队，根据题意给\\(dist_i\\)初值 \\(dist\\)没有得到任何更新：任意解","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"差分约束系统","slug":"差分约束系统","permalink":"http://oi.linkfqy.top/tags/差分约束系统/"}]},{"title":"BZOJ2330 [SCOI2011]糖果","slug":"BZOJ2330","date":"2018-08-17T09:41:39.000Z","updated":"2018-08-17T09:44:22.000Z","comments":true,"path":"posts/BZOJ2330/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2330/","excerpt":"","text":"题面在这里 ​ 差分约束系统经典题…… 因为要求最小值，把差分不等式都化成\\(\\ge\\)形式刷最长路即可 注意2,4情况的特判a==b ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxe=200005;int n,q;int nxt[maxe],son[maxe],lnk[maxn],tot,w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int dst[maxn],que[maxn],num[maxn];bool vis[maxn];bool spfa()&#123; int hed=0,til=n; for (int i=1;i&lt;=n;i++) dst[i]=1,que[i]=i,vis[i]=1; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxn]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&lt;dst[x]+w[j])&#123; dst[son[j]]=dst[x]+w[j]; if (!vis[son[j]])&#123; vis[son[j]]=1,que[til=(til+1)%maxn]=son[j]; if (++num[son[j]]&gt;n) return 0; &#125; &#125; &#125; return 1;&#125;int main()&#123; n=red(),q=red(); while (q--)&#123; int c=red(),x=red(),y=red(); if (c&gt;=4) c-=2,swap(x,y); if (c==1) add(x,y,0),add(y,x,0);else if (c==2) &#123;if (x==y) return puts(\"-1\"),0;add(x,y,1);&#125;else if (c==3) add(y,x,0); &#125; if (!spfa()) return puts(\"-1\"),0; long long ans=0; for (int i=1;i&lt;=n;i++) ans+=dst[i]; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"},{"name":"差分约束系统","slug":"差分约束系统","permalink":"http://oi.linkfqy.top/tags/差分约束系统/"}]},{"title":"【树链剖分换根】BZOJ3083 遥远的国度","slug":"BZOJ3083","date":"2018-08-16T14:37:25.000Z","updated":"2018-08-16T14:41:44.000Z","comments":true,"path":"posts/BZOJ3083/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3083/","excerpt":"","text":"题面在这里 ​ 其实就把1当根做，记录一个假想的根Root，询问时讨论一波： ​ \\(x=Root\\)：此时应当询问整棵树 \\(LCA(x,Root)=x\\)：此时应该取Root所在子树的补集 \\(\\text{otherwise}\\)：取子树x即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005,maxs=400005;int n,q,Root,w[maxn],id[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int mn[maxs],cv[maxs];inline void pushup(int x) &#123;mn[x]=min(mn[x&lt;&lt;1],mn[x&lt;&lt;1|1]);&#125;inline void addcv(int x,int w) &#123;mn[x]=cv[x]=w;&#125;inline void pushdown(int x) &#123;if (cv[x]) &#123;addcv(x&lt;&lt;1,cv[x]);addcv(x&lt;&lt;1|1,cv[x]);cv[x]=0;&#125;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;mn[x]=w[id[l]];cv[x]=0;return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid);build(x&lt;&lt;1|1,mid+1,r); pushup(x);&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;addcv(x,w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mn[x]; if (qr&lt;l||r&lt;ql) return 0x7fffffff; int mid=l+r&gt;&gt;1; pushdown(x); return min(qry(x&lt;&lt;1,l,mid,ql,qr),qry(x&lt;&lt;1|1,mid+1,r,ql,qr));&#125;int in[maxn],out[maxn],dep[maxn],H_son[maxn],siz[maxn],top[maxn],fa[maxn],times,f[maxn][18];void getdep(int x)&#123; dep[x]=dep[fa[x]]+1;siz[x]=1;H_son[x]=0;f[x][0]=fa[x]; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x; getdep(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst; in[x]=++times; id[times]=x; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;void insert(int x,int y,int w)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); ist(1,1,n,in[top[x]],in[x],w); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); ist(1,1,n,in[x],in[y],w);&#125;int lca(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); return x;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); scanf(\"%d\",&amp;Root); fa[1]=1;getdep(1); dfs(1,1); build(1,1,n); for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1]; while (q--)&#123; int c;scanf(\"%d\",&amp;c); if (c==1) scanf(\"%d\",&amp;Root);else if (c==2)&#123; int x,y,w;scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w); insert(x,y,w); &#125;else&#123; int x,res;scanf(\"%d\",&amp;x); if (x==Root) res=qry(1,1,n,1,n);else if (lca(x,Root)!=x) res=qry(1,1,n,in[x],out[x]);else&#123; int v=Root; for (int j=17;~j;j--) if (dep[f[v][j]]&gt;dep[x]) v=f[v][j]; res=min(qry(1,1,n,1,in[v]-1),qry(1,1,n,out[v]+1,n)); &#125; printf(\"%d\\n\",res); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"虚树-学习笔记","slug":"virtual_tree","date":"2018-08-16T07:04:28.000Z","updated":"2018-08-16T07:35:44.000Z","comments":true,"path":"posts/virtual_tree/","link":"","permalink":"http://oi.linkfqy.top/posts/virtual_tree/","excerpt":"为什么我现在才会","text":"为什么我现在才会 ​ 引入 先放一道题： BZOJ2286： 给一棵带边权有根树，可以花费边权的代价断一些边 每次询问\\(k_i\\)个点，问使这些点都不与根联通的最小代价 \\(n,q\\le 10^5，\\sum k_i \\le 10^5\\) ​ 如果只有一个询问是个SB题……直接树形DP就好了 但是考虑到询问的总点数很有限，还是可做的 什么是虚树 像上面的例题，我们只把与询问有关的点拿出来建一棵树，就可以解决问题 那么这棵树包含所有询问点以及它们的LCA，这棵树就是虚树 ​ 考虑每次往虚树里加入一个询问点，最多增加一个LCA，所以虚树的点数是\\(O(k)\\)的 每次询问直接在虚树里做DP就可以了 这保证了复杂度 虚树的构造 按DFS序遍历每个询问点 我们用一个栈\\(stack\\)维护从根到当前点路径上的所有虚树点 当新加入点\\(x\\)是栈顶\\(stack[top]\\)的后代时，直接入栈 否则\\(x\\)与栈顶\\(stack[top]\\)的LCA一定要入栈（可能已经入了），同时应该把LCA的\\(x\\)所在子树构造好虚树 最后别忘了清栈 12345678910111213void insert(int x)&#123; if (!top) &#123;stk[++top]=x;return;&#125; int lca=LCA(x,stk[top]); while (top&gt;1&amp;&amp;dfn[stk[top-1]]&gt;dfn[lca]) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; if (dfn[stk[top]]&gt;dfn[lca]) add(lca,stk[top],dst(lca,stk[top])),top--; if (!top||dfn[stk[top]]&lt;dfn[lca]) stk[++top]=lca; stk[++top]=x;&#125;//......sort(h+1,h+1+K,cmp); tot=top=0;for (int i=1;i&lt;=K;i++) insert(h[i]);while (top&gt;1) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; tips 最后剩下的栈顶就是虚树根啦 每次建图清\\(lnk\\)很烦，可以一边DP一边清","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"虚树","slug":"虚树","permalink":"http://oi.linkfqy.top/tags/虚树/"}]},{"title":"【SET维护虚树边权】BZOJ3991 [SDOI2015]寻宝游戏","slug":"BZOJ3991","date":"2018-08-16T06:55:34.000Z","updated":"2018-08-16T07:00:34.000Z","comments":true,"path":"posts/BZOJ3991/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3991/","excerpt":"","text":"题面在这里 ​ 分析下题意，其实要求的是虚树边权和的两倍 可以用SET维护关键点的DFS序 加入关键点会带来与相邻两点的路径和的贡献，取消关键点会带来相邻两点路径和的贡献 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef set&lt;int&gt;::iterator iter;typedef long long ll;const int maxn=100005,maxe=200005;int n,q;int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int dep[maxn],dfn[maxn],id[maxn],f[maxn][18];ll g[maxn][18],times;bool imp[maxn]; void dfs(int x,int fa)&#123; dep[x]=dep[fa]+1;f[x][0]=fa;dfn[x]=++times;id[times]=x; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) g[son[j]][0]=w[j],dfs(son[j],x);&#125;void DP()&#123; for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], g[i][j]=g[i][j-1]+g[f[i][j-1]][j-1];&#125;ll dst(int x,int y)&#123; ll res=0; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=17;~j;j--) if (dep[f[x][j]]&gt;=dep[y]) res+=g[x][j],x=f[x][j]; if (x==y) return res; for (int j=17;~j;j--) if (f[x][j]!=f[y][j]) res+=g[x][j]+g[y][j],x=f[x][j],y=f[y][j]; return res+g[x][0]+g[y][0];&#125;set&lt;int&gt; S;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1,x,y,z;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); dfs(1,1); DP(); ll ans=0; while (q--)&#123; int x;scanf(\"%d\",&amp;x); if (imp[x])&#123; iter l,r; if (S.size()&gt;1)&#123; l=S.find(dfn[x]); r=l;r++; if (l==S.begin()) l=S.end();l--; if (r==S.end()) r=S.begin(); ans-=dst(id[*l],x)+dst(id[*r],x); &#125; if (S.size()&gt;2) ans+=dst(id[*l],id[*r]); S.erase(dfn[x]); &#125;else&#123; iter l,r; S.insert(dfn[x]); if (S.size()&gt;1)&#123; l=S.find(dfn[x]); r=l;r++; if (l==S.begin()) l=S.end();l--; if (r==S.end()) r=S.begin(); ans+=dst(id[*l],x)+dst(id[*r],x); &#125; if (S.size()&gt;2) ans-=dst(id[*l],id[*r]); &#125; imp[x]^=1; printf(\"%lld\\n\",ans); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"虚树","slug":"虚树","permalink":"http://oi.linkfqy.top/tags/虚树/"}]},{"title":"BZOJ2286 [Sdoi2011]消耗战","slug":"BZOJ2286","date":"2018-08-16T04:50:59.000Z","updated":"2018-08-16T04:52:22.000Z","comments":true,"path":"posts/BZOJ2286/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2286/","excerpt":"","text":"题面在这里 ​ 虚树模板题，不解释…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=250005,maxe=500005;int n,q,K,h[maxn],stk[maxn],top;int son[maxe],lnk[maxn],nxt[maxe],tot;ll w[maxe]; bool imp[maxn];inline void add(int x,int y,ll z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int dfn[maxn],fa[maxn][18],times,dep[maxn];ll g[maxn][18],f[maxn];void dfs(int x,int Fa)&#123; fa[x][0]=Fa; dep[x]=dep[Fa]+1; dfn[x]=++times; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=Fa) g[son[j]][0]=w[j],dfs(son[j],x);&#125;void DP()&#123; for (int j=1;j&lt;18;j++) for (int i=1;i&lt;=n;i++) fa[i][j]=fa[fa[i][j-1]][j-1], g[i][j]=min(g[i][j-1],g[fa[i][j-1]][j-1]);&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=17;~j;j--) if (dep[fa[x][j]]&gt;=dep[y]) x=fa[x][j]; if (x==y) return x; for (int j=17;~j;j--) if (fa[x][j]!=fa[y][j]) x=fa[x][j],y=fa[y][j]; return fa[x][0];&#125;ll dst(int x,int y)&#123; ll res=1e18; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=17;~j;j--) if (dep[fa[x][j]]&gt;=dep[y]) res=min(res,g[x][j]),x=fa[x][j]; if (x==y) return res; for (int j=17;~j;j--) if (fa[x][j]!=fa[y][j]) res=min(res,min(g[x][j],g[y][j])),x=fa[x][j],y=fa[y][j]; return min(res,min(g[x][0],g[y][0]));&#125;void insert(int x)&#123; if (!top) &#123;stk[++top]=x;return;&#125; int lca=LCA(x,stk[top]); while (top&gt;1&amp;&amp;dfn[stk[top-1]]&gt;dfn[lca]) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; if (dfn[stk[top]]&gt;dfn[lca]) add(lca,stk[top],dst(lca,stk[top])),top--; if (!top||dfn[stk[top]]&lt;dfn[lca]) stk[++top]=lca; stk[++top]=x;&#125;void treedp(int x)&#123; f[x]=0; for (int j=lnk[x];j;j=nxt[j])&#123; treedp(son[j]); if (imp[son[j]]) f[x]+=w[j];else f[x]+=min(w[j],f[son[j]]); &#125; lnk[x]=0;&#125;inline bool cmp(const int&amp;x,const int&amp;y) &#123;return dfn[x]&lt;dfn[y];&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x,y,z;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); g[1][0]=1e18; dfs(1,1); DP(); cl(lnk,0); scanf(\"%d\",&amp;q); while (q--)&#123; scanf(\"%d\",&amp;K); for (int i=1;i&lt;=K;i++) scanf(\"%d\",&amp;h[i]);h[++K]=1; sort(h+1,h+1+K,cmp); tot=top=0; for (int i=1;i&lt;=K;i++) insert(h[i]),imp[h[i]]=1; while (top&gt;1) add(stk[top-1],stk[top],dst(stk[top-1],stk[top])),top--; treedp(stk[1]); for (int i=1;i&lt;=K;i++) imp[h[i]]=0; printf(\"%lld\\n\",f[1]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树形DP","slug":"树形DP","permalink":"http://oi.linkfqy.top/tags/树形DP/"},{"name":"虚树","slug":"虚树","permalink":"http://oi.linkfqy.top/tags/虚树/"}]},{"title":"【线段树压位、压位+SET】BZOJ4942 [Noi2017]整数","slug":"BZOJ4942","date":"2018-08-15T12:15:56.000Z","updated":"2018-08-15T12:34:58.000Z","comments":true,"path":"posts/BZOJ4942/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4942/","excerpt":"","text":"题面在这里 ​ 好像线段树压位可以直接暴艹过去…… ​ 考虑只有加法，那么暴力加1均摊复杂度是\\(O(1)\\)的 因为每次加法都只会产生1个1，而1只能在加法中产生 所以每次进位变成0的1都对应着一次加法，均摊复杂度\\(O(1)\\) ​ 然后这个有减法，我们就分别存加操作和减操作的绝对值 把\\(a\\)拆分成\\(\\sum 2^k\\)，于是修改直接压位处理是\\(O(1)\\)的 每次询问两个数相减的二进制第k位 考虑两个串在\\([0,k-1]\\)的大小，显然 加串\\(\\ge\\)减串 时，答案是第k位的异或值 否则是第k位的同或值 直接用set维护两个\\(unsigned\\ int\\)串不同的位置 比大小就是lower_bound找到第一个不等的位置比较 然后就好了……代码贼短 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned int uint;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005;int q;uint a[2][maxn];set&lt;int&gt; S;void ist(int x,int d)&#123; uint i=x/32,j=x%32; while (1)&#123; uint t=a[d][i]; a[d][i]+=(1&lt;&lt;j); if (a[d][i]==a[d^1][i]) S.erase(i);else S.insert(i); if (a[d][i]&gt;t) return; i++;j=0; &#125;&#125;bool check(int k)&#123; uint i=k/32,j=k%32; if ((a[0][i]&amp;(1&lt;&lt;j)-1)!=(a[1][i]&amp;(1&lt;&lt;j)-1)) return (a[0][i]&amp;(1&lt;&lt;j)-1)&lt;(a[1][i]&amp;(1&lt;&lt;j)-1); set&lt;int&gt;::iterator it=S.lower_bound(i); if (it==S.begin()) return 1; it--; return a[0][*it]&lt;a[1][*it];&#125;int main()&#123; q=red();red(),red(),red(); while (q--) if (red()==1)&#123; int x=red(),k=red(),d=(x&gt;0?1:(x=-x,0)); for (int i=0;i&lt;=30;i++) if (x&amp;(1&lt;&lt;i)) ist(i+k,d); &#125;else&#123; int k=red(); uint i=k/32,j=k%32; if (check(k)) putchar((((a[0][i]&gt;&gt;j)^(a[1][i]&gt;&gt;j))&amp;1)+48); else putchar((((a[0][i]&gt;&gt;j)^(a[1][i]&gt;&gt;j)^1)&amp;1)+48); putchar('\\n'); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"压位","slug":"压位","permalink":"http://oi.linkfqy.top/tags/压位/"}]},{"title":"【SPFA动态加边】BZOJ3669 [Noi2014]魔法森林","slug":"BZOJ3669_spfa","date":"2018-08-13T14:03:32.000Z","updated":"2018-08-13T14:06:30.000Z","comments":true,"path":"posts/BZOJ3669_spfa/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3669_spfa/","excerpt":"","text":"题面在这里 ​ 考虑枚举a，就要使路径最大边最小 这个可以刷SPFA 然后动态加边，更新边的两个端点就可以了 复杂度玄学……大家不要学我，老老实实去打LCT吧 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=50005,maxe=200005,maxs=400005;int n,e;struct edge&#123; int x,y,a,b; bool operator&lt;(const edge&amp;b)const &#123;return a&lt;b.a;&#125;&#125;a[maxe];int son[maxe],nxt[maxe],lnk[maxn],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int hed,til,que[maxs],dst[maxn];bool vis[maxn];void spfa()&#123; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxs]; vis[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (dst[son[j]]&gt;max(dst[x],w[j]))&#123; dst[son[j]]=max(dst[x],w[j]); if (!vis[son[j]]) vis[son[j]]=1,que[til=(til+1)%maxs]=son[j]; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=e;i++) scanf(\"%d%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].a,&amp;a[i].b); sort(a+1,a+1+e); cl(dst,63);dst[1]=0; hed=1,til=0; que[++til]=1;vis[1]=1; int ans=0x3f3f3f3f; for (int i=1;i&lt;=e;i++)&#123; add(a[i].x,a[i].y,a[i].b); add(a[i].y,a[i].x,a[i].b); que[til=(til+1)%maxs]=a[i].x; que[til=(til+1)%maxs]=a[i].y; spfa(); ans=min(ans,dst[n]+a[i].a); &#125; printf(\"%d\",ans&gt;1e6?-1:ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"BZOJ2243 [SDOI2011]染色","slug":"BZOJ2243","date":"2018-08-13T12:02:42.000Z","updated":"2018-08-13T12:07:24.000Z","comments":true,"path":"posts/BZOJ2243/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2243/","excerpt":"","text":"题面在这里 ​ 直接树链剖分 线段树维护左右颜色和颜色种类 合并区间时要去除相邻的同色节点 ​ 但是树链剖分合并区间就不太好搞了，只能做两次x到祖先的路径 注意区间合并是由方向的，树链剖分那里没注意查半天…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxe=200005,maxs=4*maxn;int n,q,c[maxn],id[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct node&#123; int x,l,r,cv; node () &#123;cv=-1;&#125; node (int _x,int _l,int _r):x(_x),l(_l),r(_r),cv(-1) &#123;&#125; inline void addcv(int w) &#123;l=r=cv=w;x=1;&#125;&#125;tre[maxs];inline node operator+(const node&amp;a,const node&amp;b) &#123;return node(a.x+b.x-(a.r==b.l),a.l,b.r);&#125;inline void pushdown(int x)&#123; if (tre[x].cv&gt;=0)&#123; tre[x&lt;&lt;1].addcv(tre[x].cv); tre[x&lt;&lt;1|1].addcv(tre[x].cv); tre[x].cv=-1; &#125;&#125;void buildtree(int x,int l,int r)&#123; if (l==r) &#123;tre[x].addcv(c[id[l]]);return;&#125; int mid=l+r&gt;&gt;1; buildtree(x&lt;&lt;1,l,mid); buildtree(x&lt;&lt;1|1,mid+1,r); tre[x]=tre[x&lt;&lt;1]+tre[x&lt;&lt;1|1];&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;tre[x].addcv(w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); tre[x]=tre[x&lt;&lt;1]+tre[x&lt;&lt;1|1];&#125;node qry(int x,int l,int r,int ql,int qr)&#123; if (ql==l&amp;&amp;r==qr) return tre[x]; int mid=l+r&gt;&gt;1; pushdown(x); if (qr&lt;=mid) return qry(x&lt;&lt;1,l,mid,ql,qr);else if (ql&gt;mid) return qry(x&lt;&lt;1|1,mid+1,r,ql,qr);else return qry(x&lt;&lt;1,l,mid,ql,mid)+qry(x&lt;&lt;1|1,mid+1,r,mid+1,qr);&#125;int H_son[maxn],siz[maxn],fa[maxn],dep[maxn],in[maxn],out[maxn],top[maxn],times;void getH(int x)&#123; siz[x]=1;dep[x]=dep[fa[x]]+1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x; getH(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst;in[x]=++times;id[times]=x; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;int LCA(int x,int y)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); x=fa[top[x]]; &#125; if (dep[x]&gt;dep[y]) swap(x,y); return x;&#125;void cao(int x,int y,int w)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); ist(1,1,n,in[top[x]],in[x],w); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); ist(1,1,n,in[x],in[y],w);&#125;int ask(int x,int y)&#123; node res;bool fir=1; while (top[x]!=top[y])&#123; if (fir) res=qry(1,1,n,in[top[x]],in[x]),fir=0; else res=qry(1,1,n,in[top[x]],in[x])+res; x=fa[top[x]]; &#125; if (fir) res=qry(1,1,n,in[y],in[x]),fir=0; else res=qry(1,1,n,in[y],in[x])+res; return res.x;&#125;char s[20];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;q); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;c[i]); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(y,x),add(x,y); fa[1]=1;getH(1); dfs(1,1); buildtree(1,1,n); while (q--)&#123; scanf(\"%s\",s); if (s[0]=='C')&#123; int x,y,c;scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;c); cao(x,y,c); &#125;else&#123; int x,y,lca;scanf(\"%d%d\",&amp;x,&amp;y); lca=LCA(x,y); printf(\"%d\\n\",ask(x,lca)+ask(y,lca)-1); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"【边权树链剖分】BZOJ1984 月下“毛景树”","slug":"BZOJ1984","date":"2018-08-13T09:49:11.000Z","updated":"2018-08-13T09:52:36.000Z","comments":true,"path":"posts/BZOJ1984/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1984/","excerpt":"","text":"题面在这里 ​ 题目很水，但是细节很多 首先是用树链剖分维护边权的姿势：每个点代表连向父亲的边 这样就要注意两点的LCA不能算入答案中 然后是线段树两个标记，只能同时存在一个 具体写法自己看代码 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005,maxs=4*maxn;int n,N,w[maxn],id[maxn];int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int mx[maxs],ad[maxs],cv[maxs];inline void pushup(int x) &#123;mx[x]=max(mx[x&lt;&lt;1],mx[x&lt;&lt;1|1]);&#125;inline void addad(int x,int w) &#123;mx[x]+=w,ad[x]+=w;if (cv[x]) cv[x]+=w;&#125;inline void addcv(int x,int w) &#123;mx[x]=w;cv[x]=w;ad[x]=0;&#125;inline void pushdown(int x)&#123; if (ad[x]) &#123;addad(x&lt;&lt;1,ad[x]);addad(x&lt;&lt;1|1,ad[x]);ad[x]=0;&#125; if (cv[x]) &#123;addcv(x&lt;&lt;1,cv[x]);addcv(x&lt;&lt;1|1,cv[x]);cv[x]=0;&#125;&#125;void ist(int x,int l,int r,int ql,int qr,int w)&#123; //+w:add -w:cover if (ql&lt;=l&amp;&amp;r&lt;=qr) &#123;if (w&gt;0) addad(x,w);else addcv(x,-w);return;&#125; if (qr&lt;l||r&lt;ql) return; int mid=l+r&gt;&gt;1; pushdown(x); ist(x&lt;&lt;1,l,mid,ql,qr,w); ist(x&lt;&lt;1|1,mid+1,r,ql,qr,w); pushup(x);&#125;int qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return mx[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; pushdown(x); return max(qry(x&lt;&lt;1,l,mid,ql,qr),qry(x&lt;&lt;1|1,mid+1,r,ql,qr));&#125;int H_son[maxn],siz[maxn],fa[maxn],dep[maxn],in[maxn],out[maxn],top[maxn],times;void getH(int x)&#123; siz[x]=1;dep[x]=dep[fa[x]]+1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; id[j+1&gt;&gt;1]=son[j];fa[son[j]]=x; getH(son[j]); siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst;in[x]=++times; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]&amp;&amp;son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;void cao(int x,int y,int w)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); ist(1,1,N,in[top[x]],in[x],w); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); ist(1,1,N,in[x]+1,in[y],w);&#125;int ask(int x,int y)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res=max(res,qry(1,1,N,in[top[x]],in[x])); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); return max(res,qry(1,1,N,in[x]+1,in[y]));&#125;char s[20];int main()&#123; scanf(\"%d\",&amp;n); N=n; for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w[i]),add(y,x),add(x,y); fa[1]=1;getH(1); dfs(1,1); for (int i=1;i&lt;n;i++) ist(1,1,N,in[id[i]],in[id[i]],-w[i]); for (scanf(\"%s\",s);s[0]!='S';scanf(\"%s\",s)) if (s[1]=='h')&#123; int x,w;scanf(\"%d%d\",&amp;x,&amp;w); ist(1,1,N,in[id[x]],in[id[x]],-w); &#125;else if (s[1]=='o')&#123; int x,y,w;scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w); cao(x,y,-w); &#125;else if (s[1]=='d')&#123; int x,y,w;scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;w); cao(x,y,w); &#125;else&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); printf(\"%d\\n\",ask(x,y)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"【线段树合并】BZOJ4756 [Usaco2017 Jan]Promotion Counting","slug":"BZOJ4756","date":"2018-08-12T09:38:13.000Z","updated":"2018-08-12T09:39:08.000Z","comments":true,"path":"posts/BZOJ4756/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4756/","excerpt":"","text":"题面在这里 ​ 直接线段树合并就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=maxn,maxs=2000005;int n,m,a[maxn],b[maxn],ans[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int tre[maxs],ls[maxs],rs[maxs],len,Rot[maxn];inline void pushup(int x) &#123;tre[x]=tre[ls[x]]+tre[rs[x]];&#125;void ist(int &amp;x,int l,int r,int k)&#123; if (!x) x=++len; if (l==r) &#123;tre[x]++;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k);else ist(rs[x],mid+1,r,k); pushup(x);&#125;int qry(int x,int l,int r,int k)&#123; if (l==r) return 0; int mid=l+r&gt;&gt;1; if (k&lt;=mid) return qry(ls[x],l,mid,k)+tre[rs[x]]; else return qry(rs[x],mid+1,r,k);&#125;int merge(int x,int y)&#123; if (!x||!y) return x+y; tre[x]+=tre[y]; ls[x]=merge(ls[x],ls[y]); rs[x]=merge(rs[x],rs[y]); return x;&#125;void dfs(int x)&#123; ist(Rot[x],1,m,a[x]); for (int j=lnk[x];j;j=nxt[j]) dfs(son[j]),Rot[x]=merge(Rot[x],Rot[son[j]]); ans[x]=qry(Rot[x],1,m,a[x]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),b[i]=a[i]; sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=1;i&lt;=n;i++) a[i]=lower_bound(b+1,b+1+m,a[i])-b; for (int i=2,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),add(x,i); dfs(1); for (int i=1;i&lt;=n;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"【线段树合并】BZOJ2733 [HNOI2012]永无乡","slug":"BZOJ2733","date":"2018-08-12T07:23:11.000Z","updated":"2018-08-12T07:25:16.000Z","comments":true,"path":"posts/BZOJ2733/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2733/","excerpt":"","text":"题面在这里 ​ RT，直接用并查集维护联通块 用权值线段树合并维护第K大信息 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;const int maxn=100005,maxs=2000005;int n,e,q,a[maxn],p[maxn],fa[maxn]; char s[5];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int Rot[maxn],len,tre[maxs],ls[maxs],rs[maxs];inline void pushup(int x) &#123;tre[x]=tre[ls[x]]+tre[rs[x]];&#125;inline int newnode(int _ls,int _rs,int _s) &#123;ls[++len]=_ls,rs[len]=_rs,tre[len]=_s;return len;&#125;void ist(int &amp;x,int l,int r,int k)&#123; if (!x) x=newnode(0,0,0); if (l==r) &#123;tre[x]++;return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(ls[x],l,mid,k); else ist(rs[x],mid+1,r,k); pushup(x);&#125;int qry(int x,int l,int r,int k)&#123; if (k&gt;tre[x]) return -1; if (l==r) return p[l]; int mid=l+r&gt;&gt;1; if (k&lt;=tre[ls[x]]) return qry(ls[x],l,mid,k); else return qry(rs[x],mid+1,r,k-tre[ls[x]]);&#125;int merge(int x,int y)&#123; if (!x||!y) return x+y; ls[x]=merge(ls[x],ls[y]); rs[x]=merge(rs[x],rs[y]); tre[x]=tre[x]+tre[y]; return x;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),p[x]=i,a[i]=x,fa[i]=i; for (int i=1,x,y;i&lt;=e;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y);fa[getfa(x)]=getfa(y); &#125; for (int i=1;i&lt;=n;i++) ist(Rot[getfa(i)],1,n,a[i]); scanf(\"%d\",&amp;q); while (q--)&#123; scanf(\"%s\",s); if (s[0]=='Q')&#123; int x,k;scanf(\"%d%d\",&amp;x,&amp;k); printf(\"%d\\n\",qry(Rot[getfa(x)],1,n,k)); &#125;else&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); if (getfa(x)!=getfa(y)) Rot[getfa(x)]=merge(Rot[getfa(x)],Rot[getfa(y)]),fa[getfa(y)]=getfa(x); &#125; &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"BZOJ1726 [Usaco2006 Nov]Roadblocks第二短路","slug":"BZOJ1726","date":"2018-08-11T10:06:40.000Z","updated":"2018-08-11T10:09:38.000Z","comments":true,"path":"posts/BZOJ1726/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1726/","excerpt":"“喂，妖妖灵吗，这里有个博主彻底疯了”","text":"“喂，妖妖灵吗，这里有个博主彻底疯了” 题面在这里 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=5005,maxe=200005;int n,e,dst[maxn];bool vis[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;void DIJ()&#123; cl(dst,63); dst[n]=0; for (int i=1;i&lt;=n;i++)&#123; int k,MIN=0x3f3f3f3f; for (int j=1;j&lt;=n;j++) if (!vis[j]&amp;&amp;dst[j]&lt;MIN) MIN=dst[k=j]; vis[k]=1; for (int j=lnk[k];j;j=nxt[j]) dst[son[j]]=min(dst[son[j]],dst[k]+w[j]); &#125;&#125;struct data&#123; int id,x; data () &#123;&#125; data (int _id,int _x):id(_id),x(_x) &#123;&#125; inline bool operator&lt;(const data&amp;b)const &#123;return x+dst[id]&gt;b.x+dst[b.id];&#125;&#125;;priority_queue&lt;data&gt; Q;int Astar()&#123; Q.push(data(1,0)); while (!Q.empty())&#123; data k=Q.top();Q.pop(); if (k.id==n&amp;&amp;k.x&gt;dst[1]) return k.x; for (int j=lnk[k.id];j;j=nxt[j]) Q.push(data(son[j],k.x+w[j])); &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); DIJ(); printf(\"%d\",Astar()); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"A*","slug":"A","permalink":"http://oi.linkfqy.top/tags/A/"}]},{"title":"BZOJ1708 [Usaco2007 Oct]Money奶牛的硬币","slug":"BZOJ1708","date":"2018-08-11T09:27:36.000Z","updated":"2018-08-11T09:30:26.000Z","comments":true,"path":"posts/BZOJ1708/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1708/","excerpt":"“看，又是一个被刷题量逼疯的”","text":"“看，又是一个被刷题量逼疯的” 题面在这里 ​ 示例程序： 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int n,V,w[30];ll f[10005];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;V); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); f[0]=1; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=V;j++) if (w[i]&lt;=j) f[j]+=f[j-w[i]]; printf(\"%lld\",f[V]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ1724 [Usaco2006 Nov]Fence Repair 切割木板","slug":"BZOJ1724","date":"2018-08-11T09:22:25.000Z","updated":"2018-08-11T09:23:14.000Z","comments":true,"path":"posts/BZOJ1724/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1724/","excerpt":"","text":"题面在这里 ​ 水博客*3 ​ 示例程序： 123456789101112131415161718192021#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int n;priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt; &gt; Q;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x;i&lt;=n;i++) scanf(\"%d\",&amp;x),Q.push(x); ll ans=0; while (Q.size()&gt;1)&#123; int x=Q.top();Q.pop(); int y=Q.top();Q.pop(); ans+=x+y; Q.push(x+y); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ1782 [Usaco2010 Feb]slowdown 慢慢游","slug":"BZOJ1782","date":"2018-08-11T09:14:19.000Z","updated":"2018-08-11T09:15:30.000Z","comments":true,"path":"posts/BZOJ1782/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1782/","excerpt":"","text":"题面在这里 ​ 水博客*2 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334#include&lt;cstdio&gt;const int maxn=100005,maxe=200005;int n,in[maxn],out[maxn],times;int son[maxe],nxt[maxe],lnk[maxn],tot;inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int BIT[maxn];inline void ist(int x,int w)&#123; for (int i=x;i&lt;=n;i+=(i&amp;-i)) BIT[i]+=w;&#125;inline int ask(int x)&#123; int res=0; for (int i=x;i;i-=(i&amp;-i)) res+=BIT[i]; return res;&#125;void dfs(int x,int fa)&#123; in[x]=++times; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x); out[x]=times;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs(1,1); for (int i=1;i&lt;=n;i++)&#123; int p;scanf(\"%d\",&amp;p); printf(\"%d\\n\",ask(in[p])); ist(in[p],1);ist(out[p]+1,-1); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"【线段树维护最大子段和】BZOJ1756 小白逛公园","slug":"BZOJ1756","date":"2018-08-11T08:51:25.000Z","updated":"2018-08-11T08:54:22.000Z","comments":true,"path":"posts/BZOJ1756/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1756/","excerpt":"","text":"题面在这里 ​ 线段树维护\\(sum,lmax,rmax,max\\)即可 分别表示区间和，从左开始的最大子段，从右开始的最大子段，总最大子段 这题L&gt;R好坑啊 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxs=2000005;int n,q,a[maxn];struct node&#123; int s,lm,rm,mx; inline void get(int x) &#123;s=lm=rm=mx=x;&#125;&#125;tre[maxs],null;inline node operator+(const node&amp;a,const node&amp;b)&#123; node res; res.s=a.s+b.s; res.lm=max(a.lm,a.s+b.lm); res.rm=max(b.rm,b.s+a.rm); res.mx=max(max(max(a.mx,b.mx),max(res.lm,res.rm)),a.rm+b.lm); return res;&#125;void build(int x,int l,int r)&#123; if (l==r) &#123;tre[x].get(a[l]);return;&#125; int mid=l+r&gt;&gt;1; build(x&lt;&lt;1,l,mid); build(x&lt;&lt;1|1,mid+1,r); tre[x]=tre[x&lt;&lt;1]+tre[x&lt;&lt;1|1];&#125;void ist(int x,int l,int r,int k,int w)&#123; if (l==r) &#123;tre[x].get(w);return;&#125; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ist(x&lt;&lt;1,l,mid,k,w); else ist(x&lt;&lt;1|1,mid+1,r,k,w); tre[x]=tre[x&lt;&lt;1]+tre[x&lt;&lt;1|1];&#125;node qry(int x,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return tre[x]; if (qr&lt;l||r&lt;ql) return null; int mid=l+r&gt;&gt;1; return qry(x&lt;&lt;1,l,mid,ql,qr)+qry(x&lt;&lt;1|1,mid+1,r,ql,qr);&#125;int main()&#123; n=red(),q=red(); null.get(0xc0c0c0c0);null.s=0; for (int i=1;i&lt;=n;i++) a[i]=red(); build(1,1,n); while (q--) if (red()==1)&#123; int l=red(),r=red(); if (l&gt;r) swap(l,r); printf(\"%d\\n\",qry(1,1,n,l,r).mx); &#125;else&#123; int k=red(),w=red(); ist(1,1,n,k,w); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"BZOJ2783 [JLOI2012]树","slug":"BZOJ2783","date":"2018-08-11T07:56:26.000Z","updated":"2018-08-11T07:57:18.000Z","comments":true,"path":"posts/BZOJ2783/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2783/","excerpt":"","text":"题面在这里 ​ 水水更健康…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;const int maxn=100005,maxe=maxn;int n,S,a[maxn],f[maxn][18],s[maxn][18],dep[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x)&#123; for (int j=lnk[x];j;j=nxt[j]) dep[son[j]]=dep[x]+1,f[son[j]][0]=x,s[son[j]][0]=a[x], dfs(son[j]);&#125;int calc(int x)&#123; int res=a[x]; for (int j=17;j&gt;=0;j--) if (res+s[x][j]&lt;=S) res+=s[x][j],x=f[x][j]; return res==S;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;S); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); for (int i=1,x,y;i&lt;n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y); f[1][0]=1;s[1][0]=0; dfs(1); for (int j=1;j&lt;=17;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], s[i][j]=s[i][j-1]+s[f[i][j-1]][j-1]; int ans=0; for (int i=1;i&lt;=n;i++) ans+=calc(i); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【后缀数组+主席树】BZOJ4556 [Tjoi2016&Heoi2016]字符串","slug":"BZOJ4556","date":"2018-08-11T07:16:35.000Z","updated":"2018-08-11T07:22:22.000Z","comments":true,"path":"posts/BZOJ4556/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4556/","excerpt":"","text":"题面在这里 ​ 首先考虑二分答案 那么就是要判断\\(S_{c,c+mid-1}\\)是否在\\(S_{a,b}\\)中出现过 考虑所有以\\(S_{c,c+mid-1}\\)为前缀的后缀，rank一定是连续的 可以倍增找出这个区间 那么就是要看这个区间内是否存在开头属于\\([a,b-mid+1]\\)的后缀 主席树区间求和就好了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxs=2000005;int n,m,q;char s[maxn];int sa[maxn],rk[maxn*2],t[maxn],buc[maxn],ht[maxn],f[maxn][17];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1,p=0;k&lt;n&amp;&amp;p&lt;n;k&lt;&lt;=1,m=p)&#123; p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(t)); &#125; for (int i=1,h=0;i&lt;=n;i++)&#123; if (h) h--; int j=sa[rk[i]-1]; while (s[i+h]==s[j+h]) h++; ht[rk[i]]=h; &#125; ht[1]=0; for (int i=1;i&lt;=n;i++) f[i][0]=ht[i]; for (int j=1;j&lt;=16;j++) for (int i=1;i&lt;=n;i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);&#125;int tre[maxs],ls[maxs],rs[maxs],len,Rot[maxn];inline void pushup(int x) &#123;tre[x]=tre[ls[x]]+tre[rs[x]];&#125;int build(int l,int r)&#123; int x=++len;tre[x]=0; if (l==r) return ls[x]=rs[x]=0,x; int mid=l+r&gt;&gt;1; ls[x]=build(l,mid); rs[x]=build(mid+1,r); return x;&#125;int ist(int fa,int l,int r,int k)&#123; int x=++len; tre[x]=tre[fa]; ls[x]=ls[fa]; rs[x]=rs[fa]; if (l==r) return tre[x]++,x; int mid=l+r&gt;&gt;1; if (k&lt;=mid) ls[x]=ist(ls[fa],l,mid,k); else rs[x]=ist(rs[fa],mid+1,r,k); pushup(x); return x;&#125;int qry(int x,int y,int l,int r,int ql,int qr)&#123; if (ql&lt;=l&amp;&amp;r&lt;=qr) return tre[y]-tre[x]; if (qr&lt;l||r&lt;ql) return 0; int mid=l+r&gt;&gt;1; return qry(ls[x],ls[y],l,mid,ql,qr)+qry(rs[x],rs[y],mid+1,r,ql,qr);&#125;int main()&#123; scanf(\"%d%d%s\",&amp;n,&amp;q,s+1); make_sa(); Rot[0]=build(1,n); for (int i=1;i&lt;=n;i++) Rot[i]=ist(Rot[i-1],1,n,sa[i]); while (q--)&#123; int a,b,c,d;scanf(\"%d%d%d%d\",&amp;a,&amp;b,&amp;c,&amp;d); int l=1,r=d-c+1,res=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1,L=rk[c],R=rk[c]; for (int j=16;j&gt;=0;j--)&#123; if (L&gt;(1&lt;&lt;j)&amp;&amp;f[L-(1&lt;&lt;j)+1][j]&gt;=mid) L-=(1&lt;&lt;j); if (R+(1&lt;&lt;j)&lt;=n&amp;&amp;f[R+1][j]&gt;=mid) R+=(1&lt;&lt;j); &#125; if (qry(Rot[L-1],Rot[R],1,n,a,b-mid+1)&gt;0) res=mid,l=mid+1;else r=mid-1; &#125; printf(\"%d\\n\",res); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://oi.linkfqy.top/tags/后缀数组/"},{"name":"主席树","slug":"主席树","permalink":"http://oi.linkfqy.top/tags/主席树/"}]},{"title":"BZOJ1977 [BeiJing2010组队]次小生成树 Tree","slug":"BZOJ1977","date":"2018-08-09T13:13:08.000Z","updated":"2018-08-09T13:15:48.000Z","comments":true,"path":"posts/BZOJ1977/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1977/","excerpt":"","text":"题面在这里 ​ 先做最小生成树 然后枚举非树边，把两点路径中最大边替换掉 如果最大边等于当前边权，考虑严格次大边 用树上倍增预处理出来就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005,maxe=600005;int n,e,fa[maxn],dep[maxn],f[maxn][20];bool vis[maxe];struct edge&#123; int x,y,w; inline bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe];struct data&#123; int mx,cd; data () &#123;&#125; data (int _mx,int _cd):mx(_mx),cd(_cd) &#123;&#125;&#125;g[maxn][20];inline data Max(data a,data b)&#123; if (a.mx==b.mx) return data(a.mx,max(a.cd,b.cd)); if (a.mx&lt;b.mx) return data(b.mx,max(a.mx,b.cd)); return data(a.mx,max(b.mx,a.cd));&#125;int tot,son[maxe],lnk[maxn],nxt[maxe],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;void dfs(int x,int fa)&#123; f[x][0]=fa; dep[x]=dep[fa]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) g[son[j]][0]=data(w[j],0),dfs(son[j],x);&#125;data LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); data res(0,0); for (int j=19;j&gt;=0;j--) if (dep[f[x][j]]&gt;=dep[y]) res=Max(res,g[x][j]),x=f[x][j]; if (x==y) return res; for (int j=19;j&gt;=0;j--) if (f[x][j]!=f[y][j]) res=Max(res,Max(g[x][j],g[y][j])),x=f[x][j],y=f[y][j]; return Max(res,Max(g[x][0],g[y][0]));&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;a[i].x,&amp;a[i].y,&amp;a[i].w); sort(a+1,a+1+e); for (int i=1;i&lt;=n;i++) fa[i]=i; ll sum=0; for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y))&#123; fa[getfa(a[i].x)]=getfa(a[i].y); sum+=a[i].w; vis[i]=1; add(a[i].x,a[i].y,a[i].w); add(a[i].y,a[i].x,a[i].w); &#125; dfs(1,1); for (int j=1;j&lt;=19;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], g[i][j]=Max(g[i][j-1],g[f[i][j-1]][j-1]); ll ans=1e17; for (int i=1;i&lt;=e;i++) if (!vis[i])&#123; data t=LCA(a[i].x,a[i].y); if (t.mx&lt;a[i].w) ans=min(ans,sum-t.mx+a[i].w); else ans=min(ans,sum-t.cd+a[i].w); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"}]},{"title":"BZOJ2463 [中山市选2009]谁能赢呢？","slug":"BZOJ2463","date":"2018-08-09T04:23:20.000Z","updated":"2018-08-09T04:27:52.000Z","comments":true,"path":"posts/BZOJ2463/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2463/","excerpt":"","text":"题面在这里 ​ 首先一个\\(N\\times N\\)的棋盘，如果\\(N\\)是偶数则一定能被\\(1\\times 2\\)的骨牌平铺 如果\\(N\\)是奇数则有1格不能覆盖 考虑这个游戏，先手一定走同一块骨牌没走过的那格，后手一定走到一块新的骨牌 \\(N\\)是偶数，先手必胜，\\(N\\)是奇数后手必胜 ​ 示例程序： 1234567#include&lt;cstdio&gt;int n;int main()&#123; while (scanf(\"%d\",&amp;n),n) puts((n&amp;1)?\"Bob\":\"Alice\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"博弈论","slug":"博弈论","permalink":"http://oi.linkfqy.top/tags/博弈论/"}]},{"title":"【贪心+并查集】BZOJ1854 [Scoi2010]游戏","slug":"BZOJ1854","date":"2018-08-08T13:43:58.000Z","updated":"2018-08-08T13:48:04.000Z","comments":true,"path":"posts/BZOJ1854/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1854/","excerpt":"","text":"题面在这里 ​ 把武器看作边，属性值看作点 那么就是要把每个点与其邻边匹配 显然一个联通块有环则所有点都能匹配 否则只有1个点不能匹配，这里我们使属性值最大点不匹配 并查集合并联通块时维护每个点是否能找到匹配就好了 ​ 示例程序： 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=10005;int n,fa[maxn];bool vis[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=10000;i++) fa[i]=i; for (int i=1;i&lt;=n;i++)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); if (getfa(x)==getfa(y)) vis[getfa(x)]=1; else vis[getfa(min(x,y))]=1,fa[getfa(min(x,y))]=getfa(max(x,y)); &#125; for (int i=1;i&lt;=10001;i++) if (!vis[i]) return printf(\"%d\",i-1),0; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"}]},{"title":"BZOJ1821 [JSOI2010]Group 部落划分","slug":"BZOJ1821","date":"2018-08-08T13:29:46.000Z","updated":"2018-08-08T13:30:40.000Z","comments":true,"path":"posts/BZOJ1821/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1821/","excerpt":"","text":"题面在这里 ​ 水博客*2 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005,maxe=1000005;int n,K,e,x[maxn],y[maxn],fa[maxn];struct edge&#123; int x,y;double w; edge () &#123;&#125; edge (int _x,int _y,double _w):x(_x),y(_y),w(_w) &#123;&#125; inline bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe];inline double sqr(double x) &#123;return x*x;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K);e=0; for (int i=1;i&lt;=n;i++)&#123; scanf(\"%d%d\",&amp;x[i],&amp;y[i]); for (int j=1;j&lt;i;j++) a[++e]=edge(i,j,sqrt(sqr(x[i]-x[j])+sqr(y[i]-y[j]))); &#125; sort(a+1,a+1+e); int tot=n; for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y))&#123; fa[getfa(a[i].x)]=getfa(a[i].y); if (--tot==K) break; &#125; for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y)) return printf(\"%.2lf\",a[i].w); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ1218 [HNOI2003]激光炸弹","slug":"BZOJ1218","date":"2018-08-08T13:09:47.000Z","updated":"2018-08-08T13:10:50.000Z","comments":true,"path":"posts/BZOJ1218/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1218/","excerpt":"","text":"题面在这里 ​ LZ又来水博客了…… ​ 示例程序： 123456789101112131415161718#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5005;int n,R,s[maxn][maxn];short int a[maxn][maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;R); for (int i=1,x,y,z;i&lt;=n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),a[x+1][y+1]+=z; for (int i=1;i&lt;=5001;i++) for (int j=1;j&lt;=5001;j++) s[i][j]=s[i-1][j]+s[i][j-1]-s[i-1][j-1]+a[i][j]; int ans=0; for (int i=R;i&lt;=5001;i++) for (int j=R;j&lt;=5001;j++) ans=max(ans,s[i][j]-s[i-R][j]-s[i][j-R]+s[i-R][j-R]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"【多校2018#6】HDU6370 Werewolf","slug":"HDU6370","date":"2018-08-08T11:49:03.000Z","updated":"2018-08-08T12:06:34.000Z","comments":true,"path":"posts/HDU6370/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6370/","excerpt":"","text":"题面在这里 ​ 首先第一问一定是0 然后就考虑每个人是否实锤说假话 把每个人看成一个点，说的话看成一条边 因为每人只说一句话，所以每个联通块最多只有一个简单环 考虑环内如果只有一条边表示说别人是狼，那么那个人就一定是狼 此外，所有说狼是村民的人都是狼 ​ 当成2-SAT想了好久…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxe=maxn;int tst,n,fa[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxn];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;char s[20];int stk[maxn],dfn[maxn],low[maxn],times,SCC,to[maxn],sum[maxn],who[maxn],num[maxn];bool instk[maxn];void Tarjan(int x)&#123; dfn[x]=low[x]=++times; instk[stk[++stk[0]]=x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]); else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (low[x]==dfn[x])&#123; SCC++; while (stk[stk[0]+1]!=x) to[stk[stk[0]]]=SCC,instk[stk[stk[0]--]]=0; &#125;&#125;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); tot=0;cl(lnk,0); for (int i=1,x;i&lt;=n;i++) scanf(\"%d%s\",&amp;x,s),add(i,x,s[0]=='w'); cl(dfn,0);cl(instk,0);times=SCC=0;stk[0]=0; for (int i=1;i&lt;=n;i++) if (!dfn[i]) Tarjan(i); cl(sum,0); cl(num,0); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (to[i]==to[son[j]]&amp;&amp;w[j]==1) sum[to[i]]++,who[to[i]]=son[j];else if (to[i]!=to[son[j]]&amp;&amp;w[j]==0) fa[getfa(i)]=getfa(son[j]); for (int i=1;i&lt;=n;i++) num[getfa(i)]++; int ans=0; for (int i=1;i&lt;=SCC;i++) if (sum[i]==1) ans+=num[who[i]]; printf(\"0 %d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ3513 [MUTC2013]idiots","slug":"BZOJ3513","date":"2018-08-07T11:46:53.000Z","updated":"2018-08-07T12:01:48.000Z","comments":true,"path":"posts/BZOJ3513/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3513/","excerpt":"","text":"题面在这里 ​ 设\\(s_i\\)表示长度为\\(i\\)的木棒数，\\(f_i\\)表示选择两根木棒长度为\\(i\\)的方案数 则有： \\[ f_i=\\sum_{j=0}^i s_j s_{i-j} \\] 这个可以FFT直接求卷积 然后发现这个其实还是有一些小瑕疵的，然后修正\\(f_i\\)： \\[ \\begin{equation} \\left\\{ \\begin{array}{lr} f_i=\\frac{f_i}2, &amp; i为奇数 \\\\ f_i=\\frac{f_i-s_{i/2}^2}2 +\\binom{s_{i/2}}2,&amp; i为偶数 \\end{array} \\right. \\end{equation} \\] 再补集转化以下，求\\(\\sum_i f_i\\times \\sum_{j=i}^{maxa_i}sj\\)就好了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;const double PI=acos(-1);int tst,n,N,a[maxn],s[maxn],g[maxn];struct comp&#123; double r,i; comp (double _r=0,double _i=0):r(_r),i(_i) &#123;&#125; comp operator+(const comp&amp;b) &#123;return comp(r+b.r,i+b.i);&#125; comp operator-(const comp&amp;b) &#123;return comp(r-b.r,i-b.i);&#125; comp operator*(const comp&amp;b) &#123;return comp(r*b.r-i*b.i,r*b.i+i*b.r);&#125;&#125;S[maxn*4],F[maxn*4];int rev[maxn*4];inline void get_rev(int n) &#123;for (int i=1,l=log2(n);i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125;void FFT(comp *a,int n,int d)&#123; for (int i=0;i&lt;n;i++) if (rev[i]&lt;i) swap(a[rev[i]],a[i]); for (int l=2;l&lt;=n;l&lt;&lt;=1)&#123; comp wl(cos(2*PI/l),d*sin(2*PI/l)); int tj=l&gt;&gt;1; for (int k=0;k&lt;n;k+=l)&#123; comp w(1,0),_t,_T; for (int j=0;j&lt;tj;j++,w=w*wl) _t=a[k+j],_T=w*a[k+j+tj],a[k+j]=_t+_T,a[k+j+tj]=_t-_T; &#125; &#125; if (d&lt;0) for (int i=0;i&lt;n;i++) a[i].r/=n;&#125;#define C2(x) ((ll)x*(x-1)/2)int main()&#123; tst=red(); N=1;while (N&lt;=2e5) N&lt;&lt;=1; get_rev(N); while (tst--)&#123; n=red(); cl(S,0);cl(s,0); for (int i=1;i&lt;=n;i++) a[i]=red(),s[a[i]]++,S[a[i]].r++; for (int i=1e5;i;i--) g[i]=g[i+1]+s[i]; FFT(S,N,1); for (int i=0;i&lt;N;i++) F[i]=S[i]*S[i]; FFT(F,N,-1); double ans=0; for (int i=1;i&lt;=1e5;i++) if (i&amp;1) ans+=(ll)(F[i].r+0.5)/2*g[i]; else ans+=(((ll)(F[i].r+0.5)-(ll)s[i/2]*s[i/2])/2+C2(s[i/2]))*g[i]; printf(\"%.7lf\\n\",1-ans*6/n/(n-1)/(n-2)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"FFT","slug":"FFT","permalink":"http://oi.linkfqy.top/tags/FFT/"}]},{"title":"FFT快速傅里叶变换_remake","slug":"FFT_remake","date":"2018-08-06T12:59:48.000Z","updated":"2018-08-06T14:11:02.000Z","comments":true,"path":"posts/FFT_remake/","link":"","permalink":"http://oi.linkfqy.top/posts/FFT_remake/","excerpt":"快速傅里叶变换（Fast Fourier Transform, FFT） 可以在\\(O(nlogn)\\)的时间计算多项式乘法 或运用于计算卷积","text":"快速傅里叶变换（Fast Fourier Transform, FFT） 可以在\\(O(nlogn)\\)的时间计算多项式乘法 或运用于计算卷积 ​ 多项式的表示 系数表示 一个次数界为\\(degA=n\\)的多项式\\(A(x)\\)可以表示为： \\[ A(x)=\\sum_{i=0}^{n-1}a_i x^i \\] 那么两个多项式\\(A(x)\\)和\\(B(x)\\)的乘积可以表示为： \\[ C(x)=A(x)B(x)=\\sum_{i=0}^{2n-2}c_i x^i \\\\ 其中c_i=\\sum_{j=0}^i a_jb_{i-j} \\] 可以发现，多项式乘法其实就是对系数向量做卷积，所以FFT解决多项式乘法的同时也求出了卷积 点值表示 对于一个次数界为\\(n\\)的多项式\\(A(x)\\)，我们用\\(n\\)个值代入，得到\\(n\\)个点： \\[ \\{ (x_0,y_0),(x_1,y_1),\\dots ,(x_{n-1},y_{n-1}) \\} \\] 显然这\\(n\\)个点能唯一确定一个次数界为\\(n\\)的多项式 这就为多项式的系数表示和点值表示互相转化提供了可能 点值表示可以非常方便地求多项式乘法： 对于多项式A\\(\\{ (x_0,y_0),(x_1,y_1),\\dots ,(x_{n-1},y_{n-1}) \\}\\)和B\\(\\{ (x_0,y&#39;_0),(x_1,y&#39;_1),\\dots ,(x_{n-1},y&#39;_{n-1}) \\}\\) 其乘积为\\(\\{ (x_0,y_0y&#39;_0),(x_1,y_1y&#39;_1),\\dots ,(x_{n-1},y_{n-1}y&#39;_{n-1}) \\}\\) FFT的过程 如图所示： 用DFT将多项式的系数表示转化为点值表示（求值） 用点值表示\\(O(n)\\)求乘积 最后用IDFT转回系数表示（插值） DFT,IDFT 前置知识：单位复数根 n次单位复数根是满足\\(\\omega ^n=1\\)的复数\\(\\omega\\) 显然n次单位复数根恰好有n个 根据复数的指数形式定义： \\[ e^{iu}=cos(u)+i\\times sin(u) \\] 以及复数单位根在复平面下的几何意义： 可以得到如下引理： 消去引理：对任何整数\\(n\\ge 0,k\\ge 0\\)以及\\(d\\gt 0\\)，有\\(\\omega _{dn}^{dk}=\\omega _n^k\\) 折半引理：如果\\(n\\gt 0\\)为整数，则n个n次单位复数根的平方构成的集合就是n/2个n/2次单位复数根的平方的集合 求和引理：对任意整数\\(n\\ge 1\\)和不能被n整数的非负整数k，有\\(\\sum_{j=0}^{n-1}(\\omega _n^k)^j=0\\) DFT 我们使用n个n次单位复数根\\(\\omega _n^i\\)作为点值表示的\\(x_i\\) 由于单位复数根的性质，使得我们可以分治处理问题 为方便起见，以下均假设n为2的整次幂 ​ 对于多项式\\(A(x)=a_0x^0+a_1x^1+a_2x^2……a_{n-1}x^{n-1}\\) 我们构造两个新的多项式\\(A^{[0]}(x)\\)和\\(A^{[1]}(x)\\)： \\[ A^{[0]}(x)=a_0x^0+a_2x^1+a_4x^2+……+a_{n-2}x^{n/2-1} \\\\ A^{[1]}(x)=a_1x^0+a_3x^1+a_5x^2+……+a_{n-1}x^{n/2-1} \\] 显然有： \\[ A(x)=A^{[0]}(x^2)+xA^{[1]}(x^2) \\] 那么就转化成了一半规模的子问题： 考虑\\(k=0,1,2……n/2-1\\) \\[ A(\\omega _n^k)=A^{[0]}(\\omega _n^{2k})+\\omega _n^kA^{[1]}(\\omega _n^{2k}) =A^{[0]}(\\omega _{n/2}^k)+\\omega _n^kA^{[1]}(\\omega _{n/2}^k) \\\\ A(\\omega _n^{k+n/2})=A^{[0]}(\\omega _n^{2k+n})+\\omega _n^{k+n/2}A^{[1]}(\\omega _n^{2k+n}) =A^{[0]}(\\omega _{n/2}^k)-\\omega _n^kA^{[1]}(\\omega _{n/2}^k) \\] 也就是说，只需要求出\\(A^{[0]}(\\omega _{n/2}^k)\\)和\\(A^{[1]}(\\omega _{n/2}^k)\\)就可以求出\\(A(x)\\) 特殊地，当n=1时，\\(A(x)\\)的点值表示就是\\(a_0\\) ​ 这样我们就可以递归实现DFT了，时间复杂度\\(O(nlogn)\\) IDFT 把DFT写成矩阵乘法\\(y=V_na\\) 对矩阵\\(V_n\\)求逆，可以得到\\(DFT^{-1}_n(y)\\)： \\[ a_j=\\frac 1 n\\sum_{k=0}^{n-1}y_k\\omega_n^{-kj} \\] 这和点值表示的定义非常相似： \\[ y_k=\\sum_{j=0}^{n-1}a_jx^j=\\sum_{j=0}^{n-1}a_j\\omega^{jk} \\] 于是DFT的方法完全适用于IDFT 即用\\(\\omega^{-1}_n\\)代替\\(\\omega_n\\),计算结果每一项除以n 于是我们得到了\\(O(nlogn)\\)求\\(DFT^{-1}_n\\)的算法 迭代实现DFT 考虑递归的过程： 发现我们只需要知道每个元素最后在什么位置，然后一层层向上合并答案就好了 考虑按奇偶分类的过程，其实这是一棵01Trie，只是低位的优先级更高 那么每个元素的位置就是其二进制位倒过来 可以用如下代码\\(O(n)\\)求出每个元素最后的位置： 1234void get_rev(int n)&#123; rev[0]=0;int l=log2(n); for (int i=1;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125; 模板，例题 例题： UOJ#34 BZOJ2179 BZOJ2194 HDU1402 BZOJ3527 板子： 123456789101112131415161718192021struct comp&#123; double r,i; comp(double _r=0,double _i=0):r(_r),i(_i) &#123;&#125; comp operator+(const comp&amp;b) &#123;return comp(r+b.r,i+b.i);&#125; comp operator-(const comp&amp;b) &#123;return comp(r-b.r,i-b.i);&#125; comp operator*(const comp&amp;b) &#123;return comp(r*b.r-i*b.i,r*b.i+i*b.r);&#125;&#125;;int rev[maxn];inline void get_rev(int n) &#123;for (int i=1,l=log2(n);i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125;void FFT(comp *a,int n,int d)&#123; for (int i=0;i&lt;n;i++) if (rev[i]&lt;i) swap(a[i],a[rev[i]]); for (int l=2;l&lt;=n;l&lt;&lt;=1)&#123; comp wl(cos(2*PI/l),d*sin(2*PI/l)); for (int k=0;k&lt;n;k+=l)&#123; comp w(1,0),_t,_T; for (int j=0,tj=l&gt;&gt;1;j&lt;tj;j++,w=w*wl) _t=a[k+j],_T=w*a[k+j+tj],a[k+j]=_t+_T,a[k+j+tj]=_t-_T; &#125; &#125; if (d&lt;0) for (int i=0;i&lt;n;i++) a[i].r/=n;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[]},{"title":"BZOJ3527 [Zjoi2014]力","slug":"BZOJ3527","date":"2018-08-06T12:43:48.000Z","updated":"2018-08-06T12:53:00.000Z","comments":true,"path":"posts/BZOJ3527/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3527/","excerpt":"","text":"题面在这里 ​ 令\\(g_i=\\frac 1 {i^2},g_0=0\\)直接推柿子： \\[ E_i=\\sum_{j=0}^i q_jg_{i-j}-\\sum_{j=i}^n q_jg_{i-j} \\] 发现前面是标准的卷积\\(C_i\\)，后面再处理一下： \\[ \\sum_{j=i}^n q_jg_{i-j} \\\\ =\\sum_{j=0}^{n-i} q_{n-j}g_{i-n+j} \\\\ D_i=\\sum_{j=0}^t q&#39;_jg_{t-j} \\] 其中\\(q&#39;_i=q_{n-i},t=n-i\\) 那么答案就是\\(C_i-D{n-i}\\) ​ 注意卷积的长度是\\(2n+1\\)而不是\\(n\\)，调了好久…… ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=400005;const double PI=3.1415926535897932384626433832795;int n,N; double q[maxn];struct comp&#123; double r,i; comp(double _r=0,double _i=0):r(_r),i(_i) &#123;&#125; comp operator+(const comp&amp;b) &#123;return comp(r+b.r,i+b.i);&#125; comp operator-(const comp&amp;b) &#123;return comp(r-b.r,i-b.i);&#125; comp operator*(const comp&amp;b) &#123;return comp(r*b.r-i*b.i,r*b.i+i*b.r);&#125;&#125;Q[maxn],G[maxn],C[maxn],D[maxn];int rev[maxn];inline void get_rev(int n) &#123;for (int i=1,l=log2(n);i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125;void FFT(comp *a,int n,int d)&#123; for (int i=0;i&lt;n;i++) if (rev[i]&lt;i) swap(a[i],a[rev[i]]); for (int l=2;l&lt;=n;l&lt;&lt;=1)&#123; comp wl(cos(2*PI/l),d*sin(2*PI/l)); for (int k=0;k&lt;n;k+=l)&#123; comp w(1,0),_t,_T; for (int j=0,tj=l&gt;&gt;1;j&lt;tj;j++,w=w*wl) _t=a[k+j],_T=w*a[k+j+tj],a[k+j]=_t+_T,a[k+j+tj]=_t-_T; &#125; &#125; if (d&lt;0) for (int i=0;i&lt;n;i++) a[i].r/=n;&#125;int main()&#123; scanf(\"%d\",&amp;n); N=1;while (N&lt;=n) N&lt;&lt;=1;N&lt;&lt;=1; for (int i=1;i&lt;=n;i++) scanf(\"%lf\",&amp;q[i]),Q[i].r=q[i],G[i].r=1.0/i/i; get_rev(N); FFT(Q,N,1);FFT(G,N,1); for (int i=0;i&lt;N;i++) C[i]=Q[i]*G[i]; cl(Q,0); for (int i=0;i&lt;=n;i++) Q[i]=comp(q[n-i],0); FFT(Q,N,1); for (int i=0;i&lt;N;i++) D[i]=Q[i]*G[i]; FFT(C,N,-1); FFT(D,N,-1); for (int i=1;i&lt;=n;i++) printf(\"%.3lf\\n\",C[i].r-D[n-i].r); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"FFT","slug":"FFT","permalink":"http://oi.linkfqy.top/tags/FFT/"}]},{"title":"【点分治+FFT】BZOJ3451 Tyvj1953 Normal","slug":"BZOJ3451","date":"2018-08-05T14:27:02.000Z","updated":"2018-08-05T14:38:30.000Z","comments":true,"path":"posts/BZOJ3451/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3451/","excerpt":"","text":"题面在这里 ​ 由于期望的线性性，考虑每个子树\\(size\\)的期望和 这个总和一定等于每个节点\\(deep\\)的期望和 把i做根，j的深度的期望记为\\(deep_{i,j}\\)，则最终答案为\\(\\sum_i \\sum_j deep_{i,j}\\) 只有当i到j路径上所有点中，i是第一个被做为根时，才会对\\(deep_{i,j}\\)有1的贡献 那么\\(\\sum_i \\sum_j deep_{i,j}=\\sum_i \\sum_j \\frac 1 {dist_{i,j}+1}\\) 只要求出距离为\\(k=1,2..\\)的点对数就得到答案了 这个是典型的点分治+FFT套路 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;const double PI=3.1415926535897932384626433832795;int n; double S[maxn];int tot,lnk[maxn],son[maxn],nxt[maxn];inline void add(int x,int y) &#123;son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct comp&#123; double r,i; comp (double _r=0,double _i=0):r(_r),i(_i) &#123;&#125; comp operator + (const comp&amp;b) &#123;return comp(r+b.r,i+b.i);&#125; comp operator - (const comp&amp;b) &#123;return comp(r-b.r,i-b.i);&#125; comp operator * (const comp&amp;b) &#123;return comp(r*b.r-i*b.i,r*b.i+i*b.r);&#125; comp operator / (const double&amp;b) &#123;return comp(r/b,i/b);&#125; &#125;A[262145];int rev[262145];void get_rev(int n)&#123; rev[0]=0;int l=log2(n); for (int i=1;i&lt;n;i++) rev[i]=(rev[i&gt;&gt;1]&gt;&gt;1)|((i&amp;1)&lt;&lt;l-1);&#125;void FFT(comp *a,int n,int d)&#123; for (int i=0;i&lt;n;i++) if (rev[i]&lt;i) swap(a[i],a[rev[i]]); for (int l=2;l&lt;=n;l&lt;&lt;=1)&#123; comp wl(cos(2*PI/l),d*sin(2*PI/l)); for (int k=0;k&lt;n;k+=l)&#123; comp w(1,0),_t,_T; for (int j=0,tj=l&gt;&gt;1;j&lt;tj;j++,w=w*wl) _t=a[k+j],_T=w*a[k+j+tj],a[k+j]=_t+_T,a[k+j+tj]=_t-_T; &#125; &#125; if (d&lt;0) for (int i=0;i&lt;n;i++) a[i]=a[i]/n;&#125;int rot,sum,siz[maxn],f[maxn],dep[maxn],val[maxn];bool vis[maxn];void calc(int Miu)&#123; int mx=0,n=1; for (int i=1;i&lt;=tot;i++) mx=max(mx,val[i]); while (n&lt;=(mx&lt;&lt;1)) n&lt;&lt;=1;get_rev(n); for (int i=0;i&lt;n;i++) A[i]=(0,0); for (int i=1;i&lt;=tot;i++) A[val[i]].r++; FFT(A,n,1); for (int i=0;i&lt;n;i++) A[i]=A[i]*A[i]; FFT(A,n,-1); for (int i=0;i&lt;=mx&lt;&lt;1;i++) S[i]+=Miu*A[i].r;&#125;void getrot(int x,int fa)&#123; siz[x]=1;f[x]=0; for (int j=lnk[x];j;j=nxt[j])&#123; if (vis[son[j]]||son[j]==fa) continue; getrot(son[j],x); siz[x]+=siz[son[j]]; f[x]=max(f[x],siz[son[j]]); &#125; f[x]=max(f[x],sum-siz[x]); if (f[x]&lt;f[rot]) rot=x;&#125;void dfs(int x,int fa)&#123; val[++tot]=dep[x];siz[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]]&amp;&amp;son[j]!=fa) dep[son[j]]=dep[x]+1,dfs(son[j],x),siz[x]+=siz[son[j]];&#125;void solve(int x)&#123; dep[x]=tot=0;dfs(x,0);calc(1);vis[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!vis[son[j]])&#123; rot=0; sum=siz[son[j]]; dep[son[j]]=1; tot=0; dfs(son[j],0); calc(-1); sum=siz[son[j]]; rot=0; getrot(son[j],0); solve(rot); &#125;&#125;int main()&#123; n=red(); for (int i=1,x,y,z;i&lt;n;i++) x=red()+1,y=red()+1,add(x,y),add(y,x); dep[0]=-1; f[0]=2e9; sum=n; getrot(1,0); solve(rot); double ans=0; for (int i=0;i&lt;n;i++) ans+=S[i]/(i+1); printf(\"%.4lf\\n\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"点分治","slug":"点分治","permalink":"http://oi.linkfqy.top/tags/点分治/"},{"name":"FFT","slug":"FFT","permalink":"http://oi.linkfqy.top/tags/FFT/"}]},{"title":"【kruskal重构树+dfs序上主席树】BZOJ3551 [ONTAK2010]Peaks加强版","slug":"BZOJ3551","date":"2018-08-04T13:04:51.000Z","updated":"2018-08-04T13:07:40.000Z","comments":true,"path":"posts/BZOJ3551/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3551/","excerpt":"","text":"题面在这里 ​ BZOJ3545强制在线版。 考虑\\(\\text{kruskal}\\)重构树，答案就是子树内第k大 直接在dfs序上跑主席树就好了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=200005,maxe=500005,maxs=7000005;int n,N,m,e,q,h[maxn],b[maxn],val[maxn],fa[maxn];struct edge&#123; int x,y,w; bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int tot,son[maxe],nxt[maxn],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int times,in[maxn],out[maxn],id[maxn],f[maxn][20];void dfs(int x)&#123; in[x]=++times;id[times]=x; for (int j=lnk[x];j;j=nxt[j]) f[son[j]][0]=x,dfs(son[j]); out[x]=times;&#125;int Rot[maxn],tre[maxs],s[maxs][2],len;inline void pushup(int x) &#123;tre[x]=tre[s[x][0]]+tre[s[x][1]];&#125;int build(int l,int r)&#123; int x=++len; tre[x]=0; if (l==r) &#123;s[x][0]=s[x][1]=0;return x;&#125; int mid=l+r&gt;&gt;1; s[x][0]=build(l,mid); s[x][1]=build(mid+1,r); return x;&#125;int ist(int fa,int l,int r,int k)&#123; int x=++len; tre[x]=tre[fa];s[x][0]=s[fa][0];s[x][1]=s[fa][1]; if (l==r) return tre[x]++,x; int mid=l+r&gt;&gt;1; if (k&lt;=mid) s[x][0]=ist(s[fa][0],l,mid,k); else s[x][1]=ist(s[fa][1],mid+1,r,k); return pushup(x),x;&#125;int qry(int x,int y,int l,int r,int k)&#123; if (tre[y]-tre[x]&lt;k) return -1; if (l==r) return -b[l]; int mid=l+r&gt;&gt;1,tem; if ((tem=tre[s[y][0]]-tre[s[x][0]])&gt;=k) return qry(s[x][0],s[y][0],l,mid,k); else return qry(s[x][1],s[y][1],mid+1,r,k-tem);&#125;int main()&#123; N=n=red(),e=red(),q=red(); for (int i=1;i&lt;=n;i++) b[i]=h[i]=-red(); sort(b+1,b+1+n); m=unique(b+1,b+1+n)-b-1; for (int i=1,x,y,z;i&lt;=e;i++) a[i].x=red(),a[i].y=red(),a[i].w=red(); sort(a+1,a+1+e); for (int i=1;i&lt;=(n&lt;&lt;1);i++) fa[i]=i; for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y))&#123; val[++N]=a[i].w; add(N,getfa(a[i].x)); add(N,getfa(a[i].y)); fa[getfa(a[i].x)]=N; fa[getfa(a[i].y)]=N; &#125; f[N][0]=N;dfs(N); for (int j=1;j&lt;20;j++) for (int i=1;i&lt;=N;i++) f[i][j]=f[f[i][j-1]][j-1]; Rot[0]=build(1,m); for (int i=1;i&lt;=N;i++) if (id[i]&lt;=n) Rot[i]=ist(Rot[i-1],1,m,lower_bound(b+1,b+1+m,h[id[i]])-b); else Rot[i]=Rot[i-1]; int lastans=-1; for (int i=1;i&lt;=q;i++)&#123; int v=red(),x=red(),k=red(); if (lastans!=-1) v^=lastans,x^=lastans,k^=lastans; for (int j=19;j&gt;=0;j--) if (val[f[v][j]]&lt;=x) v=f[v][j]; printf(\"%d\\n\",lastans=qry(Rot[in[v]-1],Rot[out[v]],1,m,k)); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"主席树","slug":"主席树","permalink":"http://oi.linkfqy.top/tags/主席树/"},{"name":"kruskal重构树","slug":"kruskal重构树","permalink":"http://oi.linkfqy.top/tags/kruskal重构树/"}]},{"title":"BZOJ3040 最短路(road)","slug":"BZOJ3040","date":"2018-08-04T08:08:47.000Z","updated":"2018-08-04T08:09:58.000Z","comments":true,"path":"posts/BZOJ3040/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3040/","excerpt":"","text":"题面在这里 ​ 优先队列优化\\(\\text{Dijkstra}\\)竟然5988ms卡过了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005,maxe=10000005;int n,e,T,rxa,rxc,rya,ryc,rp;int tot,nxt[maxe],son[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;ll dst[maxn]; bool vis[maxn];struct data&#123; ll d;int id; data () &#123;&#125; data (int _id,ll _d):id(_id),d(_d) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return d&gt;b.d;&#125;&#125;;priority_queue&lt;data&gt; H;void DIJ()&#123; cl(dst,63); dst[1]=0;H.push(data(1,0)); while (!H.empty())&#123; data k=H.top();H.pop(); if (vis[k.id]) continue; vis[k.id]=1;if (k.id==n) return; for (int j=lnk[k.id];j;j=nxt[j]) if (!vis[son[j]]&amp;&amp;dst[son[j]]&gt;dst[k.id]+w[j]) dst[son[j]]=dst[k.id]+w[j],H.push(data(son[j],dst[son[j]])); &#125;&#125;int main()&#123; n=red(),e=red(); T=red();rxa=red(),rxc=red(),rya=red(),ryc=red();rp=red(); for (int i=1,x=0,y=0,z=0;i&lt;=T;i++)&#123; x=(x*rxa+rxc)%rp; y=(y*rya+ryc)%rp; int a=min(x%n+1,y%n+1),b=max(y%n+1,y%n+1); add(a,b,1e8-100*a); &#125; for (int i=T+1,x,y,z;i&lt;=e;i++) x=red(),y=red(),z=red(),add(x,y,z); DIJ(); printf(\"%lld\",dst[n]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"【kruskal重构树】BZOJ5415 [Noi2018]归程","slug":"BZOJ5415","date":"2018-08-03T13:49:52.000Z","updated":"2018-08-03T14:08:56.000Z","comments":true,"path":"posts/BZOJ5415/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ5415/","excerpt":"","text":"题面在这里 ​ 要求所有\\(h_i\\gt p\\)的边构成的子图中，v所在联通块到的1最近距离 这题可以直接可持久化并查集艹过去 然而还是\\(\\text{kruskal}\\)重构树更巧妙一些 ​ \\(\\text{kruskal}\\)重构树：做\\(\\text{kruskal}\\)合并两个联通块时，建立一个父节点与两个联通块相连得到的树，点权是连接两个联通块的边权 这样就把边的优先级等信息表示出来了，使得它有很好的性质： 是一棵二叉树，每个叶子节点代表生成树的点，非叶子节点代表生成树的边 满足堆性质 原图两点最小 路径最长边\\(\\rightarrow\\)生成树上路径最长边\\(\\rightarrow\\text{kruskal}\\)重构树上LCA 这题只要知道有堆性质就可以了 按海拔从大到小做\\(\\text{kruskal}\\)重构树，考虑一个节点的子树海拔一定大于自己 那么倍增向上找到不被淹没的最低边，子树内最小\\(dist_{x,1}\\)就是答案 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include&lt;cstdio&gt;#include&lt;queue&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=400005,maxe=1200005;int tst,n,e,q,N,K,S;int tot,lnk[2][maxn],nxt[maxe],son[maxe],w[maxe];inline void add(int x,int y,int z,int id)&#123; son[++tot]=y;nxt[tot]=lnk[id][x];lnk[id][x]=tot;w[tot]=z;&#125;struct edge&#123; int x,y,w,h; bool operator&lt;(const edge&amp;b)const &#123;return h&gt;b.h;&#125;&#125;a[maxe];int dst[maxn];bool vis[maxn];struct data&#123; int x,d; data () &#123;&#125; data (int _x,int _d):x(_x),d(_d) &#123;&#125; bool operator&lt;(const data&amp;b)const &#123;return d&gt;b.d;&#125;&#125;;priority_queue&lt;data&gt; H;void DIJ()&#123; while (!H.empty()) H.pop(); cl(dst,0x7f);cl(vis,0); dst[1]=0;H.push(data(1,0)); while (!H.empty())&#123; data k=H.top();H.pop(); if (vis[k.x]) continue; vis[k.x]=1; for (int j=lnk[0][k.x];j;j=nxt[j]) if (!vis[son[j]]&amp;&amp;dst[son[j]]&gt;dst[k.x]+w[j]) dst[son[j]]=dst[k.x]+w[j],H.push(data(son[j],dst[son[j]])); &#125;&#125;int fa[maxn],f[maxn][20],val[maxn],MIN[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;void kruskal()&#123; sort(a+1,a+1+e); N=n; cl(val,0); for (int i=1;i&lt;=(n&lt;&lt;1);i++) fa[i]=i; for (int i=1;i&lt;=e;i++) if (getfa(a[i].x)!=getfa(a[i].y))&#123; val[++N]=a[i].h; add(N,getfa(a[i].x),0,1); add(N,getfa(a[i].y),0,1); fa[getfa(a[i].x)]=N; fa[getfa(a[i].y)]=N; &#125;&#125;void dfs(int x)&#123; MIN[x]=dst[x]; for (int j=lnk[1][x];j;j=nxt[j]) f[son[j]][0]=x,dfs(son[j]),MIN[x]=min(MIN[x],MIN[son[j]]);&#125;void DP()&#123; for (int j=1;j&lt;20;j++) for (int i=1;i&lt;=N;i++) f[i][j]=f[f[i][j-1]][j-1];&#125;int main()&#123; tst=red(); while (tst--)&#123; n=red(),e=red(); tot=0;cl(lnk,0); for (int i=1;i&lt;=e;i++)&#123; a[i].x=red(),a[i].y=red(),a[i].w=red(),a[i].h=red(); add(a[i].x,a[i].y,a[i].w,0);add(a[i].y,a[i].x,a[i].w,0); &#125; DIJ(); kruskal(); f[N][0]=N; dfs(N); DP(); q=red(),K=red(),S=red();int lastans=0; for (int i=1,x,h;i&lt;=q;i++)&#123; x=(red()+K*lastans%n-1)%n+1,h=(red()+K*lastans%(S+1))%(S+1); for (int j=19;j&gt;=0;j--) if (val[f[x][j]]&gt;h) x=f[x][j]; printf(\"%d\\n\",lastans=MIN[x]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"},{"name":"kruskal重构树","slug":"kruskal重构树","permalink":"http://oi.linkfqy.top/tags/kruskal重构树/"}]},{"title":"【LCT动态kruskal】BZOJ2594 [Wc2006]水管局长数据加强版","slug":"BZOJ2594","date":"2018-08-03T11:49:48.000Z","updated":"2018-08-03T11:55:56.000Z","comments":true,"path":"posts/BZOJ2594/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2594/","excerpt":"","text":"题面在这里 ​ 要求两点间最小的路径最大值 显然这个值一定出现在最小生成树上 然后有删边的操作，不太好搞 就离线倒着做变成加边，用LCT动态维护生成树 如果加进来的边构成环，就把环上最大边删掉 还有一个问题是LCT不太好维护边权 解决办法是把边拆成一个带点权的点和两条边 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxe=1000005,maxs=maxn+maxe;int n,e,q;struct edge&#123; int x,y,w,id; edge () &#123;&#125; edge (int _x,int _y):x(_x),y(_y) &#123;&#125; bool operator&lt;(const edge&amp;b)const &#123;return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y;&#125;&#125;a[maxe];inline bool cmpw(const edge&amp;a,const edge&amp;b) &#123;return a.w&lt;b.w;&#125;inline bool cmpid(const edge&amp;a,const edge&amp;b) &#123;return a.id&lt;b.id;&#125;struct query&#123; int x,y,type;&#125;Q[maxn]; bool vis[maxe];//LCTint fa[maxs],s[maxs][2],ID[maxs],mx[maxs],w[maxs];bool flp[maxs];#define isroot(x) (s[fa[x]][0]!=x&amp;&amp;s[fa[x]][1]!=x)inline void addflip(int x) &#123;flp[x]^=1;swap(s[x][0],s[x][1]);&#125;inline void pushup(int x)&#123; ID[x]=x;mx[x]=w[x]; if (mx[s[x][0]]&gt;mx[x]) ID[x]=ID[s[x][0]],mx[x]=mx[s[x][0]]; if (mx[s[x][1]]&gt;mx[x]) ID[x]=ID[s[x][1]],mx[x]=mx[s[x][1]];&#125;inline void pushdown(int x) &#123;if (flp[x]) flp[x]^=1,addflip(s[x][0]),addflip(s[x][1]);&#125;inline void rotate(int x)&#123; int f=fa[x],g=fa[f],d=s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; pushup(f); s[x][d]=f; fa[f]=x; pushup(x);&#125;int stk[maxs],top;inline void splay(int x)&#123; stk[top=1]=x; for (int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x))&#123; int f=fa[x],g=fa[f],d=s[f][0]==x,dd=s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x);else rotate(x),rotate(x); else rotate(x); &#125;&#125;inline void access(int x) &#123;for (int t=0;x;t=x,x=fa[x]) splay(x),s[x][1]=t,pushup(x);&#125;inline void mr(int x) &#123;access(x);splay(x);addflip(x);&#125;inline void cut(int x,int y) &#123;mr(x);access(y);splay(y);fa[x]=s[y][0]=0;/*printf(\"cut:%d %d\\n\",x,y);*/&#125;inline void join(int x,int y) &#123;mr(x);fa[x]=y;/*printf(\"link:%d %d\\n\",x,y);*/&#125;inline int getrt(int x) &#123;access(x);splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125;int fat[maxn],ans[maxn];inline int getfa(int x) &#123;return fat[x]==x?x:fat[x]=getfa(fat[x]);&#125;inline void add(edge&amp;E)&#123; if (getrt(E.x)==getrt(E.y))&#123; mr(E.x);access(E.y);splay(E.y); int id=ID[E.y]; if (w[id]&lt;=E.w) return; cut(id,a[id-n].x);cut(id,a[id-n].y); &#125; int id=E.id+n; mx[id]=w[id]=E.w;ID[id]=id; join(id,E.x);join(id,E.y);&#125;int main()&#123; n=red(),e=red(),q=red(); for (int i=1;i&lt;=e;i++)&#123; a[i].x=red(),a[i].y=red(),a[i].w=red();a[i].id=i; if (a[i].x&gt;a[i].y) swap(a[i].x,a[i].y); &#125; sort(a+1,a+1+e); for (int i=1;i&lt;=q;i++)&#123; Q[i].type=red(); int x=red(),y=red(); if (x&gt;y) swap(x,y); if (Q[i].type==1) Q[i].x=x,Q[i].y=y; else Q[i].x=(*lower_bound(a+1,a+1+e,edge(x,y))).id,vis[Q[i].x]=1; &#125; sort(a+1,a+1+e,cmpw); for (int i=1;i&lt;=n;i++) fat[i]=i,ID[i]=i; for (int i=1;i&lt;=e;i++) if (!vis[a[i].id]) if (getfa(a[i].x)==getfa(a[i].y)) vis[a[i].id]=1;else fat[getfa(a[i].x)]=getfa(a[i].y); sort(a+1,a+1+e,cmpid); for (int i=1;i&lt;=e;i++) if (!vis[a[i].id]) add(a[i]); for (int i=q;i;i--) if (Q[i].type==1)&#123; mr(Q[i].x);access(Q[i].y);splay(Q[i].y); ans[++ans[0]]=mx[Q[i].y]; &#125;else add(a[Q[i].x]); for (int i=ans[0];i&gt;=1;i--) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"},{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"}]},{"title":"【dsu on tree+hash】Codeforces 246E Blood Cousins Return","slug":"CF246E","date":"2018-08-02T05:21:03.000Z","updated":"2018-08-02T05:23:28.000Z","comments":true,"path":"posts/CF246E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF246E/","excerpt":"","text":"题面在这里 ​ 经典\\(\\text{dsu on tree}\\)，不解释 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;cstdio&gt;#include&lt;map&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;typedef unsigned long long ull;const int maxn=100005,maxe=100005;const ull MOD=499999999999993L;int n,q,ans[maxn]; char s[maxn]; ull w[maxn];int tot,lnk[maxn],son[maxe],nxt[maxe];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;struct data&#123; int dep,id; data () &#123;&#125; data (int _x,int _y):dep(_x),id(_y) &#123;&#125;&#125;;vector&lt;data&gt; V[maxn];int dep[maxn],wt[maxn],H_son[maxn];void getH(int x)&#123; wt[x]=1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j])&#123; dep[son[j]]=dep[x]+1; getH(son[j]); wt[x]+=wt[son[j]]; if (!H_son[x]||wt[H_son[x]]&lt;wt[son[j]]) H_son[x]=son[j]; &#125;&#125;map&lt;ull,int&gt; cnt[maxn];int num[maxn*2];bool xH[maxn];void change(int x,int W)&#123; if (cnt[dep[x]][w[x]]==0) num[dep[x]]++; cnt[dep[x]][w[x]]+=W; if (cnt[dep[x]][w[x]]==0) num[dep[x]]--; for (int j=lnk[x];j;j=nxt[j]) if (!xH[son[j]]) change(son[j],W);&#125;void dsu(int x,bool keep)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=H_son[x]) dsu(son[j],0); if (H_son[x]) dsu(H_son[x],1),xH[H_son[x]]=1; change(x,1); xH[H_son[x]]=0; for (int i=0;i&lt;V[x].size();i++)&#123; ans[V[x][i].id]=num[V[x][i].dep+dep[x]]; &#125; if (!keep) change(x,-1);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,fa;i&lt;=n;i++)&#123; scanf(\"%s%d\",s,&amp;fa); add(fa,i); for (int j=0;s[j];j++) w[i]=(w[i]*233+s[j])%MOD; &#125; scanf(\"%d\",&amp;q); for (int i=1;i&lt;=q;i++)&#123; int x,y;scanf(\"%d%d\",&amp;x,&amp;y); V[x].push_back(data(y,i)); &#125; getH(0);dsu(0,0); for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"http://oi.linkfqy.top/tags/dsu-on-tree/"}]},{"title":"dsu on tree 学习笔记","slug":"dsu_on_tree","date":"2018-08-01T13:57:21.000Z","updated":"2018-08-01T14:26:48.000Z","comments":true,"path":"posts/dsu_on_tree/","link":"","permalink":"http://oi.linkfqy.top/posts/dsu_on_tree/","excerpt":"\\(\\text{dsu on tree}\\)（树上启发式合并）是用于统计子树信息的算法。 基于CF上Arpa的那套理论 ​ 常数小，代码易写，于是学习了一下","text":"\\(\\text{dsu on tree}\\)（树上启发式合并）是用于统计子树信息的算法。 基于CF上Arpa的那套理论 ​ 常数小，代码易写，于是学习了一下 前置技能 树链剖分-重链剖分 重链/轻链的复杂度 思想 \\(\\text{dsu on tree}\\)依赖于轻重链划分 其思想是：只保留重子树的信息给祖先再利用 算法流程 \\(\\text{dsu on tree}\\)的过程可以如下描述： 处理轻子树的答案 处理重子树的答案，并保留贡献 获取轻子树对答案的贡献，得到当前点的答案 如果当前点是轻儿子，去除当前点的贡献 伪代码如下： 123456789101112void change(int x,int w)&#123; 记录x的贡献 for (int j=lnk[x];j;j=nxt[j]) if (!xH[son[j]]) change(son[j],w);&#125;void dsu(int x,bool keep)&#123; for 每个轻儿子 dsu(son,0); dsu(H_son[x],1); xH[H_son[x]]=1; change(x,1); xH[H_son[x]]=0; 更新x的答案 if (!keep) change(x,-1);&#125; 复杂度分析 这样的做法看似很暴力，其实有理有据 考虑change带来的复杂度： 只有轻儿子才会把子树信息加入父节点 重链剖分把任意根到叶子路径划分成了不超过\\(logn\\)条轻边和\\(logn\\)条重链 每个点到根路径都有不超过\\(logn\\)条轻边 也就是说，每个点被change了\\(logn\\)次 所以总复杂度是\\(O(n+nlogn)\\)的 例题 Codeforces 600E Codeforces 570D","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"http://oi.linkfqy.top/tags/dsu-on-tree/"}]},{"title":"Codeforces 570D Tree Requests","slug":"CF570D","date":"2018-08-01T13:54:49.000Z","updated":"2018-08-01T13:56:48.000Z","comments":true,"path":"posts/CF570D/","link":"","permalink":"http://oi.linkfqy.top/posts/CF570D/","excerpt":"","text":"题面在这里 ​ \\(\\text{dsu on tree}\\)练手题。 记录某深度下每种字母出现的次数即可 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;cstdio&gt;#include&lt;vector&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;inline char fstchar()&#123; char ch=nc();while (ch&lt;'a'||'z'&lt;ch) ch=nc(); return ch;&#125;const int maxn=500005,maxe=500005;int n,q,s[maxn],num[maxn][26];struct data&#123; int dep,id; data () &#123;&#125; data (int _x,int _y):dep(_x),id(_y) &#123;&#125;&#125;;bool ans[maxn];vector&lt;data&gt; V[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int dep[maxn],H_son[maxn],wt[maxn];void getH(int x)&#123; H_son[x]=0;wt[x]=1; for (int j=lnk[x];j;j=nxt[j])&#123; dep[son[j]]=dep[x]+1; getH(son[j]); wt[x]+=wt[son[j]]; if (!H_son[x]||wt[H_son[x]]&lt;wt[son[j]]) H_son[x]=son[j]; &#125;&#125;bool xH[maxn];void change(int x,int w)&#123; num[dep[x]][s[x]]+=w; for (int j=lnk[x];j;j=nxt[j]) if (!xH[son[j]]) change(son[j],w);&#125;void dsu(int x,bool keep)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=H_son[x]) dsu(son[j],0); if (H_son[x]) dsu(H_son[x],1),xH[H_son[x]]=1; change(x,1); xH[H_son[x]]=0; for (int i=0;i&lt;V[x].size();i++)&#123; int tot=0; for (int j=1;j&lt;=26;j++) if (num[V[x][i].dep][j]&amp;1) tot++; ans[V[x][i].id]=(tot&lt;=1); &#125; if (!keep) change(x,-1);&#125;int main()&#123; n=red();q=red(); for (int i=2,fa;i&lt;=n;i++) fa=red(),add(fa,i); for (int i=1;i&lt;=n;i++) s[i]=fstchar()-'a'+1; for (int i=1;i&lt;=q;i++)&#123; int x=red(),y=red(); V[x].push_back(data(y,i)); &#125; dep[1]=1;getH(1);dsu(1,0); for (int i=1;i&lt;=q;i++) puts(ans[i]?\"Yes\":\"No\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"http://oi.linkfqy.top/tags/dsu-on-tree/"}]},{"title":"Codeforces 600E Lomsat gelral","slug":"CF600E","date":"2018-08-01T13:03:52.000Z","updated":"2018-08-01T13:07:34.000Z","comments":true,"path":"posts/CF600E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF600E/","excerpt":"","text":"题面在这里 ​ \\(\\text{dsu on tree}\\)裸题 记录每种颜色出现次数的同时维护 每种出现次数的出现次数 以及颜色的和 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxe=200005;int n,c[maxn],cnt[maxn],num[maxn]; ll sum[maxn],ans[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int H_son[maxn],s[maxn],MAX;bool xH[maxn];void getH(int x,int fa)&#123; s[x]=1;H_son[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa)&#123; getH(son[j],x); s[x]+=s[son[j]]; if (!H_son[x]||s[H_son[x]]&lt;s[son[j]]) H_son[x]=son[j]; &#125;&#125;void change(int x,int fa,int w)&#123; num[cnt[c[x]]]--; sum[cnt[c[x]]]-=c[x]; cnt[c[x]]+=w; num[cnt[c[x]]]++; sum[cnt[c[x]]]+=c[x]; if (num[MAX+1]) MAX++;else if (!num[MAX]) MAX--; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa&amp;&amp;!xH[son[j]]) change(son[j],x,w);&#125;void dsu(int x,int fa,bool keep)&#123; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa&amp;&amp;son[j]!=H_son[x]) dsu(son[j],x,0); if (H_son[x]) dsu(H_son[x],x,1),xH[H_son[x]]=1; change(x,fa,1); xH[H_son[x]]=0; ans[x]=sum[MAX]; if (!keep) change(x,fa,-1);&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) c[i]=red(); for (int i=1,x,y;i&lt;n;i++) x=red(),y=red(),add(x,y),add(y,x); getH(1,0);dsu(1,0,0); for (int i=1;i&lt;=n;i++) printf(\"%I64d \",ans[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"dsu on tree","slug":"dsu-on-tree","permalink":"http://oi.linkfqy.top/tags/dsu-on-tree/"}]},{"title":"【多校2018#4】HDU6333 Problem B. Harvest of Apples","slug":"HDU6333","date":"2018-08-01T11:17:10.000Z","updated":"2018-08-01T11:25:12.000Z","comments":true,"path":"posts/HDU6333/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6333/","excerpt":"","text":"题面在这里 ​ 求\\(\\sum_{i=0}^m C_n^i\\) 其实可以用莫队搞，只需要\\(O(1)\\)实现\\(n\\pm1\\)和\\(m\\pm1\\)就好了 方法如下： \\[ \\sum_{i=0}^{m+1} C_n^i=\\sum_{i=0}^m C_n^i + C_n^{m+1} \\\\ \\sum_{i=0}^m C_{n+1}^i=\\sum_{i=0}^m (C_n^i+C_n^{i-1})=2\\sum_{i=0}^m C_n^i - C_n^m \\] ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int tot=0,f=1;char ch=getchar(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=getchar();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') tot=tot*10+ch-48,ch=getchar(); return f*tot;&#125;const int maxn=1e5+5,MOD=1e9+7,inv2=MOD+1&gt;&gt;1;int q,h[maxn],ans[maxn];void blocker(int n)&#123; int k=sqrt(n); for (int i=1;i&lt;=n;i++) h[i]=(i-1)/k+1;&#125;struct data&#123; int l,r,id; bool operator&lt;(const data&amp;b)const&#123; if (h[l]==h[b.l]) return r&lt;b.r; return l&lt;b.l; &#125;&#125;que[maxn];ll C,frac[maxn],inv[maxn];ll power(ll a,int b)&#123; ll res=1,w=a; while (b)&#123; if (b&amp;1) (res*=w)%=MOD; (w*=w)%=MOD; b&gt;&gt;=1; &#125; return res;&#125;inline ll c(int n,int m)&#123; if (n==m) return 1; return frac[n]*inv[m]%MOD*inv[n-m]%MOD;&#125;int main()&#123; q=red(); blocker(q); for (int i=1;i&lt;=q;i++) que[i].r=red(),que[i].l=red(),que[i].id=i; sort(que+1,que+1+q); C=1; frac[0]=1;for (int i=1;i&lt;=1e5;i++) frac[i]=(frac[i-1]*i)%MOD; for (int i=0;i&lt;=1e5;i++) inv[i]=power(frac[i],MOD-2); for (int i=1,L=0,R=0;i&lt;=q;i++)&#123; while (R&lt;que[i].r)&#123; C=(2*C%MOD-c(R++,L))%MOD; &#125; while (R&gt;que[i].r)&#123; C=(C+c(--R,L))%MOD*inv2%MOD; &#125; while (L&lt;que[i].l)&#123; C=(C+c(R,++L))%MOD; &#125; while (L&gt;que[i].l)&#123; C=(C-c(R,L--))%MOD; &#125; ans[que[i].id]=C; &#125; for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",(ans[i]+MOD)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"莫队","slug":"莫队","permalink":"http://oi.linkfqy.top/tags/莫队/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#4】HDU6343 Problem L. Graph Theory Homework","slug":"HDU6343","date":"2018-08-01T11:02:06.000Z","updated":"2018-08-01T11:16:04.000Z","comments":true,"path":"posts/HDU6343/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6343/","excerpt":"","text":"题面在这里 ​ 因为当\\(a,b\\gt 0\\)时，\\(\\sqrt a + \\sqrt b \\gt \\sqrt{a+b}\\) 所以直接从1走到n就好了 ​ 示例程序： 12345678910111213141516#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define _abs(x) ((x)&gt;0?(x):-(x))using namespace std;const int maxn=100005;int tst,n,a[maxn];int main()&#123; for (scanf(\"%d\",&amp;tst);tst;tst--)&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); printf(\"%d\\n\",(int)sqrt(_abs(a[1]-a[n]))); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"水题","slug":"水题","permalink":"http://oi.linkfqy.top/tags/水题/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#4】HDU6336 Problem E. Matrix from Arrays","slug":"HDU6336","date":"2018-08-01T10:41:04.000Z","updated":"2018-08-01T11:00:42.000Z","comments":true,"path":"posts/HDU6336/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6336/","excerpt":"","text":"题面在这里 ​ 考虑每个位置上的值： \\[ M[i][j]=A[(\\frac{(i + j)(i + j + 1)}{2} + i) \\mod L] \\\\ = A[(\\frac{3i}{2} + \\frac{j}{2} + \\frac{i ^ 2} {2} + \\frac{j ^ 2}{2} + ij) \\mod L] \\\\ =M[i+2L][j]=M[i][j+2L] \\] 也就是这个矩阵是以\\(2L\\times 2L\\)的子矩阵为循环的 预处理出这个表，直接回答 ​ 然而当时是打表发现规律的…… 然后写好了还没交上去…… 我好菜啊…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;cstdio&gt;typedef long long ll;const int maxn=45;int tst,n,q,m,a[maxn],biao[maxn][maxn];ll S;inline ll sum(int x,int y,int xx,int yy)&#123; ll res=0; for (int i=x;i&lt;=xx;i++) for (int j=y;j&lt;=yy;j++) res+=biao[i][j]; return res;&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); m=2*n; for (int i=0;i&lt;n;i++) scanf(\"%d\",&amp;a[i]); int cur=0; for (int i=0;i&lt;=4*n;i++) for (int j=0;j&lt;=i;j++) biao[j][i-j]=a[cur],(++cur)%=n; S=0; for (int i=0;i&lt;m;i++) for (int j=0;j&lt;m;j++) S+=biao[i][j]; scanf(\"%d\",&amp;q); while (q--)&#123; int x,y,xx,yy;scanf(\"%d%d%d%d\",&amp;x,&amp;y,&amp;xx,&amp;yy); int X=xx/m-x/m-1,Y=yy/m-y/m-1; ll ans=S*X*Y; ans+=X*sum(0,y%m,m-1,m-1); ans+=X*sum(0,0,m-1,yy%m); ans+=Y*sum(0,0,xx%m,m-1); ans+=Y*sum(x%m,0,m-1,m-1); ans+=sum(x%m,y%m,m-1,m-1); ans+=sum(0,0,xx%m,yy%m); ans+=sum(x%m,0,m-1,yy%m); ans+=sum(0,y%m,xx%m,m-1); printf(\"%lld\\n\",ans); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"Link-Cut Tree 学习笔记","slug":"Link_Cut_Tree","date":"2018-07-31T02:50:26.000Z","updated":"2018-07-31T07:18:00.000Z","comments":true,"path":"posts/Link_Cut_Tree/","link":"","permalink":"http://oi.linkfqy.top/posts/Link_Cut_Tree/","excerpt":"重新学一次LCT","text":"重新学一次LCT ​ 参考论文：SPOJ375 QTREE 解法的一些研究 动态树问题 RT，就是维护一棵或多棵树的路径信息、子树信息，支持对树的分割和合并 Link-Cut Tree是动态树问题一个很好的解决方案 Link-Cut Tree 定义 LCT中使用两种边来连接同一棵树中的节点：\\(\\text{Preferred Edge}\\)和\\(\\text{Parent Edge}\\) 类似于重链剖分中的轻边和重边，每个非叶子节点恰好有一条\\(\\text{Preferred Edge}​\\)指向儿子节点 由\\(\\text{Preferred Edge}\\)组成的路径称为\\(\\text{Preferred Path}\\) \\(\\text{Preferred Path}\\)的顶端节点由\\(\\text{Parent Edge}\\)与其父节点相连 ​ \\(\\text{Preferred Path}​\\)由\\(\\text{Access}​\\)操作产生 \\(\\text{Access(x)}​\\)操作将根节点到x的路径变为\\(\\text{Preferred Path}​\\)，原来指向这条路径的所有\\(\\text{Preferred Edge}​\\)变为\\(\\text{Parent Edge}​\\) ​ 这样，一棵树就被划分成若干条\\(\\text{Preferred Path}\\)，并由\\(\\text{Parent Edge}\\)相连 因为\\(\\text{Splay}\\)可以非常方便地实现分裂和合并，我们可以用\\(\\text{Splay}\\)维护每一条\\(\\text{Preferred Path}\\)的信息 \\(\\text{Splay}\\)左子树中的节点代表\\(\\text{Preferred Path}\\)中更上面的节点，\\(\\text{Splay}\\)右子树中的节点代表\\(\\text{Preferred Path}\\)中更下面的节点 操作 Access \\(\\text{Access(x)}​\\)操作的意义在于将x到根的路径变为同一棵\\(\\text{Splay}​\\)，方便其他操作 实现十分暴力：一路向上修改每棵\\(\\text{Splay}​\\)的信息。可以证明，\\(\\text{Access}​\\)操作的复杂度是均摊\\(O(logn)​\\)的 1inline void access(int x) &#123;for (int t=0;x;t=x,x=fa[x]) splay(x),s[x][1]=t,pushup(x);&#125; 不要忘了更新\\(\\text{Splay}\\)信息 MakeRoot LCT经常需要用到\\(\\text{MakeRoot}\\)操作，将某个点变成整棵树的根，这对一些关于树形态的操作很有用 实现： \\(\\text{Access(x)}​\\)，此时x在\\(\\text{Preferred Path}​\\)的底端 \\(\\text{Splay(x)}\\)，此时x变为\\(\\text{Splay}\\)的根，但所有节点都在左子树（\\(\\text{Preferred Path}\\)的上端） \\(\\text{Flip(x)}\\)，将整棵\\(\\text{Splay}\\)翻转，x就变成了\\(\\text{Preferred Path}\\)顶端 1inline void mr(int x) &#123;access(x),splay(x),addflip(x);&#125; Join \\(\\text{Join(x,y)}\\)的作用是将x变为y的一个儿子 直接把x变成根节点，再连一条\\(\\text{Parent Edge}\\)就好了 1inline void join(int x,int y) &#123;mr(x);fa[x]=y;&#125; Cut \\(\\text{Cut(x,y)}\\)的作用是删除边\\((x,y)\\) 实现： \\(\\text{MakeRoot(x)}\\)，\\(\\text{Access(y)}\\)，这样根节点所在\\(\\text{Splay}\\)只有x,y两个点了 \\(\\text{Splay(y)}\\)，此时\\(\\text{Splay}\\)中x一定是y的左儿子，fa[x]=son[y][0]=0即可 1inline void cut(int x,int y) &#123;mr(x),access(y),splay(y);if (s[y][0]==x) fa[x]=s[y][0]=0;&#125; GetRoot \\(\\text{GetRoot(x)}\\)获取x所在树的根 先\\(\\text{Access(x)}\\)，此时x所在\\(\\text{Splay}\\)的最左节点就是根了 暴力往左走即可，因为\\(\\text{Splay}\\)的深度是均摊\\(O(logn)\\)的 注意点： 一定要记得一路\\(\\text{Pushdown}\\) 最后再\\(\\text{Splay}\\)根节点，不然复杂度是错的 1inline int getrt(int x) &#123;access(x),splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125; 其他 获取x到y路径的信息： 先\\(\\text{MakeRoot(x)}\\)，\\(\\text{Access(y)}\\)，把这条路径放在一棵\\(\\text{Splay}\\)里 注意到此时x不一定是Splay的根了，还要\\(\\text{Splay(y)}\\)一下，才能获得整个路径的信息 获取LCA(x,y)： \\(\\text{Access(x)}，\\text{Access(y)}，\\text{Splay(x)}\\) 此时fa[x]就是LCA了 特判：x没有fa时，LCA是x 复杂度分析 不难发现，LCT的时间复杂度基于\\(\\text{Access}\\)操作，所以总时间复杂度为\\(O(nlogn)\\) 关于\\(\\text{Access}\\)操作的复杂度证明，详见论文 空间复杂度为\\(O(n)\\) 模板 1234567891011121314151617181920212223242526272829303132333435int s[maxn][2],fa[maxn];bool flp[maxn];#define isroot(x) (s[fa[x]][0]!=x&amp;&amp;s[fa[x]][1]!=x)inline void addflip(int x) &#123;swap(s[x][0],s[x][1]);flp[x]^=1;&#125;inline void pushup(int x) &#123;/* do something */&#125;inline void pushdown(int x) &#123;if (flp[x]) flp[x]^=1,addflip(s[x][0]),addflip(s[x][1]);&#125;inline void rotate(int x)&#123; int f=fa[x],g=fa[f],d=s[f][0]==x; if (!isroot(f)) s[g][s[g][1]==f]=x; fa[x]=g; s[f][d^1]=s[x][d]; fa[s[x][d]]=f; pushup(f); s[x][d]=f; fa[f]=x; pushup(x);&#125;int top,stk[maxn];inline void splay(int x)&#123; stk[top=1]=x; for (int i=x;!isroot(i);i=fa[i]) stk[++top]=fa[i]; while (top) pushdown(stk[top--]); while (!isroot(x))&#123; int f=fa[x],g=fa[f],d=s[f][0]==x,dd=s[g][0]==f; if (!isroot(f)) if (d==dd) rotate(f),rotate(x);else rotate(x),rotate(x); else rotate(x); &#125;&#125;inline void access(int x) &#123;for (int t=0;x;t=x,x=fa[x]) splay(x),s[x][1]=t,pushup(x);&#125;inline void mr(int x) &#123;access(x),splay(x),addflip(x);&#125;inline void join(int x,int y) &#123;mr(x);fa[x]=y;&#125;inline void cut(int x,int y) &#123;mr(x),access(y),splay(y);if (s[y][0]==x) fa[x]=s[y][0]=0;&#125;inline int getrt(int x) &#123;access(x),splay(x);while (s[x][0]) pushdown(x),x=s[x][0];splay(x);return x;&#125; //!!!//...if (getrt(x)!=getrt(y)) join(x,y); //加边 cut(x,y); //删边mr(x);access(x); //修改x的点权mr(x);access(y);splay(x); //获取(x,y)路径的信息","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"LCT","slug":"LCT","permalink":"http://oi.linkfqy.top/tags/LCT/"}]},{"title":"【多校2018#3】HDU6321 Problem C. Dynamic Graph Matching","slug":"HDU6321","date":"2018-07-30T13:21:36.000Z","updated":"2018-07-30T13:31:56.000Z","comments":true,"path":"posts/HDU6321/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6321/","excerpt":"","text":"题面在这里 ​ 一看就是状压DP了…… \\(f_{i,s}\\)表示前i个操作，状态为s的方案数 加边操作：\\(f_{i,s}=f_{i-1,s-u-v}\\)，\\((u,v)\\)是新加的边 然后i这一维可以省略，\\(f_s+=f_{s-u-v}\\) 删边操作：发现加边的顺序与答案无关，令上一次加边刚好是这次删的边 就变成了撤销上次的操作，\\(f_s-=f_{s-u-v}\\) 写得好是\\(O(Tm\\cdot 2^n)\\)丝毫不虚 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;inline char fstchar()&#123; char ch=nc();while (ch!='+'&amp;&amp;ch!='-') ch=nc(); return ch;&#125;const int maxs=1030,MOD=1e9+7;int tst,n,q,f[maxs],h[maxs],num1[maxs];int main()&#123; tst=red(); for (int s=0;s&lt;1024;s++)&#123; for (int x=s;x;x&gt;&gt;=1) num1[s]+=x&amp;1; &#125; while (tst--)&#123; n=red(),q=red(); cl(f,0);f[0]=1; while (q--)&#123; if (fstchar()=='+')&#123; int u=red(),v=red(); for (int s=(1&lt;&lt;n)-1;s&gt;=0;s--) if ((s&amp;(1&lt;&lt;u-1))&amp;&amp;(s&amp;(1&lt;&lt;v-1))) (f[s]+=f[s^(1&lt;&lt;u-1)^(1&lt;&lt;v-1)])%=MOD; &#125;else&#123; int u=red(),v=red(); for (int s=0;s&lt;(1&lt;&lt;n);s++) if ((s&amp;(1&lt;&lt;u-1))&amp;&amp;(s&amp;(1&lt;&lt;v-1))) (f[s]-=f[s^(1&lt;&lt;u-1)^(1&lt;&lt;v-1)])%=MOD; &#125; cl(h,0); for (int s=0;s&lt;(1&lt;&lt;n);s++) (h[num1[s]]+=f[s])%=MOD; bool fir=1; for (int k=1;k&lt;=n/2;k++) printf(fir?(fir=0,\"%d\"):\" %d\",(h[k*2]+MOD)%MOD); putchar('\\n'); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#3】HDU6319 Problem A. Ascending Rating","slug":"HDU6319","date":"2018-07-30T12:00:01.000Z","updated":"2018-07-30T12:10:18.000Z","comments":true,"path":"posts/HDU6319/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6319/","excerpt":"","text":"题面在这里 ​ 直接倒着处理，用单调队列维护区间上升序列 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=10000005;int tst,n,m,k,p,q,r,MOD,que[maxn];ll A,B,a[maxn];int main()&#123; tst=red(); while (tst--)&#123; n=red(),m=red(),k=red(),p=red(),q=red(),r=red(),MOD=red();A=B=0; for (int i=1;i&lt;=k;i++) a[i]=red(); for (int i=k+1;i&lt;=n;i++) a[i]=(p*a[i-1]+(ll)q*i+r)%MOD; int hed=1,til=0; for (int l=n;l&gt;=n-m+2;l--)&#123; while (hed&lt;=til&amp;&amp;a[que[til]]&lt;=a[l]) til--; que[++til]=l; &#125; for (int l=n-m+1;l&gt;=1;l--)&#123;int r=l+m-1; while (hed&lt;=til&amp;&amp;que[hed]&gt;r) hed++; while (hed&lt;=til&amp;&amp;a[que[til]]&lt;=a[l]) til--; que[++til]=l; A+=a[que[hed]]^l; B+=(til-hed+1)^l; &#125; printf(\"%lld %lld\\n\",A,B); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"单调队列","slug":"单调队列","permalink":"http://oi.linkfqy.top/tags/单调队列/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#3】HDU6324 Problem F. Grab The Tree","slug":"HDU6324","date":"2018-07-30T11:05:51.000Z","updated":"2018-07-30T11:09:02.000Z","comments":true,"path":"posts/HDU6324/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6324/","excerpt":"","text":"题面在这里 ​ 考虑所有点的异或和\\(sum\\) 如果\\(sum=0\\)，则无论怎么取都是平局 否则考虑\\(sum\\)二进制下最高的1 如果先手取了任意一个含有这个1的节点，后者一定取不到这个1 那么先手必胜 ​ 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;int tst,n;int main()&#123; tst=red(); while (tst--)&#123; n=red();int sum=0; for (int i=1;i&lt;=n;i++) sum^=red(); for (int i=1;i&lt;n;i++) red(),red(); puts(sum==0?\"D\":\"Q\") ; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://oi.linkfqy.top/tags/博弈论/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#3】HDU6322 Problem D. Euler Function","slug":"HDU6322","date":"2018-07-30T10:53:30.000Z","updated":"2018-07-30T10:55:20.000Z","comments":true,"path":"posts/HDU6322/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6322/","excerpt":"","text":"题面在这里 ​ 好像只有\\(1,2,3,4,6\\)不是合数？ 具体证明并不会…… ​ 示例程序： 12345678910111213#include&lt;cstdio&gt;using namespace std;int te,n;int main()&#123; for (scanf(\"%d\",&amp;te);te;te--)&#123; scanf(\"%d\",&amp;n); if (n==1) puts(\"5\"); else printf(\"%d\\n\",n+5); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://oi.linkfqy.top/tags/数学/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#3】HDU6330 Problem L. Visual Cube","slug":"HDU6330","date":"2018-07-30T10:42:42.000Z","updated":"2018-07-30T10:44:40.000Z","comments":true,"path":"posts/HDU6330/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6330/","excerpt":"","text":"题面在这里 ​ 直接模拟就好了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=105;const char s[5][6]=&#123;\" +-+\",\" /./|\",\"+-+.+\",\"|.|/ \",\"+-+ \"&#125;;int tst,a,b,c,n,m;char map[maxn][maxn];void draw(int x,int y)&#123; //printf(\"draw %d %d\\n\",x,y); for (int i=0;i&lt;5;i++) for (int j=0;j&lt;5;j++) if (s[i][j]!=' ') map[x+i][y+j]=s[i][j];&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d%d%d\",&amp;a,&amp;b,&amp;c);//printf(\"%d %d %d\\n\",a,b,c); cl(map,'.'); n=(b+c)*2+1;m=(a+b)*2+1;//printf(\"%d %d\\n\",n,m); for (int k=1;k&lt;=c;k++) for (int j=b;j&gt;=1;j--) for (int i=1;i&lt;=a;i++) draw(2*(b-j)+2*(c-k)+1,2*(i-1)+2*(j-1)+1); for (int i=1;i&lt;=n;i++)&#123; for (int j=1;j&lt;=m;j++) putchar(map[i][j]); putchar('\\n'); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"},{"name":"模拟","slug":"模拟","permalink":"http://oi.linkfqy.top/tags/模拟/"}]},{"title":"【多校2018#3】HDU6325 Problem G. Interstellar Travel","slug":"HDU6325","date":"2018-07-30T10:35:02.000Z","updated":"2018-07-30T10:41:26.000Z","comments":true,"path":"posts/HDU6325/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6325/","excerpt":"","text":"题面在这里 ​ 两点之间代价就是叉积啊…… 考虑几何意义，就是让围成的面积最大（负值） 那么就是一个上凸壳，直接做就好了 ​ 然而要字典序最小，考虑使凸包产生多种方案一定是三点共线，判一下即可 最后还是被重复点坑死了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=200005;int tst,n,stk[maxn],len,id[maxn];struct point&#123; ll x,y;int id; point () &#123;&#125; point (ll _x,ll _y) :x(_x),y(_y) &#123;&#125; bool operator&lt;(const point&amp;b)const &#123;return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y;&#125;&#125;a[maxn];typedef point vec;inline vec operator-(const point&amp;a,const point&amp;b) &#123;return vec(a.x-b.x,a.y-b.y);&#125;inline ll cross(const vec&amp;a,const vec&amp;b) &#123;return a.x*b.y-a.y*b.x;&#125;int main()&#123; tst=red(); while (tst--)&#123; n=red(); for (int i=1;i&lt;=n;i++) a[i].x=red(),a[i].y=red(),a[i].id=i; sort(a+1,a+1+n); len=0; for (int i=1;i&lt;=n;i++)&#123; while (len&gt;1)&#123; ll c=cross(a[stk[len]]-a[stk[len-1]],a[i]-a[stk[len-1]]); if (c&gt;0||c==0&amp;&amp;a[stk[len]].id&gt;a[i].id) len--;else break; &#125; if (len==0||a[i].x!=a[stk[len]].x) stk[++len]=i; &#125; for (int i=1;i&lt;=len;i++) if (i&lt;len) printf(\"%d \",a[stk[i]].id);else printf(\"%d\\n\",a[stk[i]].id); &#125;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"},{"name":"凸包","slug":"凸包","permalink":"http://oi.linkfqy.top/tags/凸包/"}]},{"title":"双联通分量小结+Tarjan模板整理","slug":"BCC_and_Tarjan","date":"2018-07-28T12:33:26.000Z","updated":"2018-07-28T13:37:44.000Z","comments":true,"path":"posts/BCC_and_Tarjan/","link":"","permalink":"http://oi.linkfqy.top/posts/BCC_and_Tarjan/","excerpt":"之前有学过双联通分量相关知识…… 直到前几天学长讲课才发现自己可能学了假的Tarjan 这里做一个remake","text":"之前有学过双联通分量相关知识…… 直到前几天学长讲课才发现自己可能学了假的Tarjan 这里做一个remake ​ 预备知识 桥（割边）：如果去掉，图的联通块个数会增加的边 割点（割顶）：如果去掉，图的联通块个数会增加的点 DFS树：将一个图DFS遍历所得到的树 非树边：不在DFS树上的边 边双联通分量：任意两点可以通过两条不同路径（边不重复）互达的子图 点双联通分量：任意两点可以通过两条不同路径（点不重复）互达的子图 ​ 于是有这样的性质： 非树边只会存在于DFS树的点与祖先之间 一个点（割点）可能属于多个点双联通分量 一条边只属于确定的一个边双联通分量 边双联通分量 考虑非树边对DFS树的影响，有以下结论： 非树边及其在DFS树上覆盖的路径属于同一边双联通分量 边双联通分量缩点后整个图必然是森林 边双联通分量的Tarjan算法 找桥 记录\\(dfn[x]\\)表示x入栈的时间戳，\\(low[x]\\)为x可达的所有点中最小的dfn 那么，DFS树边\\(u\\rightarrow v\\)是桥当且仅当\\(low[v]&gt;dfn[u]\\) 这样我们就得到了找桥的Tarjan算法 12345678void tarjan(int x,int fa)&#123; low[x]=dfn[x]=++times; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; tarjan(son[j],x); low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;dfn[x]) isb[j]=isb[j^1]=1; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]);&#125; 找边双联通分量 我原来的做法是：不经过桥，把整个图再遍历一次，每个联通块是边双 后来发现这简直蠢爆了 其实可以直接用强连通分量那套栈处理的方法 但是要注意：由于找到桥才判定边双，一定不要忘了根节点，可以结束后把栈清空！！ 123456789101112131415void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;stk[++stk[0]]=x; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x); low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;dfn[x])&#123; BCC++; while (stk[stk[0]]!=son[j]) id[stk[stk[0]--]]=BCC; id[stk[stk[0]--]]=BCC; &#125; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]);&#125;//......for (int i=1;i&lt;=n;i++) if (!dfn[i]) &#123;Tarjan(i,0); BCC++;while (stk[0]) id[stk[stk[0]--]]=BCC;&#125; 点双联通分量的Tarjan算法 找割点 同样记录\\(dfn\\)和\\(low\\) u是割点条件是存在\\(u\\rightarrow v\\)，使得\\(low[v]\\ge dfn[u]\\) 但是根节点需要特判——仅当根有多个儿子时，根才是割点 123456789void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;int sum=0;bool suc=0; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x);low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;=dfn[x]) suc=1;sum++; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]); g[x]=(fa&amp;&amp;suc||!fa&amp;&amp;sum&gt;1);&#125; 找点双联通分量 和边双类似，用栈记录 点双联通分量缩点一般使用圆方树，所以Tarjan时直接建边 同样存在根节点的问题 1234567891011121314inline void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;stk[++stk[0]]=x; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x); low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;=dfn[x])&#123; BCC++; add(x); while (stk[stk[0]]!=son[j]) add(stk[stk[0]--]); &#125; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]);&#125;//......for (int i=1;i&lt;=n;i++) if (!dfn[i]) &#123;Tarjan(i,0); BCC++;while (stk[0]) add(stk[stk[0]--]);&#125; ​ 大概就好了吧……","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"双联通分量","slug":"双联通分量","permalink":"http://oi.linkfqy.top/tags/双联通分量/"}]},{"title":"POJ3352 Road Construction","slug":"POJ3352","date":"2018-07-28T12:28:59.000Z","updated":"2018-07-28T12:30:40.000Z","comments":true,"path":"posts/POJ3352/","link":"","permalink":"http://oi.linkfqy.top/posts/POJ3352/","excerpt":"","text":"题面在这里 ​ 水。 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=1005,maxe=2005;int n,e,BCC,id[maxn],du[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int dfn[maxn],low[maxn],stk[maxn],times=0;void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;stk[++stk[0]]=x; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x); low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;dfn[x])&#123; BCC++; while (stk[stk[0]]!=son[j]) id[stk[stk[0]--]]=BCC; id[stk[stk[0]--]]=BCC; &#125; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]);&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); add(0,1);add(1,0);Tarjan(0,0); for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (id[i]!=id[son[j]]) du[id[i]]++,du[id[son[j]]]++; int leaf=0; for (int i=1;i&lt;=BCC;i++) if (du[i]==2) leaf++; printf(\"%d\",leaf+1&gt;&gt;1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"双联通分量","slug":"双联通分量","permalink":"http://oi.linkfqy.top/tags/双联通分量/"},{"name":"POJ","slug":"POJ","permalink":"http://oi.linkfqy.top/tags/POJ/"}]},{"title":"POJ3177 Redundant Paths","slug":"POJ3177","date":"2018-07-28T12:25:11.000Z","updated":"2018-07-28T12:28:34.000Z","comments":true,"path":"posts/POJ3177/","link":"","permalink":"http://oi.linkfqy.top/posts/POJ3177/","excerpt":"","text":"题面在这里 ​ 双联通分量缩点以后答案就是\\(\\lfloor \\frac{leaf+1}2 \\rfloor\\) 感性理解一下，就是每次找LCA最浅的两个叶子合并 然后就好了，主要是练习边双联通分量Tarjan模板 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=5005,maxe=20005;int n,e,BCC,id[maxn],du[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int dfn[maxn],low[maxn],stk[maxn],times=0;void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;stk[++stk[0]]=x; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x); low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;dfn[x])&#123; BCC++; while (stk[stk[0]]!=son[j]) id[stk[stk[0]--]]=BCC; id[stk[stk[0]--]]=BCC; &#125; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]);&#125;bool vis[maxn][maxn];int main()&#123; scanf(\"%d%d\",&amp;n,&amp;e); for (int i=1,x,y;i&lt;=e;i++)&#123; scanf(\"%d%d\",&amp;x,&amp;y); if (!vis[x][y]) add(x,y),add(y,x); vis[x][y]=vis[y][x]=1; &#125; Tarjan(1,0); BCC++;while (stk[0]) id[stk[stk[0]--]]=BCC; for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (id[i]!=id[son[j]]) du[id[i]]++,du[id[son[j]]]++; int leaf=0; for (int i=1;i&lt;=BCC;i++) if (du[i]==2) leaf++; printf(\"%d\",leaf+1&gt;&gt;1); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"双联通分量","slug":"双联通分量","permalink":"http://oi.linkfqy.top/tags/双联通分量/"},{"name":"POJ","slug":"POJ","permalink":"http://oi.linkfqy.top/tags/POJ/"}]},{"title":"【割点+计数】BZOJ2730 [HNOI2012]矿场搭建","slug":"BZOJ2730","date":"2018-07-28T05:35:54.000Z","updated":"2018-07-28T07:40:26.000Z","comments":true,"path":"posts/BZOJ2730/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2730/","excerpt":"","text":"题面在这里 ​ 考虑每个连通块 如果一个连通块内没有割点（整个点双），任意放两个出口即可（防止出口被炸） 否则考虑只有一个割点的点双，这样的点双至少要放一个出口（防止割点被炸） 具体实现只需要遍历每个点双，考虑对答案的贡献就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;using namespace std;const int maxn=1005,maxe=1005;int tst,n,e; ll ans1,ans2;int tot,lnk[maxn],son[maxe],nxt[maxe];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int dfn[maxn],low[maxn],times;bool g[maxn];void Tarjan(int x,int fa)&#123; dfn[x]=low[x]=++times;int sum=0;bool suc=0; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]])&#123; Tarjan(son[j],x);low[x]=min(low[x],low[son[j]]); if (low[son[j]]&gt;=dfn[x]) suc=1;sum++; &#125;else if (son[j]!=fa) low[x]=min(low[x],dfn[son[j]]); g[x]=(fa&amp;&amp;suc||!fa&amp;&amp;sum&gt;1);&#125;int num,ge,vis[maxn],tag;void dfs(int x)&#123; num++;ge+=g[x];vis[x]=tag; if (g[x]) &#123;num--;return;&#125; for (int j=lnk[x];j;j=nxt[j]) if (vis[son[j]]!=tag) dfs(son[j]);&#125;int main()&#123; for (scanf(\"%d\",&amp;e);e;scanf(\"%d\",&amp;e))&#123; cl(lnk,0);tot=0;n=0; for (int i=1,x,y;i&lt;=e;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x),n=max(n,max(x,y)); cl(dfn,0);times=0;cl(g,0); for (int i=1;i&lt;=n;i++) if (!dfn[i]) Tarjan(i,0); ans1=0;ans2=1;cl(vis,0); for (int i=1;i&lt;=n;i++) if (!vis[i]&amp;&amp;!g[i])&#123; tag++;num=ge=0;dfs(i); if (ge==0) ans1+=2,ans2*=num*(num-1)/2;else if (ge==1) ans1+=1,ans2*=num; &#125; printf(\"Case %d: %lld %lld\\n\",++tst,ans1,ans2); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"双联通分量","slug":"双联通分量","permalink":"http://oi.linkfqy.top/tags/双联通分量/"}]},{"title":"HDU4622 Reincarnation","slug":"HDU4622","date":"2018-07-26T13:04:34.000Z","updated":"2018-07-26T13:27:24.000Z","comments":true,"path":"posts/HDU4622/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU4622/","excerpt":"","text":"题面在这里 ​ 考虑枚举字串\\([l,r]\\)，则所有包含\\([l,r]\\)的区间答案+1 因为要考虑本质不同的子串，设该子串上次出现位置\\([l&#39;,r&#39;]\\) 则包含\\([l&#39;,r]\\)子串的区间答案-1 然后XJBDP就好了 记录子串上次出现的区间可以用哈希 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef unsigned long long ull;using namespace std;const int maxn=2005;const int maxs=2005,MOD=10007;int tst,n,q,f[maxn][maxn]; ull pw[maxn],h[maxn];char s[maxn];inline ull gethash(int l,int r)&#123; return h[r]-h[l-1]*pw[r-l+1];&#125;struct hashmap&#123; int lnk[MOD+5],nxt[maxs],son[maxs],tot;ull w[maxs]; inline void clear() &#123;cl(lnk,0);tot=0;&#125; inline void add(ull x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x%MOD];lnk[x%MOD]=tot;w[tot]=x; &#125; inline int* ask(ull x)&#123; for (int j=lnk[x%MOD];j;j=nxt[j]) if (w[j]==x) return &amp;son[j]; return NULL; &#125;&#125;lst;int main()&#123; pw[0]=1;for (int i=1;i&lt;=2000;i++) pw[i]=pw[i-1]*233; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%s%d\",s+1,&amp;q);n=strlen(s+1); for (int i=1;i&lt;=n;i++) h[i]=h[i-1]*233+s[i]; cl(f,0); for (int L=1;L&lt;=n;L++)&#123; lst.clear(); for (int i=1;i+L-1&lt;=n;i++)&#123;int j=i+L-1; f[i][j]++;ull hhh=gethash(i,j); if (lst.ask(hhh)!=NULL) f[*lst.ask(hhh)][j]--,*lst.ask(hhh)=i;else lst.add(hhh,i); &#125; &#125; for (int i=n;i&gt;=1;i--) for (int j=i;j&lt;=n;j++) f[i][j]+=f[i+1][j]+f[i][j-1]-f[i+1][j-1]; while (q--)&#123; int l,r;scanf(\"%d%d\",&amp;l,&amp;r); printf(\"%d\\n\",f[l][r]); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ2795 [Poi2012]A Horrible Poem","slug":"BZOJ2795","date":"2018-07-25T13:20:59.000Z","updated":"2018-07-25T13:28:44.000Z","comments":true,"path":"posts/BZOJ2795/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2795/","excerpt":"","text":"题面在这里 ​ 其实挺简单的…… 考虑\\(S[1..x]\\)是S的循环节，当且仅当\\(S[1..n-x]=S[1+x,n]\\) 这个可以用哈希快速判断 因为循环节一定是最小循环节的倍数，而n一定是S的循环节 那么就可以从n开始，枚举并排除质因子，从而得到最小质因子 这个用线性筛预处理最小质因子\\(O(logn)\\)枚举就好了 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435#include&lt;cstdio&gt;#define ull unsigned long longconst int maxn=500005;int n,q,p[maxn],nxt[maxn]; bool vis[maxn];char s[maxn];void makep(int n)&#123; nxt[1]=1; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i,nxt[i]=i; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1;nxt[i*p[j]]=p[j]; if (i%p[j]==0) break; &#125; &#125;&#125;ull sum[maxn],pw[maxn];inline ull getha(int l,int r)&#123; if (l&gt;r) return 0; return sum[r]-sum[l-1]*pw[r-l+1];&#125;int main()&#123; scanf(\"%d%s\",&amp;n,s+1);makep(n);pw[0]=1; for (int i=1;i&lt;=n;i++) sum[i]=sum[i-1]*233+s[i],pw[i]=pw[i-1]*233; scanf(\"%d\",&amp;q); while (q--)&#123; int l,r,tem,len,mn;scanf(\"%d%d\",&amp;l,&amp;r); for (tem=len=r-l+1,mn=nxt[tem];tem&gt;1;mn=nxt[tem])&#123; while (len%mn==0&amp;&amp;getha(l,r-len/mn)==getha(l+len/mn,r)) len/=mn; while (tem%mn==0) tem/=mn; &#125; printf(\"%d\\n\",len); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"},{"name":"线性筛","slug":"线性筛","permalink":"http://oi.linkfqy.top/tags/线性筛/"}]},{"title":"【多校2018#2】HDU6312 Game","slug":"HDU6312","date":"2018-07-25T12:23:23.000Z","updated":"2018-07-25T12:28:02.000Z","comments":true,"path":"posts/HDU6312/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6312/","excerpt":"","text":"题面在这里 ​ 其实无论如何先手必胜…… 考虑\\(1..n\\)的集合，如果先手不取1能必胜，就必胜了 如果不取1后手必胜，就取1，这样对任何数的选取都没有影响，把后手必胜的局面留给对方 然后就好了…… ​ 考场里是猜出来的…… ​ 示例程序： 123456789#include&lt;cstdio&gt;int n;int main()&#123; while (~scanf(\"%d\",&amp;n))&#123; puts(\"Yes\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"博弈论","slug":"博弈论","permalink":"http://oi.linkfqy.top/tags/博弈论/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#2】HDU6315 Naive Operations","slug":"HDU6315","date":"2018-07-25T10:43:22.000Z","updated":"2018-07-25T10:54:52.000Z","comments":true,"path":"posts/HDU6315/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6315/","excerpt":"","text":"题面在这里 ​ 首先注意到\\(b_i\\)只是n的排列 可以猜一下\\(\\lfloor a_i/b_i \\rfloor\\)变化的次数很少 其实就是\\(\\sum_{i=1}^n n/i\\)总共\\(O(n\\cdot ln(n))\\)次 然后就是大力数据结构…… 把操作看成\\(b_i\\)不断减，减成\\(0\\)对答案的贡献就+1 线段树每次区间减后不断询问最小值，最小值为0就把对应位置对答案的贡献+1 总复杂度\\(O(n\\cdot ln(n)logn)\\) ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc second#define mp make_pairusing namespace std;typedef pair&lt;int,int&gt; data;const int maxn=100000;int n,te,b[maxn+5],c[maxn+5];int ID[(maxn&lt;&lt;2)+5],MIN[(maxn&lt;&lt;2)+5],tag[(maxn&lt;&lt;2)+5];#define Eoln(x) ((x)==10||(x)==13||(x)==EOF)inline char readc()&#123; static char buf[100000],*l=buf,*r=buf; if (l==r) r=(l=buf)+fread(buf,1,100000,stdin); if (l==r) return EOF;return *l++;&#125;inline int readi(int &amp;x)&#123; int tot=0;char ch=readc(),lst='+'; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); return (lst=='-'?x=-tot:x=tot),Eoln(ch);&#125;inline void Update(int x,int tem) &#123;for (int i=x;i&lt;=n;i+=i&amp;-i) c[i]+=tem;&#125;inline int Sum(int x) &#123;int sum=0;for (int i=x;i;i-=i&amp;-i) sum+=c[i];return sum;&#125;inline void Pushup(int p)&#123; if (MIN[p&lt;&lt;1]&lt;MIN[p&lt;&lt;1|1]) MIN[p]=MIN[p&lt;&lt;1],ID[p]=ID[p&lt;&lt;1]; else MIN[p]=MIN[p&lt;&lt;1|1],ID[p]=ID[p&lt;&lt;1|1];&#125;void Build(int L,int R,int p=1)&#123; tag[p]=0;if (L==R) &#123;ID[p]=L;MIN[p]=b[L];return;&#125;int mid=L+(R-L&gt;&gt;1); Build(L,mid,p&lt;&lt;1);Build(mid+1,R,p&lt;&lt;1|1);Pushup(p);&#125;inline void Pushdown(int p)&#123; int now=tag[p];tag[p]=0;if (!now) return; MIN[p&lt;&lt;1]+=now;tag[p&lt;&lt;1]+=now;MIN[p&lt;&lt;1|1]+=now;tag[p&lt;&lt;1|1]+=now;&#125;void Insert(int L,int R,int k,int l=1,int r=n,int p=1)&#123; if (R&lt;l||r&lt;L) return;if (L&lt;=l&amp;&amp;r&lt;=R) &#123;MIN[p]+=k;tag[p]+=k;return;&#125;int mid=l+(r-l&gt;&gt;1); Pushdown(p);Insert(L,R,k,l,mid,p&lt;&lt;1);Insert(L,R,k,mid+1,r,p&lt;&lt;1|1);Pushup(p);&#125;data Min(int L,int R,int l=1,int r=n,int p=1)&#123; if (R&lt;l||r&lt;L) return mp(2e9,0);if (L&lt;=l&amp;&amp;r&lt;=R) return mp(MIN[p],ID[p]);int mid=l+(r-l&gt;&gt;1); Pushdown(p);return min(Min(L,R,l,mid,p&lt;&lt;1),Min(L,R,mid+1,r,p&lt;&lt;1|1));&#125;inline void Add(int L,int R)&#123; Insert(L,R,-1);data now=Min(L,R); while (!now.fr)&#123; Insert(now.sc,now.sc,b[now.sc]); Update(now.sc,1);now=Min(L,R); &#125;&#125;inline int Ask(int L,int R) &#123;return Sum(R)-Sum(L-1);&#125;int main()&#123; while (~readi(n))&#123; readi(te);for (int i=1;i&lt;=n;i++) readi(b[i]),c[i]=0; for (Build(1,n);te;te--)&#123; char ch=readc();while (!islower(ch)) ch=readc(); int L,R;readi(L);readi(R); if (ch=='a') Add(L,R); else printf(\"%d\\n\",Ask(L,R)); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#2】HDU6318 Swaps and Inversions","slug":"HDU6318","date":"2018-07-25T10:37:13.000Z","updated":"2018-07-25T10:41:26.000Z","comments":true,"path":"posts/HDU6318/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6318/","excerpt":"","text":"题面在这里 ​ 考虑交换一对原本构成逆序对的数，会将代价从x变为y 而交换次数恰好等于逆序对数 所以\\(x&lt;y\\)不做任何交换 \\(x&gt;y\\)交换所有逆序对 ​ 又一次无耻的copy队友代码…… ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;using namespace std;typedef long long LL;const int maxn=100000;int n,X,Y,a[maxn+5],b[maxn+5],c[maxn+5];LL ans;#define Eoln(x) ((x)==10||(x)==13||(x)==EOF)inline char readc()&#123; static char buf[100000],*l=buf,*r=buf; if (l==r) r=(l=buf)+fread(buf,1,100000,stdin); if (l==r) return EOF;return *l++;&#125;inline int readi(int &amp;x)&#123; int tot=0;char ch=readc(),lst='+'; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); return (lst=='-'?x=-tot:x=tot),Eoln(ch);&#125;inline int Find(int x)&#123; int L=1,R=b[0],mid; while (L&lt;=R) &#123;mid=L+(R-L&gt;&gt;1);if (b[mid]==x) return mid;x&lt;b[mid]?R=mid-1:L=mid+1;&#125;&#125;inline void Update(int x,int tem) &#123;for (int i=x;i&lt;=b[0];i+=i&amp;-i) c[i]+=tem;&#125;inline int Sum(int x) &#123;int sum=0;for (int i=x;i;i-=i&amp;-i) sum+=c[i];return sum;&#125;int main()&#123; while (~readi(n))&#123; readi(X);readi(Y);for (int i=1;i&lt;=n;i++) readi(a[i]),b[i]=a[i]; sort(b+1,b+1+n);b[0]=unique(b+1,b+1+n)-b-1;ans=0; for (int i=1;i&lt;=n;i++) a[i]=Find(a[i]),c[i]=0; for (int i=n;i;i--) ans+=Sum(a[i]-1),Update(a[i],1); if (X&lt;Y) ans*=X; else ans*=Y;printf(\"%lld\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ2424 [HAOI2010]订货","slug":"BZOJ2424","date":"2018-07-24T13:02:04.000Z","updated":"2018-07-24T13:07:38.000Z","comments":true,"path":"posts/BZOJ2424/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2424/","excerpt":"","text":"题面在这里 ​ 很显然能想到\\(f_{i,j}\\)表示第i个月，月末库存为j的最小成本 \\[ f_{i,j}=Min\\{ f_{i-1,k}+d_i(u_i-k+j)+j\\cdot m \\} \\\\ =Min\\{ f_{i-1,k}-k\\cdot d_i \\} +j(m+d_i)+u_id_i \\] 记录前缀最小值就好了 ​ 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=55,maxs=10005;int n,m,S,u[maxn],d[maxn];ll f[maxn][maxs],MN[maxs];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;m,&amp;S); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;u[i]); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;d[i]); cl(f,63);cl(MN,63); f[0][0]=0;MN[0]=0; for (int i=1;i&lt;=n;i++)&#123; MN[0]=f[i-1][0]; for (int j=1;j&lt;=S;j++) MN[j]=min(MN[j-1],f[i-1][j]-j*d[i]); for (int j=0;j&lt;=S;j++) f[i][j]=MN[min(S,j+u[i])]+j*(m+d[i])+u[i]*d[i]; &#125; printf(\"%lld\",f[n][0]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【多校2018#1】HDU6301 Distinct Values","slug":"HDU6301","date":"2018-07-23T13:34:27.000Z","updated":"2018-07-23T13:38:40.000Z","comments":true,"path":"posts/HDU6301/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6301/","excerpt":"","text":"题面在这里 ​ 把区间排序，去除被包含的区间 剩下的东西就可以用两个指针维护区间，每次找没有用过的最小值放入区间末 没有用过的最小值随便弄个数据结构维护一下就好了 ​ 懒得打了……直接copy队友的代码 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cctype&gt;#include&lt;algorithm&gt;#define fr first#define sc secondusing namespace std;const int maxn=100000;int te,n,m,ans[maxn+5];pair&lt;int,int&gt; a[maxn+5];int sum[(maxn&lt;&lt;2)+5];#define Eoln(x) ((x)==10||(x)==13||(x)==EOF)inline char readc()&#123; static char buf[100000],*l=buf,*r=buf; if (l==r) r=(l=buf)+fread(buf,1,100000,stdin); if (l==r) return EOF;return *l++;&#125;inline int readi(int &amp;x)&#123; int tot=0;char ch=readc(),lst='+'; while (!isdigit(ch)) &#123;if (ch==EOF) return EOF;lst=ch;ch=readc();&#125; while (isdigit(ch)) tot=(tot&lt;&lt;3)+(tot&lt;&lt;1)+(ch^48),ch=readc(); return (lst=='-'?x=-tot:x=tot),Eoln(ch);&#125;void Build(int L,int R,int p=1)&#123; if (L==R) &#123;sum[p]=1;return;&#125;int mid=L+(R-L&gt;&gt;1); Build(L,mid,p&lt;&lt;1);Build(mid+1,R,p&lt;&lt;1|1);sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];&#125;void Insert(int pos,int k,int l=1,int r=n,int p=1)&#123; if (l==r) &#123;sum[p]+=k;return;&#125;int mid=l+(r-l&gt;&gt;1); if (pos&lt;=mid) Insert(pos,k,l,mid,p&lt;&lt;1); else Insert(pos,k,mid+1,r,p&lt;&lt;1|1); sum[p]=sum[p&lt;&lt;1]+sum[p&lt;&lt;1|1];&#125;int Find(int L=1,int R=n,int p=1)&#123; if (L==R) return L;int mid=L+(R-L&gt;&gt;1); if (sum[p&lt;&lt;1]) return Find(L,mid,p&lt;&lt;1); else return Find(mid+1,R,p&lt;&lt;1|1);&#125;inline bool cmp(const pair&lt;int,int&gt; &amp;a,const pair&lt;int,int&gt; &amp;b) &#123;return a.fr&lt;b.fr||a.fr==b.fr&amp;&amp;a.sc&gt;b.sc;&#125;int main()&#123; for (readi(te);te;te--)&#123; readi(n);readi(m);for (int i=1;i&lt;=m;i++) readi(a[i].fr),readi(a[i].sc); sort(a+1,a+1+m,cmp);int MAX=a[1].sc,tot=1;Build(1,n); for (int i=2;i&lt;=m;i++) if (a[i].sc&gt;MAX) a[++tot]=a[i],MAX=a[i].sc;m=tot; for (int i=1;i&lt;a[1].fr;i++) ans[i]=1; for (int i=a[1].fr;i&lt;=a[1].sc;i++) ans[i]=i-a[1].fr+1,Insert(ans[i],-1); int L=a[1].fr,R=a[1].sc; for (int i=2;i&lt;=m;i++)&#123; if (a[i-1].sc&lt;a[i].fr) &#123;while (L&lt;=R) Insert(ans[L++],1);while (L&lt;a[i].fr) ans[L++]=1;R=L-1;&#125; while (L&lt;a[i].fr) Insert(ans[L++],1); while (R&lt;a[i].sc) &#123;int now=Find();ans[++R]=now;Insert(ans[R],-1);&#125; &#125; for (int i=a[m].sc+1;i&lt;=n;i++) ans[i]=1; for (int i=1;i&lt;=n;i++) i&gt;1?printf(\" %d\",ans[i]):printf(\"%d\",ans[i]);puts(\"\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#1】HDU6298 Maximum Multiple","slug":"HDU6298","date":"2018-07-23T13:09:39.000Z","updated":"2018-07-23T13:12:42.000Z","comments":true,"path":"posts/HDU6298/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6298/","excerpt":"","text":"题面在这里 ​ 好像只有\\((n/3,n/3,n/3)\\)和\\((n/2,n/4,n/4)\\)两种可能了 因为其他方案不能保证\\(x+y+z=n\\)了 考场上打表看出来的…… ​ 示例程序： 1234567891011121314151617#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;int tst,n;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); if (n%3==0) printf(\"%lld\\n\",(ll)(n/3)*(n/3)*(n/3));else&#123; int x=n/2,y=x/2; if (x+2*y==n) printf(\"%lld\\n\",(ll)x*y*y);else puts(\"-1\"); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#1】HDU6308 Time Zone","slug":"HDU6308","date":"2018-07-23T12:31:43.000Z","updated":"2018-07-23T12:33:20.000Z","comments":true,"path":"posts/HDU6308/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6308/","excerpt":"","text":"题面在这里 ​ SB模拟题，考场上WA了N发好气啊…… ​ 示例程序： 123456789101112131415161718192021222324#include &lt;cstdio&gt;#include &lt;cctype&gt;using namespace std;int ti,hh,mm,wz,k;char s[10];int X,Y;int main()&#123; for (scanf(\"%d\",&amp;ti); ti; --ti)&#123; X=0,Y=0; scanf(\"%d%d%s\",&amp;hh,&amp;mm,s+1); X=s[5]-'0',wz=5; if (isdigit(s[6])) X=X*10+s[6]-'0',wz=6; if (s[wz+1]=='.') Y=s[wz+2]-'0'; if (s[4]=='-') X=-X,Y=-Y; hh=hh+X-8;mm+=6*Y; if (mm&gt;=60) mm-=60,hh++; if (mm&lt;0) mm+=60,hh--; hh=(hh%24+24)%24; printf(\"%02d:%02d\\n\",hh,mm); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"【多校2018#1】HDU6300 Triangle Partition","slug":"HDU6300","date":"2018-07-23T12:24:05.000Z","updated":"2018-07-23T12:29:14.000Z","comments":true,"path":"posts/HDU6300/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6300/","excerpt":"","text":"题面在这里 ​ 因为不存在三点共线 所以x坐标相同的点不超过两个 那么按x把所有点排序直接输出就好了 构成的三角形一定不相交 ​ 示例程序： 1234567891011121314151617181920#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=3005;int tst,n;struct point&#123; int x,y,id; bool operator&lt;(const point&amp;b)const &#123;return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y;&#125;&#125;a[maxn];int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=3*n;i++) scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y),a[i].id=i; sort(a+1,a+1+3*n); for (int i=1;i&lt;=n;i++) printf(\"%d %d %d\\n\",a[i*3-2].id,a[i*3-1].id,a[i*3].id); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ1485 [HNOI2009]有趣的数列","slug":"BZOJ1485","date":"2018-07-22T10:15:23.000Z","updated":"2018-07-22T10:50:56.000Z","comments":true,"path":"posts/BZOJ1485/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1485/","excerpt":"","text":"题面在这里 ​ 这题其实是一个裸的卡特兰数…… 直接消质因数搞就好了 证明如下： 根据题意，奇数位和偶数位分别递增 则任意选择n个数后，数列就被确定了（或者不合法） 考虑从1到2n依次填入数，则\\(2i-1\\)和\\(2i\\)两项一定是\\(2i-1\\)先填 这样就要求已填奇数位个数小于等于已填偶数位个数 就是卡特兰数的经典模型，括号匹配了 ​ 之前一直不知道卡特兰数通项公式\\(\\frac {C_{2n}^n}{n+1}\\)是怎么来的，这里再证一下 考虑括号匹配问题，其实就是构造一个长为2n的01串，使得任意位置\\(sum_1\\le sum_0\\) 则先选n个1，方案是\\(C_{2n}^n\\) 再考虑不合法的方案：必然存在i，使得\\(sum1_i=sum0_i+1\\)且\\(sum1_{i-1}=sum0_{i-1}\\) 使i+1到2n的01串取反，则整个串有\\(n-1\\)个0，\\(n+1\\)个1，对应方案为\\(C_{2n}^{n+1}\\) 则卡特兰数\\(C_{2n}^n-C_{2n}^{n+1}=\\frac {C_{2n}^n}{n+1}\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=2000005;int n,MOD,p[maxn],nxt[maxn],num[maxn];bool vis[maxn];void makep(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i,nxt[i]=i; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1;nxt[i*p[j]]=p[j]; if (i%p[j]==0) break; &#125; &#125;&#125;inline void add(int x,int f)&#123; for (;x&gt;1;x/=nxt[x]) num[nxt[x]]+=f;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;MOD); makep(2*n); for (int i=n+2;i&lt;=2*n;i++) add(i,1); for (int i=1;i&lt;=n;i++) add(i,-1); long long ans=1; for (int i=1;i&lt;=p[0];i++) for (int j=1;j&lt;=num[p[i]];j++) (ans*=p[i])%=MOD; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"数学","slug":"数学","permalink":"http://oi.linkfqy.top/tags/数学/"}]},{"title":"BZOJ3997 [TJOI2015]组合数学","slug":"BZOJ3997","date":"2018-07-22T02:43:40.000Z","updated":"2018-07-22T03:11:54.000Z","comments":true,"path":"posts/BZOJ3997/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3997/","excerpt":"","text":"题面在这里 ​ 把每个物品看作一个点，其实就是求DAG的最小链覆盖 根据\\(Dilworth\\)定理，DAG最小链覆盖=最大点独立集=最长反链 然后这个网格图就可以DP了 \\(f_{i,j}\\)表示最长反链左下角在\\((i,j)\\)的最长长度 \\(f_{i,j}=Max\\{ f_{i-1,j},f_{i,j+1},f_{i-1,j+1}+a_{i,j} \\}\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1005;int tst,n,m,a[maxn][maxn];ll f[maxn][maxn];int main()&#123; tst=red(); while (tst--)&#123; n=red(),m=red(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) a[i][j]=red(); for (int i=1;i&lt;=n;i++) for (int j=m;j&gt;=1;j--) f[i][j]=max(max(f[i-1][j],f[i][j+1]),f[i-1][j+1]+a[i][j]); printf(\"%lld\\n\",f[n][1]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"递推","slug":"递推","permalink":"http://oi.linkfqy.top/tags/递推/"}]},{"title":"BZOJ1002 [FJOI2007]轮状病毒","slug":"BZOJ1002","date":"2018-07-22T00:43:46.000Z","updated":"2018-07-22T00:49:32.000Z","comments":true,"path":"posts/BZOJ1002/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1002/","excerpt":"","text":"题面在这里 ​ 竟然不取模差评…… 写高精度的话\\(O(N^3)\\)暴力就不能过了 虽然有递推式\\(f_i=3f_{i-1}-f_{i-2}+2\\)我选择打表【逃 ​ 代码就不贴了","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"http://oi.linkfqy.top/tags/矩阵树定理/"}]},{"title":"BZOJ2763 [JLOI2011]飞行路线","slug":"BZOJ2763","date":"2018-07-19T09:10:19.000Z","updated":"2018-07-19T09:10:34.000Z","comments":true,"path":"posts/BZOJ2763/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2763/","excerpt":"","text":"题面在这里 ​ 水水更健康…… ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=10005,maxe=100005,maxs=maxn*12;int n,e,K,S,T;int tot,son[maxe],lnk[maxn],nxt[maxe],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;struct p&#123; int x,t; p() &#123;&#125; p(int _x,int _t):x(_x),t(_t) &#123;&#125;&#125;que[maxs];int dst[maxn][12];bool vis[maxn][12];void spfa()&#123; cl(dst,63);cl(vis,0); int hed=0,til=1; que[1]=p(S,0);dst[S][0]=0; while (hed!=til)&#123; int x=que[hed=(hed+1)%maxs].x,t=que[hed].t; vis[x][t]=0; for (int j=lnk[x];j;j=nxt[j])&#123; if (dst[son[j]][t]&gt;dst[x][t]+w[j])&#123; dst[son[j]][t]=dst[x][t]+w[j]; if (!vis[son[j]][t]) vis[son[j]][t]=1,que[til=(til+1)%maxs]=p(son[j],t); &#125; if (t&lt;K&amp;&amp;dst[son[j]][t+1]&gt;dst[x][t])&#123; dst[son[j]][t+1]=dst[x][t]; if (!vis[son[j]][t+1]) vis[son[j]][t+1]=1,que[til=(til+1)%maxs]=p(son[j],t+1); &#125; &#125; &#125;&#125;int main()&#123; scanf(\"%d%d%d%d%d\",&amp;n,&amp;e,&amp;K,&amp;S,&amp;T);S++,T++; for (int i=1,x,y,z;i&lt;=e;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),x++,y++,add(x,y,z),add(y,x,z); spfa(); int ans=0x3f3f3f3f; for (int i=0;i&lt;=K;i++) ans=min(ans,dst[T][i]); printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"}]},{"title":"BZOJ1026 [SCOI2009]windy数","slug":"BZOJ1026","date":"2018-07-19T07:42:06.000Z","updated":"2018-07-19T07:46:52.000Z","comments":true,"path":"posts/BZOJ1026/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1026/","excerpt":"","text":"题面在这里 ​ 数位DP写起来很简单，但是很难想啊…… 发现果然还是记忆化搜索好写 定义\\(dfs(step,last,less,first)​\\)表示处理到step位，上一位是last，是否小于给定数，是否含有前导零 然后就好了 ​ 示例程序： 123456789101112131415161718192021222324252627#include&lt;cstdio&gt;#include&lt;cstring&gt;#define _abs(x) ((x)&lt;0?-(x):(x))#define cl(x,y) memset(x,y,sizeof(x))const int maxn=15;int l,r,f[maxn][maxn];int a[maxn],len;int dfs(int stp,int lst,bool ls,bool fir)&#123; if (stp==0) return 1; if (ls&amp;&amp;!fir&amp;&amp;f[stp][lst]!=-1) return f[stp][lst]; int now=ls?9:a[stp],res=0; for (int i=0;i&lt;=now;i++) if (fir||_abs(i-lst)&gt;=2) res+=dfs(stp-1,i,ls||i&lt;a[stp],fir&amp;&amp;!i); return !ls||fir?res:f[stp][lst]=res;&#125;int calc(int x)&#123; len=0; for (;x;x/=10) a[++len]=x%10; return dfs(len,0,0,1);&#125;int main()&#123; scanf(\"%d%d\",&amp;l,&amp;r); cl(f,-1); printf(\"%d\",calc(r)-calc(l-1)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"数位DP","slug":"数位DP","permalink":"http://oi.linkfqy.top/tags/数位DP/"}]},{"title":"BZOJ3626 [LNOI2014]LCA","slug":"BZOJ3626","date":"2018-07-17T11:21:35.000Z","updated":"2018-07-17T11:28:42.000Z","comments":true,"path":"posts/BZOJ3626/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3626/","excerpt":"","text":"题面在这里 ​ 考虑\\(deep_i\\)到底表示的是什么东西 其实就是\\(i\\)到根路径上有几个点 即对于任意\\(i\\in [l,r]\\)，\\(i\\)到根路径上每个点对答案的贡献都是1 如果对每个\\(i\\)到根路径上点权都加一，\\(z\\)的答案就是\\(z\\)到根路径上点权之和 这个可以用树链剖分实现 然后对所有询问离线，差分求区间和 时间复杂度\\(O(nlog^2_2n)\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define nc getchar#include&lt;vector&gt;#define pb push_back#define mp make_pairusing namespace std;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=50005,maxe=maxn,maxs=maxn*4,MOD=201314;int n,q,ans[maxn];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;int fa[maxn],H_son[maxn],dep[maxn],siz[maxn],top[maxn],id[maxn],times;void mkdep(int x,int f)&#123; dep[x]=dep[f]+1;fa[x]=f;siz[x]=1; for (int j=lnk[x];j;j=nxt[j])&#123; mkdep(son[j],x);siz[x]+=siz[son[j]]; if (!H_son[x]||siz[H_son[x]]&lt;siz[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst;id[x]=++times; if (H_son[x]) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=H_son[x]) dfs(son[j],son[j]);&#125;int tre[maxs],tag[maxs];inline void pushdown(int x,int L,int R)&#123; if (tag[x]==0||L==R) return; int mid=L+R&gt;&gt;1; (tre[x&lt;&lt;1]+=(mid-L+1)*tag[x])%=MOD; (tag[x&lt;&lt;1]+=tag[x])%=MOD; (tre[x&lt;&lt;1|1]+=(R-mid)*tag[x])%=MOD; (tag[x&lt;&lt;1|1]+=tag[x])%=MOD; tag[x]=0;&#125;void insert(int x,int L,int R,int ql,int qr,int w)&#123; if (qr&lt;L||R&lt;ql) return; if (ql&lt;=L&amp;&amp;R&lt;=qr) &#123;(tre[x]+=(R-L+1)*w)%=MOD;(tag[x]+=w)%=MOD;return;&#125; int mid=L+R&gt;&gt;1; pushdown(x,L,R); insert(x&lt;&lt;1,L,mid,ql,qr,w);insert(x&lt;&lt;1|1,mid+1,R,ql,qr,w); tre[x]=(tre[x&lt;&lt;1]+tre[x&lt;&lt;1|1])%MOD;&#125;int query(int x,int L,int R,int ql,int qr)&#123; if (qr&lt;L||R&lt;ql) return 0; if (ql&lt;=L&amp;&amp;R&lt;=qr) return tre[x]; int mid=L+R&gt;&gt;1; pushdown(x,L,R); return (query(x&lt;&lt;1,L,mid,ql,qr)+query(x&lt;&lt;1|1,mid+1,R,ql,qr))%MOD;&#125;void ist(int x,int y,int w)&#123; if (!y) return; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); insert(1,1,n,id[top[x]],id[x],w); x=fa[top[x]]; &#125; if (id[x]&gt;id[y]) swap(x,y); insert(1,1,n,id[x],id[y],w);&#125;int qry(int x,int y)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); (res+=query(1,1,n,id[top[x]],id[x]))%=MOD; x=fa[top[x]]; &#125; if (id[x]&gt;id[y]) swap(x,y); return (res+query(1,1,n,id[x],id[y]))%MOD;&#125;vector&lt;pair&lt;int,int&gt; &gt; Ql[maxn],Qr[maxn];int main()&#123; n=red(),q=red(); for (int i=2,fa;i&lt;=n;i++) fa=red()+1,add(fa,i); mkdep(1,1);dfs(1,1); for (int i=1;i&lt;=q;i++)&#123; int l=red()+1,r=red()+1,x=red()+1; Ql[l-1].pb(mp(i,x)); Qr[r].pb(mp(i,x)); &#125; for (int i=1;i&lt;=n;i++)&#123; ist(1,i,1); for (int j=0;j&lt;Ql[i].size();j++) (ans[Ql[i][j].first]-=qry(1,Ql[i][j].second))%=MOD; for (int j=0;j&lt;Qr[i].size();j++) (ans[Qr[i][j].first]+=qry(1,Qr[i][j].second))%=MOD; &#125; for (int i=1;i&lt;=q;i++) printf(\"%d\\n\",(ans[i]+MOD)%MOD); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"【树形背包】BZOJ4033 [HAOI2015]树上染色","slug":"BZOJ4033","date":"2018-07-17T07:24:15.000Z","updated":"2018-07-17T07:38:44.000Z","comments":true,"path":"posts/BZOJ4033/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4033/","excerpt":"","text":"题面在这里 ​ 树形背包第一题…… 这题只要考虑子树到父节点的边对答案的贡献即可，即： \\[ w\\cdot (k(K-k)+(s_y-k)(n-K-(s_y-k))) \\] 然后定义\\(f_{i,j}\\)表示子树i内有j个黑点，子树i内的边对答案的贡献 然后把黑点看成物品就是树形背包了 树形背包的转移方法就是把子树一个一个地合并进来 所以不能把所有子树答案先求出来，size也要一边求一边DP ​ 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=2005,maxe=4005;int n,K,s[maxn];ll f[maxn][maxn];int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;void dfs(int x,int fa)&#123; s[x]=1; for (int i=lnk[x];i;i=nxt[i])if (son[i]!=fa)&#123; int y=son[i]; dfs(y,x); for (int j=min(K,s[x]);j&gt;=0;j--) for (int k=min(K,s[y]);k&gt;=0;k--) if (j+k&lt;=K) f[x][j+k]=max(f[x][j+k],f[x][j]+f[y][k]+(ll)w[i]*(k*(K-k)+(s[y]-k)*(n-K-(s[y]-k)))); s[x]+=s[y]; &#125;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1,x,y,z;i&lt;n;i++) scanf(\"%d%d%d\",&amp;x,&amp;y,&amp;z),add(x,y,z),add(y,x,z); dfs(1,1); printf(\"%lld\",f[1][K]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树形DP","slug":"树形DP","permalink":"http://oi.linkfqy.top/tags/树形DP/"}]},{"title":"【状压DP】BZOJ2734 [HNOI2012]集合选数","slug":"BZOJ2734","date":"2018-07-17T02:31:52.000Z","updated":"2018-07-17T02:31:52.000Z","comments":true,"path":"posts/BZOJ2734/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2734/","excerpt":"","text":"题面在这里 ​ 一开始看毫无头绪，可以建立这样一个矩阵： \\[ x\\ \\ 3x\\ \\ 9x \\dots \\\\ 2x\\ \\ 6x\\ \\ 18x \\dots \\\\ 4x\\ \\ 12x\\ \\ 36x \\dots \\\\ \\dots \\] 然后就是不能取相邻格子，因为\\(logn\\)比较小，直接状压就好了…… ​ 复杂度有点玄学啊…… 卡了好久才过 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;const int MOD=1e9+1,maxn=20,maxm=13,maxs=1&lt;&lt;13;int n,e,N,M;ll f[maxn][maxs],pw2[maxn],pw3[maxn],ans;void maker()&#123; N=M=1;pw2[0]=pw3[0]=1; for (int i=1;pw2[i-1]*2&lt;=n;i++) pw2[i]=pw2[i-1]*2,N++; for (int i=1;pw3[i-1]*3&lt;=n;i++) pw3[i]=pw3[i-1]*3,M++;&#125;int highbit(int j) &#123;for (int t=M;t;t--) if (j&amp;(1&lt;&lt;t-1)) return t;return 0;&#125;ll DP(int x)&#123; N=M=1; for (int i=x;i*2&lt;=n;i*=2) N++; for (int i=x;i*3&lt;=n;i*=3) M++; for (int i=1;i&lt;=N;i++) for (int j=0;j&lt;(1&lt;&lt;M);j++) f[i][j]=0; f[0][0]=1; for (int i=1;i&lt;=N;i++) for (int j=0;j&lt;(1&lt;&lt;M);j++)&#123; if (j&amp;(j&gt;&gt;1)) continue;ll w=pw2[i-1]*pw3[highbit(j)-1]*(j!=0); if (w&gt;n||x*w&gt;n) break; for (int k=0;k&lt;(1&lt;&lt;M);k++) if (!(k&amp;j)) (f[i][j]+=f[i-1][k])%=MOD; &#125; ll res=0; for (int j=0;j&lt;(1&lt;&lt;M);j++) (res+=f[N][j])%=MOD; return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); maker(); ans=1; for (int i=1;i&lt;=n;i++) if (i%2!=0&amp;&amp;i%3!=0) (ans*=DP(i))%=MOD; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"}]},{"title":"【lis】洛谷P3365 改造二叉树","slug":"luogu_P3365","date":"2018-07-16T06:55:03.000Z","updated":"2018-07-16T06:57:54.000Z","comments":true,"path":"posts/luogu_P3365/","link":"","permalink":"http://oi.linkfqy.top/posts/luogu_P3365/","excerpt":"","text":"题面在这里 ​ 因为要满足\\(a_i-a_j\\ge i-j\\)即\\(a_i-i\\ge a_j-j\\) 那么对\\(\\{ a_i-i \\}\\)这个序列做最长不降子序列就好了 ​ 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=100005,maxe=maxn;int n,m,w[maxn],a[maxn],lnk[maxn][2],g[maxn];void dfs(int x)&#123; if (lnk[x][0]) dfs(lnk[x][0]); a[++m]=w[x]; if (lnk[x][1]) dfs(lnk[x][1]);&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;w[i]); for (int i=2,fa,s;i&lt;=n;i++) scanf(\"%d%d\",&amp;fa,&amp;s),lnk[fa][s]=i; dfs(1); for (int i=1;i&lt;=n;i++) a[i]-=i; int len=1;g[1]=a[1]; for (int i=2;i&lt;=n;i++) if (g[len]&lt;=a[i]) g[++len]=a[i];else *upper_bound(g+1,g+1+len,a[i])=a[i]; printf(\"%d\",n-len); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"LIS","slug":"LIS","permalink":"http://oi.linkfqy.top/tags/LIS/"},{"name":"洛谷","slug":"洛谷","permalink":"http://oi.linkfqy.top/tags/洛谷/"}]},{"title":"BZOJ4057 [Cerc2012]Kingdoms","slug":"BZOJ4057","date":"2018-07-14T09:45:22.000Z","updated":"2018-07-14T09:47:16.000Z","comments":true,"path":"posts/BZOJ4057/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4057/","excerpt":"","text":"题面在这里 ​ 直接状压DP就好了…… 时间复杂度\\(O(n^2\\cdot 2^n)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=25,maxs=(1&lt;&lt;20)+5;int tst,n,d[maxn][maxn],a[maxn],mon[maxn];bool f[maxs];int main()&#123; tst=red(); while (tst--)&#123; n=red(); for (int i=0;i&lt;n;i++) for (int j=0;j&lt;n;j++) d[i][j]=red(); cl(f,0); f[(1&lt;&lt;n)-1]=1; for (int s=(1&lt;&lt;n)-1;s;s--)&#123; a[0]=0; for (int i=0;i&lt;n;i++) if (s&amp;(1&lt;&lt;i)) a[++a[0]]=i,mon[i]=0; for (int i=1;i&lt;=a[0];i++) for (int j=1;j&lt;=a[0];j++) mon[a[i]]-=d[a[i]][a[j]]; for (int i=1;i&lt;=a[0];i++) if (mon[a[i]]&lt;0) f[s^(1&lt;&lt;a[i])]|=f[s]; &#125; bool fir=1; for (int i=0;i&lt;n;i++) if (f[1&lt;&lt;i]) if (fir) printf(\"%d\",i+1),fir=0;else printf(\" %d\",i+1); if (fir) printf(\"0\"); if (tst) putchar('\\n'); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"状压DP","slug":"状压DP","permalink":"http://oi.linkfqy.top/tags/状压DP/"}]},{"title":"BZOJ1232 [Usaco2008Nov]安慰奶牛cheer","slug":"BZOJ1232","date":"2018-07-14T07:12:27.000Z","updated":"2018-07-14T07:17:44.000Z","comments":true,"path":"posts/BZOJ1232/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1232/","excerpt":"","text":"题面在这里 ​ 题目意思不清楚……其实是DFS遍历的意思 这样每条边被算了2次，点被算了度数次，起点再加一次 考虑每条边对答案的贡献，就是端点点权+边权*2 然后取最小点权作为起点就好了 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=10005,maxe=100005;int n,e,c[maxn],f[maxn],fa[maxn];ll ans;inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;struct edge&#123; int x,y,w; bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe];void kruskal()&#123; for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++)&#123; if (getfa(a[i].x)==getfa(a[i].y)) continue; fa[getfa(a[i].x)]=getfa(a[i].y); ans+=a[i].w*2;f[a[i].x]++;f[a[i].y]++; &#125;&#125;int main()&#123; n=red(),e=red();int mn=0x3f3f3f3f; for (int i=1;i&lt;=n;i++) c[i]=red(),mn=min(mn,c[i]); for (int i=1;i&lt;=e;i++) a[i].x=red(),a[i].y=red(),a[i].w=red()*2+c[a[i].x]+c[a[i].y]; sort(a+1,a+1+e); for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++)&#123; if (getfa(a[i].x)==getfa(a[i].y)) continue; fa[getfa(a[i].x)]=getfa(a[i].y);ans+=a[i].w; &#125; printf(\"%lld\",ans+mn); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"}]},{"title":"BZOJ3396 [Usaco2009 Jan]Total flow 水流","slug":"BZOJ3396","date":"2018-07-13T13:12:15.000Z","updated":"2018-07-14T00:06:46.000Z","comments":true,"path":"posts/BZOJ3396/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3396/","excerpt":"","text":"题面在这里 水水更健康…… 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define nc getchar#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char fstchar()&#123; char ch=nc();while (ch&lt;=32) ch=nc(); return ch;&#125;const int maxn=255,maxe=2005,INF=0x3f3f3f3f;int e,S,T;int tot,son[maxe],nxt[maxe],lnk[maxn],cap[maxe],flw[maxe],pos[maxn];inline void add(int x,int y,int w)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;flw[tot]=0;cap[tot]=w; son[++tot]=x;nxt[tot]=lnk[y];lnk[y]=tot;flw[tot]=0;cap[tot]=0;&#125;int que[maxn],d[maxn];bool bfs()&#123; cl(d,63); int hed=0,til=1; que[til]=S;d[S]=0; while (hed!=til)&#123; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j]) if (d[son[j]]==INF&amp;&amp;flw[j]&lt;cap[j]) que[++til]=son[j],d[son[j]]=d[x]+1; &#125; return d[T]!=INF;&#125;int dfs(int x,int flow)&#123; if (x==T||flow==0) return flow; int res=0,f; for (int &amp;j=pos[x];j;j=nxt[j]) if (d[son[j]]==d[x]+1&amp;&amp;(f=dfs(son[j],min(flow,cap[j]-flw[j])))&gt;0)&#123; flw[j]+=f;flw[j^1]-=f; res+=f;flow-=f; if (flow==0) break; &#125; return res;&#125;int main()&#123; scanf(\"%d\",&amp;e);S='A',T='Z';tot=1; for (int i=1;i&lt;=e;i++)&#123; char x=fstchar(),y=fstchar();int w;scanf(\"%d\",&amp;w); add(x,y,w); &#125; int ans=0; while (bfs())&#123; memcpy(pos,lnk,sizeof(pos)); ans+=dfs(S,INF); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"}]},{"title":"BZOJ4385 [POI2015]Wilcze doły","slug":"BZOJ4385","date":"2018-07-13T12:04:16.000Z","updated":"2018-07-13T12:10:26.000Z","comments":true,"path":"posts/BZOJ4385/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4385/","excerpt":"","text":"题面在这里 首先很明显选择删除的区间长度为d 那么定义\\(g_i=s_i-s_{i-d+1}\\)表示以i为结尾的区间和 然后two pointers枚举区间，满足\\(s_{(i,j)}-g_{max}\\le p\\) \\(g_{max}\\)就是区间内g的最大值，用单调队列维护就好了 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=2000005;int n,l,a[maxn],que[maxn];ll s[maxn],g[maxn],S;int main()&#123; scanf(\"%d%lld%d\",&amp;n,&amp;S,&amp;l); for (int i=1;i&lt;=n;i++) a[i]=red(),s[i]=s[i-1]+a[i],g[i]=s[i]-s[max(i-l,0)]; int ans=l,hed=1,til=0; for (int i=1,j=1;i&lt;=n;i++)&#123; while (hed&lt;=til&amp;&amp;g[que[til]]&lt;=g[i]) til--; que[++til]=i; while (s[i]-s[j-1]-g[que[hed]]&gt;S)&#123; j++;if (hed&lt;=til&amp;&amp;que[hed]-l&lt;j-1) hed++; &#125; ans=max(ans,i-j+1); &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"单调队列","slug":"单调队列","permalink":"http://oi.linkfqy.top/tags/单调队列/"}]},{"title":"BZOJ4998 星球联盟","slug":"BZOJ4998","date":"2018-07-13T08:40:09.000Z","updated":"2018-07-13T09:40:36.000Z","comments":true,"path":"posts/BZOJ4998/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4998/","excerpt":"","text":"题面在这里 首先离线做出最后情况的生成树 然后如果询问的边是非树边，就用并查集把路径上的点合并 如果树边就是NO 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=200005,maxe=400005;int n,e,q,qx[maxe],qy[maxe],fa[maxn],f[maxn],s[maxn],dep[maxn];bool tedge[maxe];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;inline int getf(int x) &#123;return f[x]==x?x:f[x]=getf(f[x]);&#125;//inline int getF(int x) &#123;return F[x]==x?x:F[x]=getF(F[x]);&#125;void dfs(int x)&#123; dep[x]=dep[fa[x]]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x]) fa[son[j]]=x,dfs(son[j]);&#125;inline void merge(int x,int y)&#123; x=getf(x);y=getf(y); while (x!=y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); int fx=getf(fa[x]); f[x]=fx;s[fx]+=s[x]; x=fx; &#125;&#125;int main()&#123; n=red(),e=red(),q=red();int E=e+q; for (int i=1;i&lt;=n;i++) f[i]=i; for (int i=1;i&lt;=E;i++)&#123; qx[i]=red(),qy[i]=red(); if (getf(qx[i])!=getf(qy[i])) f[getf(qx[i])]=getf(qy[i]),tedge[i]=1,add(qx[i],qy[i]),add(qy[i],qx[i]); &#125; for (int i=1;i&lt;=n;i++) if (!fa[i]) fa[i]=i,dfs(i); for (int i=1;i&lt;=n;i++) f[i]=i,s[i]=1; for (int i=1;i&lt;=e;i++) if (!tedge[i]) merge(qx[i],qy[i]); for (int i=e+1;i&lt;=E;i++) if (tedge[i]) puts(\"No\");else&#123; merge(qx[i],qy[i]); printf(\"%d\\n\",s[getf(qx[i])]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"离线","slug":"离线","permalink":"http://oi.linkfqy.top/tags/离线/"}]},{"title":"HDU6165 FFF at Valentine","slug":"HDU6165","date":"2018-07-11T22:23:09.000Z","updated":"2018-07-11T22:28:00.000Z","comments":true,"path":"posts/HDU6165/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU6165/","excerpt":"","text":"题面在这里 ​ 首先环内的点一定可以互通，先缩点 然后刷拓扑，如果同时出现两个入度为0的点就验证失败 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1005,maxe=6005;int tst,n,e;namespace A&#123; int tot,son[maxe],nxt[maxe],lnk[maxn]; inline void add(int x,int y)&#123;// printf(\"A: %d %d\\n\",x,y); son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot; &#125;&#125;namespace B&#123; int tot,son[maxe],nxt[maxe],lnk[maxn],f[maxn]; inline void add(int x,int y)&#123;// printf(\"B: %d %d\\n\",x,y); son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;f[y]++; &#125;&#125;int times,dfn[maxn],low[maxn],stk[maxn],to[maxn];bool instk[maxn];void Tarjan(int x)&#123; using namespace A; dfn[x]=low[x]=++times;stk[++stk[0]]=x;instk[x]=1; for (int j=lnk[x];j;j=nxt[j]) if (!dfn[son[j]]) Tarjan(son[j]),low[x]=min(low[x],low[son[j]]);else if (instk[son[j]]) low[x]=min(low[x],dfn[son[j]]); if (dfn[x]==low[x])&#123; while (stk[stk[0]+1]!=x)&#123; instk[stk[stk[0]]]=0;to[stk[stk[0]--]]=x; &#125; &#125;&#125;int que[maxn];bool topo()&#123; using namespace B; int hed=0,til=0; for (int i=1;i&lt;=n;i++) if (!f[i]&amp;&amp;to[i]==i) que[++til]=i; while (hed!=til)&#123; if (til-hed&gt;=2) return 0; int x=que[++hed]; for (int j=lnk[x];j;j=nxt[j])&#123; f[son[j]]--; if (!f[son[j]]) que[++til]=son[j]; &#125; &#125; return 1;&#125;int main()&#123; tst=red(); while (tst--)&#123; n=red(),e=red(); A::tot=0;cl(A::lnk,0); B::tot=0;cl(B::lnk,0);cl(B::f,0); for (int i=1,x,y;i&lt;=e;i++) x=red(),y=red(),A::add(x,y); times=0,cl(dfn,0);cl(stk,0);cl(low,0);cl(instk,0);cl(to,0); for (int i=1;i&lt;=n;i++) if (!dfn[i]) Tarjan(i); &#123; using namespace A; for (int i=1;i&lt;=n;i++) for (int j=lnk[i];j;j=nxt[j]) if (to[i]!=to[son[j]]) B::add(to[i],to[son[j]]); &#125; if (topo()) puts(\"I love you my love and our love save us!\");else puts(\"Light my fire!\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"强连通分量","slug":"强连通分量","permalink":"http://oi.linkfqy.top/tags/强连通分量/"},{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"}]},{"title":"BZOJ3038 上帝造题的七分钟2","slug":"BZOJ3038","date":"2018-07-10T09:44:50.000Z","updated":"2018-07-10T09:49:02.000Z","comments":true,"path":"posts/BZOJ3038/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3038/","excerpt":"","text":"题面在这里 水水更健康…… 示例程序： 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=100005;int n,q,fa[maxn];ll BIT[maxn],a[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;#define lowbit(x) ((x)&amp;-(x))inline void ist(int x,ll w)&#123; for (int i=x;i&lt;=n;i+=lowbit(i)) BIT[i]+=w;&#125;inline ll qry(int x)&#123; ll res=0; for (int i=x;i;i-=lowbit(i)) res+=BIT[i]; return res;&#125;void change(int l,int r)&#123; for (int i=getfa(l);i&lt;=r;i=getfa(i+1))&#123; ist(i,(ll)sqrt(a[i])-a[i]);a[i]=sqrt(a[i]); if (a[i]&lt;=1) fa[getfa(i)]=getfa(i+1); &#125;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%lld\",&amp;a[i]),fa[i]=i,ist(i,a[i]);fa[n+1]=n+1; scanf(\"%d\",&amp;q); while (q--)&#123; int c,l,r;scanf(\"%d%d%d\",&amp;c,&amp;l,&amp;r); if (l&gt;r) swap(l,r); if (c==1) printf(\"%lld\\n\",qry(r)-qry(l-1));else change(l,r); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"BZOJ3211 花神游历各国","slug":"BZOJ3211","date":"2018-07-10T09:44:50.000Z","updated":"2018-07-10T09:48:36.000Z","comments":true,"path":"posts/BZOJ3211/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3211/","excerpt":"","text":"题面在这里 水水更健康…… 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;cstdio&gt;#include&lt;cmath&gt;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;int n,q,fa[maxn],a[maxn];ll BIT[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;#define lowbit(x) ((x)&amp;-(x))inline void ist(int x,int w)&#123; for (int i=x;i&lt;=n;i+=lowbit(i)) BIT[i]+=w;&#125;inline ll qry(int x)&#123; ll res=0; for (int i=x;i;i-=lowbit(i)) res+=BIT[i]; return res;&#125;void change(int l,int r)&#123; for (int i=getfa(l);i&lt;=r;i=getfa(i+1))&#123; ist(i,(int)sqrt(a[i])-a[i]);a[i]=sqrt(a[i]); if (a[i]&lt;=1) fa[getfa(i)]=getfa(i+1); &#125;&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) a[i]=red(),fa[i]=i,ist(i,a[i]);fa[n+1]=n+1; q=red(); while (q--)&#123; int c=red(),l=red(),r=red(); if (c==1) printf(\"%lld\\n\",qry(r)-qry(l-1));else change(l,r); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"BZOJ3732 Network","slug":"BZOJ3732","date":"2018-07-10T02:11:26.000Z","updated":"2018-07-10T04:34:06.000Z","comments":true,"path":"posts/BZOJ3732/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3732/","excerpt":"","text":"题面在这里 ​ 显然答案就在最小生成树上…… 水水更健康 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=15005,maxe=30005;int n,e,q,fa[maxn];struct edge&#123; int x,y,w; bool operator&lt;(const edge&amp;b)const &#123;return w&lt;b.w;&#125;&#125;a[maxe];int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int tot,son[maxe],nxt[maxe],lnk[maxn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;void kruskal()&#123; for (int i=1;i&lt;=n;i++) fa[i]=i; for (int i=1;i&lt;=e;i++)&#123; if (getfa(a[i].x)==getfa(a[i].y)) continue; fa[getfa(a[i].x)]=getfa(a[i].y); add(a[i].x,a[i].y,a[i].w);add(a[i].y,a[i].x,a[i].w); &#125;&#125;int f[maxn][15],g[maxn][15],dep[maxn];void dfs(int x,int fa)&#123; f[x][0]=fa;dep[x]=dep[fa]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) g[son[j]][0]=w[j],dfs(son[j],x);&#125;void DP()&#123; for (int j=1;j&lt;15;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1], g[i][j]=max(g[i][j-1],g[f[i][j-1]][j-1]);&#125;int LCA(int x,int y)&#123; int res=0; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=14;j&gt;=0;j--) if (dep[f[x][j]]&gt;=dep[y]) res=max(res,g[x][j]),x=f[x][j]; if (x==y) return res; for (int j=14;j&gt;=0;j--) if (f[x][j]!=f[y][j]) res=max(res,max(g[x][j],g[y][j])),x=f[x][j],y=f[y][j]; return max(res,max(g[x][0],g[y][0]));&#125;int main()&#123; n=red(),e=red(),q=red(); for (int i=1;i&lt;=e;i++) a[i].x=red(),a[i].y=red(),a[i].w=red(); sort(a+1,a+1+e); kruskal(); dfs(1,1);DP(); for (int i=1,x,y;i&lt;=q;i++) x=red(),y=red(),printf(\"%d\\n\",LCA(x,y)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最小生成树","slug":"最小生成树","permalink":"http://oi.linkfqy.top/tags/最小生成树/"},{"name":"LCA","slug":"LCA","permalink":"http://oi.linkfqy.top/tags/LCA/"}]},{"title":"BZOJ2761 [JLOI2011]不重复数字","slug":"BZOJ2761","date":"2018-07-09T06:43:42.000Z","updated":"2018-07-09T06:45:46.000Z","comments":true,"path":"posts/BZOJ2761/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2761/","excerpt":"","text":"题面在这里 水水更健康 示例程序： 1234567891011121314151617181920212223242526272829#include&lt;cstdio&gt;#include&lt;set&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=50005;int tst,n;set&lt;int&gt; S;int main()&#123; tst=red(); while (tst--)&#123; n=red();S.clear(); for (int i=1;i&lt;=n;i++)&#123; int x=red(); if (S.count(x)==0) printf(\"%d \",x),S.insert(x); &#125;putchar('\\n'); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"水题","slug":"水题","permalink":"http://oi.linkfqy.top/tags/水题/"}]},{"title":"BZOJ4195 [Noi2015]程序自动分析","slug":"BZOJ4195","date":"2018-07-09T06:13:05.000Z","updated":"2018-07-09T06:18:32.000Z","comments":true,"path":"posts/BZOJ4195/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4195/","excerpt":"","text":"题面在这里 水水更健康 示例程序： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=2000005,MOD=19260817;int tst,n,fa[MOD],x[maxn],y[maxn],c[maxn];inline int getfa(int x) &#123;return fa[x]==x?x:fa[x]=getfa(fa[x]);&#125;int main()&#123; tst=red(); while (tst--)&#123; int suc=1; n=red(); for (int i=1;i&lt;=n;i++) x[i]=red(),y[i]=red(),c[i]=red(); for (int i=1;i&lt;MOD;i++) fa[i]=i; for (int i=1;i&lt;=n;i++) if (c[i]) fa[getfa(x[i]%MOD)]=getfa(y[i]%MOD); for (int i=1;i&lt;=n;i++) if (!c[i]&amp;&amp;getfa(x[i]%MOD)==getfa(y[i]%MOD)) &#123;suc=0;break;&#125; puts(suc?\"YES\":\"NO\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"并查集","slug":"并查集","permalink":"http://oi.linkfqy.top/tags/并查集/"}]},{"title":"BZOJ4196 [Noi2015]软件包管理器","slug":"BZOJ4196","date":"2018-07-09T03:14:43.000Z","updated":"2018-07-09T03:19:22.000Z","comments":true,"path":"posts/BZOJ4196/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4196/","excerpt":"","text":"题面在这里 ​ 直接树链剖分就好了……练代码熟练度 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;#define nc getcharinline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxs=400005;int n,q,fa[maxn],dep[maxn],top[maxn],H_son[maxn],sum[maxn],in[maxn],out[maxn],times=0;int tot,lnk[maxn],nxt[maxn],son[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void mkH(int x)&#123; H_son[x]=-1;sum[x]=1; for (int j=lnk[x];j;j=nxt[j])&#123; dep[son[j]]=dep[x]+1; mkH(son[j]); sum[x]+=sum[son[j]]; if (H_son[x]&lt;0||sum[H_son[x]]&lt;sum[son[j]]) H_son[x]=son[j]; &#125;&#125;void dfs(int x,int lst)&#123; top[x]=lst; in[x]=++times; if (H_son[x]&gt;=0) dfs(H_son[x],lst); for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=H_son[x]) dfs(son[j],son[j]); out[x]=times;&#125;int s[maxs],tag[maxs];inline void pushdown(int x,int L,int mid,int R)&#123; if (L==R||tag[x]&lt;0) return; tag[x&lt;&lt;1]=tag[x&lt;&lt;1|1]=tag[x]; s[x&lt;&lt;1]=tag[x]*(mid-L+1); s[x&lt;&lt;1|1]=tag[x]*(R-mid); tag[x]=-1;&#125;void insert(int x,int L,int R,int ql,int qr,int k)&#123; if (L&gt;R||qr&lt;L||R&lt;ql) return; if (ql&lt;=L&amp;&amp;R&lt;=qr) &#123;s[x]=(R-L+1)*k,tag[x]=k;return;&#125; int mid=L+R&gt;&gt;1; pushdown(x,L,mid,R); insert(x&lt;&lt;1,L,mid,ql,qr,k); insert(x&lt;&lt;1|1,mid+1,R,ql,qr,k); s[x]=s[x&lt;&lt;1]+s[x&lt;&lt;1|1];&#125;int query(int x,int L,int R,int ql,int qr)&#123; if (L&gt;R||qr&lt;L||R&lt;ql) return 0; if (ql&lt;=L&amp;&amp;R&lt;=qr) return s[x]; int mid=L+R&gt;&gt;1; pushdown(x,L,mid,R); return query(x&lt;&lt;1,L,mid,ql,qr)+query(x&lt;&lt;1|1,mid+1,R,ql,qr);&#125;void ist(int x,int y,int k)&#123; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); insert(1,1,n,in[top[x]],in[x],k); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); insert(1,1,n,in[x],in[y],k);&#125;int qry(int x,int y)&#123; int res=0; while (top[x]!=top[y])&#123; if (dep[top[x]]&lt;dep[top[y]]) swap(x,y); res+=query(1,1,n,in[top[x]],in[x]); x=fa[top[x]]; &#125; if (in[x]&gt;in[y]) swap(x,y); res+=query(1,1,n,in[x],in[y]); return res; &#125;char str[20];int main()&#123; n=red(); for (int i=1;i&lt;n;i++) fa[i]=red(),add(fa[i],i); dep[0]=1;mkH(0); dfs(0,0); cl(tag,-1); q=red(); while (q--)&#123; int x; scanf(\"%s%d\",str,&amp;x); if (str[0]=='i')&#123; printf(\"%d\\n\",dep[x]-qry(0,x)); ist(0,x,1); &#125;else&#123; printf(\"%d\\n\",query(1,1,n,in[x],out[x])); insert(1,1,n,in[x],out[x],0); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"},{"name":"树链剖分","slug":"树链剖分","permalink":"http://oi.linkfqy.top/tags/树链剖分/"}]},{"title":"【对偶图转最短路】BZOJ2007 [Noi2010]海拔","slug":"BZOJ2007","date":"2018-07-07T08:02:44.000Z","updated":"2018-07-07T08:31:08.000Z","comments":true,"path":"posts/BZOJ2007/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2007/","excerpt":"","text":"题面在这里 ​ 首先注意到海拔只可能是0或1 首先海拔不可能大于1，然后考虑与h相连的路口均为0,1 则代价为\\(h\\cdot a+(1-h)\\cdot b\\ge min\\{ a,b \\}\\)，a,b分别为与0,1相连的总流量 把单点类比到联通块上，这样的话只有西北一片0和东南一片1了 代价只在分界线上产生，其实就是要找最小割 这个恰好是平面图，对偶图刷最短路即可 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;queue&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=505,maxnn=250005,maxe=1000005,p[4][2]=&#123;&#123;-1,0&#125;,&#123;0,1&#125;,&#123;1,0&#125;,&#123;0,-1&#125;&#125;;int n,a[maxn][maxn][4],S,T;int tot,son[maxe],nxt[maxe],lnk[maxnn],w[maxe];inline void add(int x,int y,int z)&#123; son[++tot]=y,nxt[tot]=lnk[x],lnk[x]=tot,w[tot]=z;&#125;#define getid(x,y) (((x)-1)*n+(y))ll dst[maxnn];struct data&#123; int x;ll w; data () &#123;&#125; data (int _x,ll _w) &#123;x=_x;w=_w;&#125; bool operator&lt;(const data&amp;b)const &#123;return w&gt;b.w;&#125;&#125;;priority_queue&lt;data&gt; H;void DIJ()&#123; cl(dst,63); H.push(data(S,0));dst[S]=0; while (!H.empty())&#123; if (H.top().w&gt;dst[H.top().x]) &#123;H.pop();continue;&#125; int k=H.top().x; H.pop(); for (int j=lnk[k];j;j=nxt[j]) if (dst[son[j]]&gt;dst[k]+w[j]) dst[son[j]]=dst[k]+w[j],H.push(data(son[j],dst[son[j]])); &#125;&#125;int main()&#123; n=red();S=n*n+1;T=S+1; for (int i=0;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) a[i][j][0]=red(); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) a[i][j][1]=red(); for (int i=0;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) a[i][j][2]=red(); for (int i=1;i&lt;=n;i++) for (int j=0;j&lt;=n;j++) a[i][j][3]=red(); //make graph: for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=n;j++) for (int t=0;t&lt;4;t++)&#123; int x=i+p[t][0],y=j+p[t][1],w; if (y&lt;1) &#123;add(S,getid(i,j),a[x][y][(t+2)%4]);continue;&#125; if (x&gt;n) &#123;add(S,getid(i,j),a[i][j][(t+2)%4]);continue;&#125; if (t==1||t==2) w=a[i][j][t];else w=a[x][y][t]; if (x&lt;1||y&gt;n) add(getid(i,j),T,w);else add(getid(i,j),getid(x,y),w); &#125; DIJ(); printf(\"%lld\",dst[T]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"},{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"最短路","slug":"最短路","permalink":"http://oi.linkfqy.top/tags/最短路/"},{"name":"对偶图","slug":"对偶图","permalink":"http://oi.linkfqy.top/tags/对偶图/"}]},{"title":"BZOJ1832 [AHOI2008]聚会","slug":"BZOJ1832","date":"2018-07-06T06:39:18.000Z","updated":"2018-07-06T06:56:40.000Z","comments":true,"path":"posts/BZOJ1832/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1832/","excerpt":"","text":"题面在这里 ​ 两两求LCA，显然聚会城市是与另外两个不同的LCA 答案就是深度和减去LCA深度和 ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxe=1000005;int n,q,dep[maxn],f[maxn][20];int tot,son[maxe],nxt[maxe],lnk[maxn];inline void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x,int fa)&#123; f[x][0]=fa;dep[x]=dep[fa]+1; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x);&#125;inline void DP()&#123; for (int j=1;j&lt;20;j++) for (int i=1;i&lt;=n;i++) f[i][j]=f[f[i][j-1]][j-1];&#125;int LCA(int x,int y)&#123; if (dep[x]&lt;dep[y]) swap(x,y); for (int j=19;j&gt;=0;j--) if (dep[f[x][j]]&gt;=dep[y]) x=f[x][j]; if (x==y) return x; for (int j=19;j&gt;=0;j--) if (f[x][j]!=f[y][j]) x=f[x][j],y=f[y][j]; return f[x][0];&#125;int main()&#123; n=red(),q=red(); for (int i=1,x,y;i&lt;n;i++) x=red(),y=red(),add(x,y),add(y,x); dfs(1,1);DP(); while (q--)&#123; int x=red(),y=red(),z=red(); int a=LCA(x,y),b=LCA(y,z),c=LCA(z,x); if (a==b) printf(\"%d\",c);else if (b==c) printf(\"%d\",a);else printf(\"%d\",b); printf(\" %d\\n\",dep[x]+dep[y]+dep[z]-dep[a]-dep[b]-dep[c]); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"LCA","slug":"LCA","permalink":"http://oi.linkfqy.top/tags/LCA/"}]},{"title":"【动态开点线段树】BZOJ5358 [Lydsy1805月赛]口算训练","slug":"BZOJ5358","date":"2018-07-03T06:38:53.000Z","updated":"2018-07-03T06:57:02.000Z","comments":true,"path":"posts/BZOJ5358/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ5358/","excerpt":"","text":"题面在这里 对每个出现过的质因数建线段树 每次把d分解，看区间内是不是所有质因数都比d多 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005,maxs=maxn*300;int tst,n,q,a[maxn],p[maxn],lst[maxn];bool vis[maxn];void makeprime(int n)&#123; for (int i=2;i&lt;=n;i++)&#123; if (!vis[i]) p[++p[0]]=i,lst[i]=i; for (int j=1;j&lt;=p[0]&amp;&amp;i*p[j]&lt;=n;j++)&#123; vis[i*p[j]]=1;lst[i*p[j]]=p[j]; if (i%p[j]==0) break; &#125; &#125;&#125;int id,Rot[maxs],s[maxs],ls[maxs],rs[maxs];#define newnode (ls[++id]=0,rs[id]=0,s[id]=0,id)void ist(int &amp;x,int L,int R,int k)&#123; if (!x) x=newnode; if (L==R) &#123;s[x]++;return;&#125; int mid=L+R&gt;&gt;1; if (k&lt;=mid) ist(ls[x],L,mid,k);else ist(rs[x],mid+1,R,k); s[x]=s[ls[x]]+s[rs[x]];&#125;int qry(int &amp;x,int L,int R,int ql,int qr)&#123; if (!x||L&gt;R||qr&lt;L||R&lt;ql) return 0; if (ql&lt;=L&amp;&amp;R&lt;=qr) return s[x]; int mid=L+R&gt;&gt;1; return qry(ls[x],L,mid,ql,qr)+qry(rs[x],mid+1,R,ql,qr);&#125;inline bool check(int d,int l,int r)&#123; for (int j=d;j&gt;1;)&#123; int x=lst[j],tot=0; while (j%x==0) tot++,j/=x; if (qry(Rot[x],1,n,l,r)&lt;tot) return 0; &#125; return 1;&#125;int main()&#123; tst=red(); makeprime(1e5); while (tst--)&#123; n=red(),q=red(); cl(Rot,0);id=0; for (int i=1;i&lt;=n;i++)&#123; int x=a[i]=red(); for (int j=x;j&gt;1;j=j/lst[j]) ist(Rot[lst[j]],1,n,i); &#125; while (q--)&#123; int l=red(),r=red(),d=red(); printf(check(d,l,r)?\"Yes\\n\":\"No\\n\"); &#125; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"线段树","slug":"线段树","permalink":"http://oi.linkfqy.top/tags/线段树/"}]},{"title":"【矩阵树定理】BZOJ4031 [HEOI2015]小Z的房间","slug":"BZOJ4031","date":"2018-05-31T11:53:16.000Z","updated":"2018-05-31T11:57:50.000Z","comments":true,"path":"posts/BZOJ4031/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4031/","excerpt":"","text":"题面在这里 不解释…… 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;typedef ll matrix[200][200]; const int maxn=15,p[4][2]=&#123;&#123;1,0&#125;,&#123;0,1&#125;,&#123;-1,0&#125;,&#123;0,-1&#125;&#125;;const ll MD=1e9;int n,N,m,id[maxn][maxn];char s[maxn][maxn];matrix kir;inline void A(ll &amp;a,ll b)&#123; (a+=(b%MD+MD)%MD)%=MD; &#125;inline void add(int u,int v)&#123; A(kir[u][v],-1);A(kir[v][v],1);&#125;void mkid()&#123; N=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) if (s[i][j]=='.') id[i][j]=++N;&#125;ll det(matrix a,int n)&#123; ll f=1,res=1; for (int i=1;i&lt;=n;i++)&#123; int where=-1; for (int j=i;j&lt;=n;j++) if (a[j][i]!=0) &#123;where=j;break;&#125; if (where&lt;0) return 0; if (where!=i) swap(a[i],a[where]),f=-f; for (int j=i+1;j&lt;=n;j++) while (a[j][i]!=0)&#123; ll t=a[j][i]/a[i][i]; for (int k=1;k&lt;=n;k++) A(a[j][k],-a[i][k]*t); if (a[j][i]==0) break; swap(a[i],a[j]),f=-f; &#125; &#125; for (int i=1;i&lt;=n;i++) (res*=a[i][i])%=MD; return (res*f%MD+MD)%MD;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%s\",s[i]+1); mkid(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) for (int t=0;t&lt;4;t++) if (id[i][j]&amp;&amp;id[i+p[t][0]][j+p[t][1]]) add(id[i][j],id[i+p[t][0]][j+p[t][1]]); printf(\"%lld\",det(kir,N-1)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"http://oi.linkfqy.top/tags/矩阵树定理/"}]},{"title":"UOJ#186. 【UR#13】Yist","slug":"UOJ186","date":"2018-05-28T22:23:19.000Z","updated":"2018-05-28T22:57:32.000Z","comments":true,"path":"posts/UOJ186/","link":"","permalink":"http://oi.linkfqy.top/posts/UOJ186/","excerpt":"","text":"题面在这里 考虑删除一个点\\(x\\)需要的最短区间长度 找到左边第一个比x小的u，右边第一个比x小的v 则区间\\((u,v)\\)减去其中需要被删除(‘0’)而且比x小的点个数就是最短的区间 把所有需要删除的点对应区间取最小值就是答案了 ​ 其实再思考一下可以发现，只考虑区间\\((u,v)\\)减去其中需要被删除的点个数是不影响答案的 因为如果\\((u,v)\\)内有一需要被删除的点比x大，它对应的区间一定含于\\((u,v)\\) 再无论怎么删除，它的区间都是比\\((u,v)\\)小的，我们要取区间的最小值，所以对答案没有影响 ​ 然后就可以把所有需要删除的点从大到小，依次暴力找\\((u,v)\\) 并且一路标记访问过的点 某次访问到标记点就不要找了，因为得到的答案一定比之前标记的那次大 这样复杂度是\\(O(nq)\\)的 ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;inline char nc()&#123; static char buf[100000],*l=buf,*r=buf; return l==r&amp;&amp;(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;inline void reads(char *s)&#123; char c=nc();while (c&lt;'0'||'9'&lt;c) c=nc(); int n=0; while ('0'&lt;=c&amp;&amp;c&lt;='9') s[++n]=c,c=nc();&#125;const int maxn=1000005,INF=0x3f3f3f3f;int n,q,a[maxn],b[maxn],ans;char s[maxn];bool vis[maxn];void calc(int x)&#123; int l,r,tot=0; //(l,r) vis[x]=1; for (l=x-1;l&gt;=1&amp;&amp;a[l]&gt;=a[x]||s[l]=='0';l--)&#123; if (s[l]=='0') tot++; if (vis[l]) return;else vis[l]=1; &#125; for (r=x+1;r&lt;=n&amp;&amp;a[r]&gt;=a[x]||s[r]=='0';r++)&#123; if (s[r]=='0') tot++; if (vis[r]) return;else vis[r]=1; &#125; ans=min(ans,r-l-1-tot);&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) a[i]=red(),b[a[i]]=i; q=red(); while (q--)&#123; reads(s);ans=INF;cl(vis,0); for (int i=n;i&gt;=1;i--) if (s[b[i]]=='0') calc(b[i]); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"UOJ","slug":"UOJ","permalink":"http://oi.linkfqy.top/tags/UOJ/"}]},{"title":"【Trie+瞎搞】Codeforces 965E Short Code","slug":"CF965E","date":"2018-05-28T11:26:31.000Z","updated":"2018-05-28T11:26:32.000Z","comments":true,"path":"posts/CF965E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF965E/","excerpt":"","text":"题面在这里 先把Trie建出来，有单词节点和空节点 其实就是把单词节点尽量向上移 使得深度和最小 所以用个优先队列启发式合并一下就好了 复杂度\\(O(nlog^2n)\\) ​ 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;const int maxn=100005;int n,dep[maxn];int rot,len,son[maxn][26],fa[maxn];char s[maxn];bool vis[maxn];priority_queue&lt;int&gt; S[maxn];void add_s(char *s)&#123; int x=rot; for (int i=0;s[i];i++)&#123; int c=s[i]-'a'; if (!son[x][c]) son[x][c]=++len,fa[len]=x; x=son[x][c]; &#125; vis[x]=1;&#125;int dfs(int x)&#123; dep[x]=dep[fa[x]]+1; int res=0;if (vis[x]) S[x].push(dep[x]),res+=dep[x]; for (int i=0,s=son[x][i];i&lt;26;i++,s=son[x][i]) if (s)&#123; res+=dfs(s); while (!S[s].empty()) S[x].push(S[s].top()),S[s].pop(); &#125; if (!vis[x]&amp;&amp;x!=rot) res-=S[x].top(),S[x].pop(), res+=dep[x],S[x].push(dep[x]); return res;&#125;int main()&#123; scanf(\"%d\",&amp;n); rot=len=1; for (int i=1;i&lt;=n;i++) scanf(\"%s\",s),add_s(s); dep[0]=-1; printf(\"%d\",dfs(rot)); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"Trie","slug":"Trie","permalink":"http://oi.linkfqy.top/tags/Trie/"}]},{"title":"我的emacs配置+快捷键备忘","slug":"emacs-setting","date":"2018-05-27T22:56:31.000Z","updated":"2018-05-27T23:21:16.000Z","comments":true,"path":"posts/emacs-setting/","link":"","permalink":"http://oi.linkfqy.top/posts/emacs-setting/","excerpt":"最近开始使用emacs编辑器……","text":"最近开始使用emacs编辑器…… 附：emacs快捷键 以下是我的emacs配置： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051(custom-set-variables ;; custom-set-variables was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. '(cua-mode t nil (cua-base)) '(show-paren-mode t) '(tool-bar-mode nil))(custom-set-faces ;; custom-set-faces was added by Custom. ;; If you edit it by hand, you could mess it up, so be careful. ;; Your init file should contain only one such instance. ;; If there is more than one, they won't work right. '(default ((t (:family \"Consolas\" :foundry \"outline\" :slant normal :weight normal :height 130 :width normal)))));;自带;;样式：(setq default-frame-alist '((vertical-scroll-bars) (background-color . \"black\") (foreground-color . \"grey\")))(set-face-foreground 'region \"white\")(set-face-background 'region \"grey15\");;比较有用：(setq make-backup-files nil) ;;退出时删除生成的副本(setq inhibit-splash-screen t) ;;关闭帮助画面(electric-pair-mode t) ;;自动补全括号(electric-indent-mode t) ;;花括号自动换行(show-paren-mode t) ;;显示匹配的括号(global-linum-mode t) ;;显示行号(setq scroll-step 1);;每次一行一行向下翻(setq-default cursor-type 'bar) ;;光标设为竖线(setq default-tab-width 4) ;;默认Tab宽度(setq c-basic-offset 4) ;;缩进宽度;;快捷键：(defun my-compile() (interactive) (save-buffer) (let((file(file-name-nondirectory buffer-file-name))) (compile (format \"g++ -g %s -o %s\" file (file-name-sans-extension file)))) (switch-to-buffer-other-window\"*compilation*\") )(global-set-key (kbd \"&lt;f9&gt;\") 'my-compile)(global-set-key (kbd \"&lt;f5&gt;\") 'gdb)(global-set-key (kbd \"C-s\") 'save-buffer)(global-set-key (kbd \"C-f\") 'isearch-forward)(global-set-key (kbd \"M-&lt;f4&gt;\") 'save-buffers-kill-emacs)(global-set-key (kbd \"C-a\") 'mark-whole-buffer)","categories":[{"name":"实用","slug":"实用","permalink":"http://oi.linkfqy.top/categories/实用/"}],"tags":[]},{"title":"GDB常用命令整理","slug":"GDB-commands","date":"2018-05-27T22:54:33.000Z","updated":"2018-05-27T23:20:54.000Z","comments":true,"path":"posts/GDB-commands/","link":"","permalink":"http://oi.linkfqy.top/posts/GDB-commands/","excerpt":"","text":"附：GDB不完全手册 run 运行（F5） r next 下一步（F7） n step 进入（F8） s break 设置断点 b break if x==1 continue 下一个断点 （Alt+S） c display 显示（Alt+A） disp print 暂时显示 p delete 删除断点、显示 d delete 1 delete display 1 kill 终止程序 （F6） info 详细信息显示 info break info display until 直至退出函数 u quit 推出GDB q","categories":[{"name":"实用","slug":"实用","permalink":"http://oi.linkfqy.top/categories/实用/"}],"tags":[]},{"title":"矩阵树定理","slug":"Matrix-tree","date":"2018-05-27T07:26:21.000Z","updated":"2018-05-27T08:40:14.000Z","comments":true,"path":"posts/Matrix-tree/","link":"","permalink":"http://oi.linkfqy.top/posts/Matrix-tree/","excerpt":"最近学习了矩阵树定理。 矩阵树定理可以求生成树个数","text":"最近学习了矩阵树定理。 矩阵树定理可以求生成树个数 前置知识 行列式 定义 对于一个\\(N\\times N\\)矩阵\\(A\\)，它的行列式\\(det(A)\\)： \\[ det(A)=\\sum\\limits_{(i_1i_2...i_n)}(-1)^ka_{1,i_1}a_{2,i_2}...a_{n,i_n}= \\left|\\begin{array}{cccc} a_{1,1} &amp; a_{1,2} &amp; \\dots &amp; a_{1,n} \\\\ a_{2,1} &amp; \\dots \\\\ \\dots \\\\ a_{n,1} &amp; a_{n,2} &amp; \\dots &amp; a_{n,n} \\end{array}\\right| \\] 其中\\(i\\)是\\(n\\)的一个排列，\\(k\\)是这个排列的逆序对数 这个定义可以理解为每行每列仅取一个，求所有方案的乘积和 几何意义：线性变换的（体积）放大率 性质 行列式具有以下性质： \\(det(A)=det(A^T)\\)（行列等价） 交换两行，行列式变号（从奇偶排列的角度看） 某一行乘K，行列式变为K倍（从几何意义理解） 某一行加上另一行的K倍，行列式不变（这意味着行列式可以高斯消元） 把\\(\\forall i&gt;j,a_{i,j}=0\\)的矩阵称为上三角矩阵，左上到右下称为主对角线 上三角矩阵的行列式为主对角线乘积（由定义得） 求解 行列式的求解可以用高斯消元\\(O(n^3)\\)实现： 先高斯消元把矩阵等价变形为上三角矩阵，然后求主对角线乘积就好了 如果答案要膜一个质数，就用逆元 如果丧心病狂不是质数，就只能辗转相除法了 注意记录交换行的次数，并取负 12345678910111213141516171819ll det(matrix a,int n)&#123; int tot=0; for (int i=1;i&lt;=n;i++)&#123; int where=-1; for (int j=i;j&lt;=n;j++) if (a[j][i]!=0) &#123;where=j;break;&#125; if (where&lt;0) return 0; if (where&gt;i)&#123; tot++; for (int j=1;j&lt;=n;j++) swap(a[i][j],a[where][j]); &#125; for (int j=i+1;j&lt;=n;j++)&#123; ll t=a[j][i]*inv(a[i][i])%MD; for (int k=i;k&lt;=n;k++) A(a[j][k],-a[i][k]*t); &#125; &#125; ll res=1; for (int i=1;i&lt;=n;i++) (res*=a[i][i])%=MD; return (tot&amp;1)?MD-res:res;&#125; 基尔霍夫矩阵 对于一个无向图，定义邻接矩阵和度数矩阵： 邻接矩阵：\\(a_{u,v}=a_{v,u}=1 当且仅当存在u\\leftrightarrow v\\) 度数矩阵：\\(a_{v,v}\\)表示v的度数 类似地，有向图也有以下定义： 邻接矩阵：\\(a_{u,v}=1 当且仅当存在u\\rightarrow v\\) 度数矩阵：\\(a_{v,v}\\)表示v的入度 基尔霍夫矩阵就是邻接矩阵减去度数矩阵 矩阵树定理 Matrix-tree定理： 一个图的生成树个数为 基尔霍夫矩阵的余子式\\(M_{i,i}\\)的行列式\\(det(M_{i,i})\\) 对应有向图就是以i为根的外向树个数 模板 bzoj4596 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=25;typedef ll matrix[maxn][maxn];const ll MD=1e9+7;int n,m[maxn];ll ans;matrix kir;struct data&#123; int x,y; inline void read() &#123;scanf(\"%d%d\",&amp;x,&amp;y);&#125;&#125;a[maxn][105];inline void A(ll &amp;a,ll b)&#123; (a+=(b%MD+MD)%MD)%=MD; &#125;inline ll inv(ll a)&#123; ll res=1,w=a%MD,b=MD-2; while (b)&#123; if (b&amp;1) res=res*w%MD; w=w*w%MD; b&gt;&gt;=1; &#125; return res;&#125;ll det(matrix a,int n)&#123; int tot=0; for (int i=1;i&lt;=n;i++)&#123; int where=-1; for (int j=i;j&lt;=n;j++) if (a[j][i]!=0) &#123;where=j;break;&#125; if (where&lt;0) return 0; if (where&gt;i)&#123; tot++; for (int j=1;j&lt;=n;j++) swap(a[i][j],a[where][j]); &#125; for (int j=i+1;j&lt;=n;j++)&#123; ll t=a[j][i]*inv(a[i][i])%MD; for (int k=i;k&lt;=n;k++) A(a[j][k],-a[i][k]*t); &#125; &#125; ll res=1; for (int i=1;i&lt;=n;i++) (res*=a[i][i])%=MD; return (tot&amp;1)?MD-res:res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;n;i++)&#123; scanf(\"%d\",&amp;m[i]); for (int j=1;j&lt;=m[i];j++) a[i][j].read(); &#125; for (int s=0;s&lt;(1&lt;&lt;n-1);s++)&#123; cl(kir,0);int tot=0; for (int i=1;i&lt;=n;i++) if (s&amp;(1&lt;&lt;i-1))&#123;tot++; for (int j=1;j&lt;=m[i];j++)&#123; int x=a[i][j].x,y=a[i][j].y; A(kir[x][y],-1);A(kir[y][x],-1);A(kir[x][x],1);A(kir[y][y],1); &#125;&#125; A(ans,((n-1-tot&amp;1)?-1:1)*det(kir,n-1)); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"http://oi.linkfqy.top/tags/矩阵树定理/"}]},{"title":"【矩阵树定理】BZOJ4596 [Shoi2016]黑暗前的幻想乡","slug":"BZOJ4596","date":"2018-05-27T07:13:52.000Z","updated":"2018-05-27T08:17:04.000Z","comments":true,"path":"posts/BZOJ4596/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4596/","excerpt":"","text":"题面在这里 ​ 首先要容斥，答案就是： \\[ \\sum_{i=0}^n (-1)^i\\cdot count_i \\] 其中\\(count_i\\)表示i个公司不修路的方案数 这个可以用矩阵树定理求得，只要枚举那些公司不修路就好了 时间复杂度\\(O(2^n\\cdot n^3)\\) ​ 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=25;typedef ll matrix[maxn][maxn];const ll MD=1e9+7;int n,m[maxn];ll ans;matrix kir;struct data&#123; int x,y; inline void read() &#123;scanf(\"%d%d\",&amp;x,&amp;y);&#125;&#125;a[maxn][105];inline void A(ll &amp;a,ll b)&#123; (a+=(b%MD+MD)%MD)%=MD; &#125;inline ll inv(ll a)&#123; ll res=1,w=a%MD,b=MD-2; while (b)&#123; if (b&amp;1) res=res*w%MD; w=w*w%MD; b&gt;&gt;=1; &#125; return res;&#125;ll det(matrix a,int n)&#123; int tot=0; for (int i=1;i&lt;=n;i++)&#123; int where=-1; for (int j=i;j&lt;=n;j++) if (a[j][i]!=0) &#123;where=j;break;&#125; if (where&lt;0) return 0; if (where&gt;i)&#123; tot++; for (int j=1;j&lt;=n;j++) swap(a[i][j],a[where][j]); &#125; for (int j=i+1;j&lt;=n;j++)&#123; ll t=a[j][i]*inv(a[i][i])%MD; for (int k=i;k&lt;=n;k++) A(a[j][k],-a[i][k]*t); &#125; &#125; ll res=1; for (int i=1;i&lt;=n;i++) (res*=a[i][i])%=MD; return (tot&amp;1)?MD-res:res;&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;n;i++)&#123; scanf(\"%d\",&amp;m[i]); for (int j=1;j&lt;=m[i];j++) a[i][j].read(); &#125; for (int s=0;s&lt;(1&lt;&lt;n-1);s++)&#123; cl(kir,0);int tot=0; for (int i=1;i&lt;=n;i++) if (s&amp;(1&lt;&lt;i-1))&#123;tot++; for (int j=1;j&lt;=m[i];j++)&#123; int x=a[i][j].x,y=a[i][j].y; A(kir[x][y],-1);A(kir[y][x],-1);A(kir[x][x],1);A(kir[y][y],1); &#125;&#125; A(ans,((n-1-tot&amp;1)?-1:1)*det(kir,n-1)); &#125; printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"矩阵树定理","slug":"矩阵树定理","permalink":"http://oi.linkfqy.top/tags/矩阵树定理/"}]},{"title":"【矩阵乘法】51Nod 1668 非010串","slug":"51Nod1668","date":"2018-05-24T13:25:55.000Z","updated":"2018-05-24T13:30:56.000Z","comments":true,"path":"posts/51Nod1668/","link":"","permalink":"http://oi.linkfqy.top/posts/51Nod1668/","excerpt":"","text":"题面在这里 ​ 矩乘裸题，不解释 ​ 示例程序： 123456789101112131415161718192021222324252627282930313233343536#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))typedef long long ll;const ll tt=1e9+7;ll n;struct matrix&#123; ll s[9][9]; void E() &#123;cl(s,0);for (int i=1;i&lt;=4;i++) s[i][i]=1;&#125;&#125;A,ans;matrix operator*(const matrix&amp;a,const matrix&amp;b)&#123; matrix c;cl(c.s,0); for (int i=1;i&lt;=4;i++) for (int j=1;j&lt;=4;j++) for (int k=1;k&lt;=4;k++) (c.s[i][j]+=a.s[i][k]*b.s[k][j]%tt)%=tt; return c;&#125;matrix power(matrix a,ll b)&#123; matrix w,res;res.E();w=a; while (b)&#123; if (b&amp;1) res=res*w; w=w*w; b&gt;&gt;=1; &#125; return res;&#125;int main()&#123; scanf(\"%lld\",&amp;n); if (n==1) return printf(\"2\"),0; A.s[1][1]=A.s[2][1]=A.s[4][2]=A.s[1][3]=A.s[2][3]=A.s[3][4]=A.s[4][4]=1; ans.s[1][1]=ans.s[1][2]=ans.s[1][3]=ans.s[1][4]=1; ans=ans*power(A,n-2); printf(\"%lld\",(ans.s[1][1]+ans.s[1][2]+ans.s[1][3]+ans.s[1][4])%tt); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"51Nod","slug":"51Nod","permalink":"http://oi.linkfqy.top/tags/51Nod/"},{"name":"矩阵","slug":"矩阵","permalink":"http://oi.linkfqy.top/tags/矩阵/"}]},{"title":"Codeforces 983A Finite or not?","slug":"CF983A","date":"2018-05-20T13:47:02.000Z","updated":"2018-05-20T13:52:26.000Z","comments":true,"path":"posts/CF983A/","link":"","permalink":"http://oi.linkfqy.top/posts/CF983A/","excerpt":"","text":"题面在这里 如果是十进制的话，只要q不含除2和5之外的质因子就Finite了 那么大胆猜想，只有q只含有b所含的质因子才能Finite，否则就是Infinite 示例程序： 1234567891011121314151617181920212223#include&lt;cstdio&gt;typedef long long ll;ll p,q,b;int tst;ll gcd(ll x,ll y)&#123; if (y==0) return x; return gcd(y,x%y);&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%lld%lld%lld\",&amp;p,&amp;q,&amp;b); if (p==0) &#123;printf(\"Finite\\n\");continue;&#125; ll t=gcd(p,q);p/=t;q/=t; while (q&gt;1)&#123; t=gcd(q,b); if (t==1) break; while (q%t==0) q/=t; &#125; if (q==1) printf(\"Finite\\n\");else printf(\"Infinite\\n\"); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 958E3 Guard Duty (hard)","slug":"CF958E3","date":"2018-05-19T05:27:19.000Z","updated":"2018-05-19T05:35:32.000Z","comments":true,"path":"posts/CF958E3/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958E3/","excerpt":"","text":"题面在这里 考虑到黑点与白点个数相同就一定有解 那么可以分治做：找到一条连线把所有点分为两部分，使其黑白点个数相同 具体的做法就是，以最左下的点为原点极角排序，然后大力枚举分割点集的连线 如何证明一定能找到？ 考虑遇到黑点+1，白点-1，那么初始是0，最终也是0，而且中间经过了\\(2N-1\\)个点 那么其中必定有零点，这就意味着找到了解 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=20005;int n,ans[maxn];bool vis[maxn];struct point&#123; int x,y,id; bool f; point() &#123;&#125; point(int _x,int _y):x(_x),y(_y) &#123;&#125; bool operator&lt;(const point&amp;b)const&#123; return x&lt;b.x||x==b.x&amp;&amp;y&lt;b.y; &#125;&#125;a[maxn],b[maxn],p;typedef point vec;inline vec operator-(const vec&amp;a,const vec&amp;b)&#123; return vec(a.x-b.x,a.y-b.y);&#125;inline int cross(const vec&amp;a,const vec&amp;b)&#123; return a.x*b.y-a.y*b.x;&#125;bool cmp(const point&amp;a,const point&amp;b)&#123; return cross(a-p,b-p)&gt;0;&#125;void divide(int l,int r)&#123; if (l&gt;=r) return; for (int i=l;i&lt;=r;i++) b[i]=a[i]; swap(*min_element(a+l,a+r+1),a[r]); p=a[r]; sort(a+l,a+r,cmp); cl(vis,0); int i,j,t,mid; for (i=l,t=0;i&lt;r;vis[i]=1,t+=a[i].f?1:-1,i++) if ((p.f^a[i].f)&amp;&amp;t==0) break; mid=i; if (!p.f) ans[p.id]=a[i].id;else ans[a[i].id]=p.id; divide(l,mid-1);divide(mid+1,r-1); for (int i=l;i&lt;=r;i++) a[i]=b[i];&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y),a[i].id=i,a[i].f=0; for (int i=n+1;i&lt;=n+n;i++) scanf(\"%d%d\",&amp;a[i].x,&amp;a[i].y),a[i].id=i,a[i].f=1; divide(1,2*n); for (int i=1;i&lt;=n;i++) printf(\"%d\\n\",ans[i]-n); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"分治","slug":"分治","permalink":"http://oi.linkfqy.top/tags/分治/"}]},{"title":"讲课备忘录","slug":"jiangke","date":"2018-05-17T09:00:00.000Z","updated":"2018-05-17T09:10:24.000Z","comments":true,"path":"posts/jiangke/","link":"","permalink":"http://oi.linkfqy.top/posts/jiangke/","excerpt":"这是为水题选讲准备的备忘录","text":"这是为水题选讲准备的备忘录 A2 找相同\\(M\\times M\\)子矩阵 B2 树上放\\(K=1,2\\dots n\\)个端点求最多控制个数 C2 \\(N\\)个元素，分成\\(K\\)段，求每段分别\\(mod\\space p\\)的最大加和 E1 判断是否存在不相交航线 E2 N个元素中取K个不相邻的，求最小代价 E3 求任意不相交航线","categories":[{"name":"杂","slug":"杂","permalink":"http://oi.linkfqy.top/categories/杂/"}],"tags":[]},{"title":"【DP/WQS二分】Codeforces 958E2 Guard Duty (medium)","slug":"CF958E2","date":"2018-05-16T03:36:22.000Z","updated":"2018-05-16T04:05:50.000Z","comments":true,"path":"posts/CF958E2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958E2/","excerpt":"","text":"题面在这里 把时间间隔看作元素，间隔长度看作代价 问题就转化为：N个元素取K个不相邻元素，使代价最小 两种解法： 一、WQS二分 可以先WQS二分去掉一维K 即每个元素的代价加上\\(mid\\)，不限制取的个数 用DP验证最优决策下取的个数是否超过K即可 时间复杂度\\(O(NlogN)\\) 二、直接DP \\(f_{i,j,0/1}\\)表示前i个取了j个，第i个是否取 的最小代价 这样复杂度是\\(O(NK)\\)的 但是可以发现最优解一定只需要前\\(3K\\)小的元素 这样把前\\(3K\\)个元素拿来DP，复杂度就是\\(O(N^2)\\) 示例程序1： 12345678910111213141516171819202122232425262728293031#include&lt;cstdio&gt;#include&lt;cstring&gt; #include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=500005;const double eps=1e-3; int n,K,a[maxn],g[maxn];double f[maxn];void check(double w)&#123; f[0]=0;f[1]=min(a[1]+w,0.0); for (int i=2;i&lt;=n;i++) if (f[i-1]&gt;f[i-2]+a[i]+w) f[i]=f[i-2]+a[i]+w,g[i]=g[i-2]+1;else f[i]=f[i-1],g[i]=g[i-1];&#125;int main()&#123; scanf(\"%d%d\",&amp;K,&amp;n); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]); sort(a+1,a+1+n); for (int i=1;i&lt;n;i++) a[i]=a[i+1]-a[i];n--; double l=-1e9,r=1e9,mid; while (r-l&gt;eps)&#123; mid=(l+r)/2; if (check(mid),g[n]&lt;K) r=mid;else l=mid; &#125; check(mid=(l+r)/2); printf(\"%.0lf\",f[n]-K*mid); return 0;&#125; 示例程序2： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;cstdio&gt;#include &lt;cctype&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;using namespace std;const int N=500005;struct note&#123; int w,wz; bool operator &lt; (const note lyf) const &#123;return w&lt;lyf.w;&#125;&#125;q[N];int k,n,a[N],d[N],b[N],f[4][N],p;inline char nc(void)&#123; static char ch[100010],*p1=ch,*p2=ch; return p1==p2&amp;&amp;(p2=(p1=ch)+fread(ch,1,100010,stdin),p1==p2)?EOF:*p1++;&#125;inline void read(int &amp;a)&#123; static char c=nc();int f=1; for (;!isdigit(c);c=nc()) if (c=='-') f=-1; for (a=0;isdigit(c);a=(a&lt;&lt;3)+(a&lt;&lt;1)+c-'0',c=nc()); return (void)(a*=f);&#125;int main()&#123; read(k),read(n); for (int i=1; i&lt;=n; ++i) read(a[i]); sort(a+1,a+1+n); for (int i=1; i&lt;n; ++i) d[i]=q[i].w=a[i+1]-a[i],q[i].wz=i; sort(q+1,q+n); for (int i=1; i&lt;=min(n,3*k); ++i) b[q[i].wz]=1; memset(f,0x3f,sizeof f); for (int i=0; i&lt;=3; ++i) f[i][0]=0; for (int i=1; i&lt;=n; ++i) if (b[i])&#123; ++p; for (int j=1; j&lt;=min(p,k); ++j) f[p&amp;3][j]=min(f[(p-1)&amp;3][j],f[(p-1-b[i-1])&amp;3][j-1]+d[i]); &#125; return printf(\"%d\\n\",f[p&amp;3][k]),0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"WQS二分","slug":"WQS二分","permalink":"http://oi.linkfqy.top/tags/WQS二分/"}]},{"title":"【DP】Codeforces 958C2 Encryption (medium)","slug":"CF958C2","date":"2018-05-13T03:30:43.000Z","updated":"2018-05-13T03:48:48.000Z","comments":true,"path":"posts/CF958C2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958C2/","excerpt":"一道简单的DP题……","text":"一道简单的DP题…… 题面在这里 \\(f_{i,j,k}\\)表示前i个元素分为j部分，最后一块值为k 对于第i个元素，讨论它在前一块还是后一块就好了 示例程序： 123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;const int maxn=20005;int n,K,p,a[maxn];int f[maxn][55][105],dp[maxn][55];int main()&#123; scanf(\"%d%d%d\",&amp;n,&amp;K,&amp;p); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;a[i]),a[i]%=p; memset(f,0xc0,sizeof(f)); memset(dp,0xc0,sizeof(dp)); f[0][0][0]=0;dp[0][0]=0; for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=K&amp;&amp;j&lt;=i;j++)&#123; f[i][j][a[i]]=max(f[i-1][j][0]+a[i],dp[i-1][j-1]+a[i]); for (int m=1;m&lt;p;m++) f[i][j][(a[i]+m)%p]=max(f[i][j][(a[i]+m)%p],f[i-1][j][m]-m+(a[i]+m)%p); for (int k=0;k&lt;p;k++) dp[i][j]=max(dp[i][j],f[i][j][k]); &#125; printf(\"%d\",dp[n][K]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"Codeforces 958E1 Guard Duty (easy)","slug":"CF958E1","date":"2018-05-13T03:30:43.000Z","updated":"2018-05-13T13:33:42.000Z","comments":true,"path":"posts/CF958E1/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958E1/","excerpt":"很妙的一道思考题……","text":"很妙的一道思考题…… 题面在这里 考虑两条航线\\(\\overline{AB}\\)与\\(\\overline{CD}\\)交叉 根据三角不等式，其长度和一定大于\\(\\overline{AC}\\)与\\(\\overline{BD}\\) 得出结论：所有航线长度和最短的方案一定不含交叉 由于长度最短的方案是一定存在的，所以只要\\(n=m\\)就存在不交叉的方案了 示例程序： 1234567#include&lt;cstdio&gt;int n,m;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); printf(n==m?\"Yes\":\"No\"); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"妙题","slug":"妙题","permalink":"http://oi.linkfqy.top/tags/妙题/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【贪心】Codeforces 958B2 Maximum Control (medium)","slug":"CF958B2","date":"2018-05-12T14:03:59.000Z","updated":"2018-05-12T15:05:50.000Z","comments":true,"path":"posts/CF958B2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958B2/","excerpt":"","text":"题面在这里 很容易想到\\(K=2\\)时就是求树的直径 其实就是两次DFS，得到的两个最远点的距离就是直径了 其实\\(K\\gt 2\\)也差不多： 每次从未标记的点中找出深度最大的，用于放新的飞船 然后一路向上，标记路径上所有点并更新答案就好了 挺好想的一个贪心…… 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn=100005,maxe=200005;int n,v,ans,num,fa[maxn],dep[maxn],id[maxn],farson[maxn];int lnk[maxn],son[maxe],nxt[maxe],tot;bool vis[maxn];void add(int x,int y)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;&#125;void dfs(int x)&#123; dep[x]=0;farson[x]=0; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa[x])&#123; fa[son[j]]=x,dfs(son[j]); if (dep[son[j]]+1&gt;dep[x]) dep[x]=dep[son[j]]+1,farson[x]=farson[son[j]]; &#125; if (dep[x]==0) farson[x]=x;&#125;bool cmp(const int &amp;i,const int &amp;j)&#123; return dep[i]&gt;dep[j];&#125;int main()&#123; scanf(\"%d\",&amp;n); for (int i=1,x,y;i&lt;=n;i++) scanf(\"%d%d\",&amp;x,&amp;y),add(x,y),add(y,x); dfs(1); v=farson[1];fa[v]=0;dfs(v); for (int i=1;i&lt;=n;i++) id[i]=i;sort(id+1,id+1+n,cmp); vis[v]=1;printf(\"%d\",ans=1),num=1; for (int t=1,i=id[t];t&lt;=n;t++,i=id[t]) if (!vis[i])&#123; for (int j=farson[i];j!=fa[i];j=fa[j]) vis[j]=1,ans++; printf(\" %d\",ans);num++; &#125; for (int i=num+1;i&lt;=n;i++) printf(\" %d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"贪心","slug":"贪心","permalink":"http://oi.linkfqy.top/tags/贪心/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"【hash】Codeforces 958A2 Death Stars (medium)","slug":"CF958A2","date":"2018-04-19T12:23:59.000Z","updated":"2018-04-19T12:27:12.000Z","comments":true,"path":"posts/CF958A2/","link":"","permalink":"http://oi.linkfqy.top/posts/CF958A2/","excerpt":"","text":"题面在这里 暴力枚举位置，用hash\\(O(m)\\)判断两个矩阵是否相等即可 时间复杂度\\(O(n^2m)\\) 示例程序： 12345678910111213141516171819202122232425262728#include&lt;cstdio&gt;const int maxn=2005;typedef unsigned long long ull;int n,m;char a[maxn][maxn],b[maxn][maxn];ull hsha[maxn],hshb[maxn][maxn];ull hash(char *s)&#123; ull res=0; for (int i=0;i&lt;m;i++) res=res*29+s[i]-'a'+1; return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;m); for (int i=1;i&lt;=n;i++) scanf(\"%s\",a[i]+1); for (int i=1;i&lt;=m;i++) scanf(\"%s\",b[i]+1); for (int i=1;i&lt;=n;i++) hsha[i]=hash(a[i]+1); for (int i=1;i&lt;=m;i++) for (int j=1;j&lt;=n-m+1;j++) hshb[i][j]=hash(b[i]+j); for (int i=1;i&lt;=n-m+1;i++) for (int j=1;j&lt;=n-m+1;j++)&#123; bool suc=1; for (int k=0;k&lt;m;k++) if (hsha[i+k]!=hshb[1+k][j]) &#123;suc=0;break;&#125; if (suc) return printf(\"%d %d\",i,j),0; &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"hash","slug":"hash","permalink":"http://oi.linkfqy.top/tags/hash/"},{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"}]},{"title":"《最小割模型在信息学竞赛中的应用》学习笔记","slug":"MaxFlow_Amber","date":"2018-04-17T12:10:55.000Z","updated":"2018-04-17T12:39:08.000Z","comments":true,"path":"posts/MaxFlow_Amber/","link":"","permalink":"http://oi.linkfqy.top/posts/MaxFlow_Amber/","excerpt":"最近学习了Amber的这篇论文，感觉很强大","text":"最近学习了Amber的这篇论文，感觉很强大 原文：算法合集之《最小割模型在信息学竞赛中的应用》 先挖个坑……","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"网络流","slug":"网络流","permalink":"http://oi.linkfqy.top/tags/网络流/"}]},{"title":"【后缀数组+二分+贪心】BZOJ4310 跳蚤","slug":"BZOJ4310","date":"2018-04-09T12:28:25.000Z","updated":"2018-04-09T12:51:14.000Z","comments":true,"path":"posts/BZOJ4310/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ4310/","excerpt":"后缀数组综合应用……","text":"后缀数组综合应用…… 题面在这里 看到最大值最小就很明显是二分了 关键在于如何获得第mid小的子串 考虑第i小的后缀能够贡献多少个不同的子串，其实是\\(n-sa[i]+1-height[i]\\) 由于已知后缀的排序，扫一趟看第mid个贡献属于哪个后缀，就可以得到第mid小的子串了 然后就是一个非常好想的贪心：从后往前，如果当前段即将比二分出的子串大，就分另一段 看看段数是否不大于k就验证好了 比较两个子串的大小可以用LCP实现。 时间复杂度\\(O(nlogn)\\) 其实还有解法二…… 注意到k非常的小，可以先二分子串属于哪个后缀，然后大力二分右端点的位置 往右枚举一个段的左端点，右端点为了不大于子串往左缩，到\\(l\\gt r\\)就可分一段了 由于最多分K段，所以做的次数并不多 炒鸡好写而且常数巨小！\\(O(knlog^2n)\\)跑得飞快 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;cmath&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;typedef long long ll;const int maxn=100005;int n,m,K,sa[maxn],rk[maxn],ht[maxn],ansl,ansr;char s[maxn];int t[maxn],buc[maxn],f[maxn][20],w[maxn];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i&gt;=1;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1,p=0;k&lt;n&amp;&amp;p&lt;n;k&lt;&lt;=1,m=p)&#123; p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(rk)); if (p==n) break; m=p; &#125; for (int i=1,h=0;i&lt;=n;i++)&#123; if (h) h--; int j=sa[rk[i]-1]; while (s[i+h]==s[j+h]) h++; ht[rk[i]]=h; &#125; ht[1]=0; for (int i=1;i&lt;=n;i++) f[i][0]=ht[i]; for (int j=1;j&lt;=log2(n);j++) for (int i=1;i+(1&lt;&lt;j)-1&lt;=n;i++) f[i][j]=min(f[i][j-1],f[i+(1&lt;&lt;j-1)][j-1]);&#125;inline int LCP(int l,int r)&#123; if (l==r) return n-l+1; l=rk[l];r=rk[r]; if (l&gt;r) swap(l,r); l++; int j=log2(r-l+1); return min(f[l][j],f[r-(1&lt;&lt;j)+1][j]);&#125;inline bool cmp(int l,int r,int ll,int rr)&#123; int n1=r-l+1,n2=rr-ll+1,k=LCP(l,ll); if (n1&lt;=n2&amp;&amp;k&gt;=n1) return 1; if (n1&gt;n2&amp;&amp;k&gt;=n2) return 0; return s[l+k]&lt;=s[ll+k];&#125;bool check(ll mid)&#123; int l,r,num=1,lst=n; for (int i=1;i&lt;=n;i++) if (w[i]&lt;mid) mid-=w[i];else &#123;l=sa[i];r=n-w[i]+mid;;break;&#125; for (int i=n;i&gt;=1;i--)&#123; if (s[i]&gt;s[l]) return 0; if (!cmp(i,lst,l,r)) lst=i,num++; if (num&gt;K) return 0; &#125; ansl=l;ansr=r;return 1;&#125;int main()&#123; scanf(\"%d%s\",&amp;K,s+1);n=strlen(s+1); make_sa(); ll l=1,r=0; for (int i=1;i&lt;=n;i++) w[i]=n-sa[i]+1-ht[i],r+=w[i]; while (l&lt;=r)&#123; ll mid=l+r&gt;&gt;1; if (check(mid)) r=mid-1;else l=mid+1; &#125; for (int i=ansl;i&lt;=ansr;i++) putchar(s[i]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://oi.linkfqy.top/tags/后缀数组/"}]},{"title":"后缀数组之倍增算法","slug":"suffix_array","date":"2018-04-07T13:36:39.000Z","updated":"2018-04-07T15:01:46.000Z","comments":true,"path":"posts/suffix_array/","link":"","permalink":"http://oi.linkfqy.top/posts/suffix_array/","excerpt":"后缀数组（Suffix Array,SA）可以通过预处理文本串，解决多模板匹配问题。 而AC自动机正好相反，需要事先知道所有的模板。 这是需要首先注意的。","text":"后缀数组（Suffix Array,SA）可以通过预处理文本串，解决多模板匹配问题。 而AC自动机正好相反，需要事先知道所有的模板。 这是需要首先注意的。 后缀数组 定义字符串的后缀的编号为首字母在原串中的位置。 后缀数组的定义：将字符串的所有后缀排序，其编号构成的数组称为后缀数组 相比后缀自动机和后缀树，后缀数组更为简单，所以更为常用 后缀数组的构造 常使用倍增算法构造后缀数组 其思想是名次的大小体现了子串的大小，将两个名次当作二元组排序。 参与排序的子串长度倍增，最终变成全串的后缀 ​ 首先对所有后缀的第一个字符排序：（图片来自网络） 将得到的名次两两绑定再排序： 得到的名次再排序: 此时每个元素已经代表4个后缀了，依次类推便可将所有后缀排序，排名不变动表示排序已完成 这样倍增的次数是\\(O(logn)\\)的，如果每次使用基数排序，复杂度为\\(O(nlogn)\\) 还是比较强大的。 这里提供两个模板： 1.用vector模拟基数排序，便于理解但常数大 12345678910111213141516171819202122232425262728vector&lt;int&gt; buc[maxn];int rk[maxn*2],res[maxn],id[maxn];void csort(int k)&#123; for (int i=0;i&lt;=m;i++) buc[i].clear(); for (int i=1;i&lt;=n;i++) buc[rk[id[i]+k]].push_back(id[i]); id[0]=0; for (int i=0;i&lt;=m;i++)&#123; int len=buc[i].size(); for (int j=0;j&lt;len;j++) id[++id[0]]=buc[i][j]; &#125;&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i]; for (int k=1;k&lt;n;k&lt;&lt;=1)&#123; for (int i=1;i&lt;=n;i++) id[i]=i; csort(k); csort(0); id[0]=0; int t=0; for (int i=1;i&lt;=n;i++)&#123; if (!(rk[id[i]]==rk[id[i-1]]&amp;&amp;rk[id[i]+k]==rk[id[i-1]+k])) t++; res[id[i]]=t; &#125; for (int i=1;i&lt;=n;i++) rk[i]=res[i]; if (t&gt;=n) break; m=t; &#125; for (int i=1;i&lt;=n;i++) sa[rk[i]]=i;&#125; 2.每次倍增都更新SA，通过叠加得到名次 1234567891011121314151617181920212223int rk[maxn],t[maxn],buc[maxn];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i&gt;=1;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1;k&lt;n;k&lt;&lt;=1)&#123; int p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(t)); if (p==n) break; m=p; &#125;&#125; 后缀数组的应用 多模板匹配 由于已经得到了所有后缀的排序，可以直接二分，验证这个后缀是否比模板串大 如果模板串是一个后缀的前缀，就说明模板串是文本串的子串，二分得到的上下界一减就知道匹配了几次 时间复杂度\\(O(mlogn)\\)，m是模板串长度 求LCP 设\\(height[i]\\)表示串\\(sa[i]\\)与串\\(sa[i-1]\\)的LCP 那么\\(sa[i]\\)与\\(sa[j]\\)两个后缀的LCP就等于\\(\\mathop{Max} \\limits^j_{k=i+1}\\{ height[sa[k]] \\}\\) 其实求LCP就转化为RMQ问题了 如何求\\(height\\)呢？ 令\\(h[i]=height[rank[i]]\\) 那么就有这样一个性质： \\[ h[i]\\ge h[i-1]-1 \\] 证明如下： 设\\(rank[k]=rank[i-1]-1\\)，则\\(h[i-1]=LCP\\{i-1,k\\}\\) 那么将这两个后缀去掉第一个字符，得到后缀\\(k+1\\)和\\(i\\) 其实\\(h[i-1]-1=LCP\\{k+1,i\\}\\)，而此时\\(rank[k+1]\\le rank[i]-1\\) 所以\\(h[i]\\ge h[i-1]-1\\) 利用这个性质，每次用\\(h[i-1]\\)就可以推出\\(h[i]\\)，再得到\\(height[i]\\)，复杂度\\(O(n)\\) 代码如下，很简单： 123456for (int i=1,h=0;i&lt;=n;i++)&#123; if (h) h--; int j=sa[rk[i]-1]; while (s[i+h]==s[j+h]) h++; ht[rk[i]]=h;&#125; 求第K大子串 考虑后缀\\(sa[i]\\)能够提供\\(n-sa[i]+1-height[i]\\)个本质不同的子串 用二分看第K个子串落在哪个后缀中就好了 ​ 相同子串算多个： 这个只能\\(O(nlogn)\\)回答了，BZOJ3998 二分这个子串是哪个后缀的前缀 只要知道有多少子串比当前后缀小即可 排名更前的任意子串都比它小，贡献\\(\\sum n-sa[i]+1\\) 排名更后的其实就是LCP会比它小，贡献\\(\\sum_i LCP(sa[i],sa[mid])\\) 求子串Rank 直接二分找到第一个含该子串的后缀，然后 求\\(n-sa[i]+1-height[i]\\)的前缀和，就能得到比该子串小的个数了 子串是哪些后缀的前缀 显然答案是一个连续的区间（rank连续） 假设求子串\\(S_{a,b}\\)，首先得到\\(rank[a]\\)，答案就是向两边扩展一下 可以发现答案区间内所有后缀与后缀a的LCP一定大于等于\\(b-a+1\\) 预处理关于\\(height\\)的ST表，直接倍增一下得到这个区间 子串是否包含另一个子串 假设询问子串\\(S_{a,b}\\)是否包含子串\\(S_{c,d}\\) 可以知道子串\\(S_{c,d}\\)是哪些后缀的前缀，这些后缀的排名是连续的 只要出现某个后缀的开头属于\\([a,b-(d-c+1)+1]\\)就有了 相当于在区间内询问是否有值属于某区间，主席树维护就好了 ​ 暂时先写这么多，想到再补……","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"后缀数组","slug":"后缀数组","permalink":"http://oi.linkfqy.top/tags/后缀数组/"}]},{"title":"【后缀数组】BZOJ1717 [Usaco2006 Dec]Milk Patterns 产奶的模式","slug":"BZOJ1717","date":"2018-04-07T13:29:46.000Z","updated":"2018-04-07T13:33:56.000Z","comments":true,"path":"posts/BZOJ1717/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1717/","excerpt":"","text":"题面在这里 直接二分答案，其实就是验证是否存在连续的\\(K\\)个后缀，其LCP大于\\(mid\\) 时间复杂度\\(O(nlogn)\\) 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=20005,maxm=1000005;int n,m,K,sa[maxn],rk[maxn],ht[maxn],s[maxn];int buc[maxm],t[maxn];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i&gt;=1;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=1e6; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1;k&lt;n;k&lt;&lt;=1)&#123; int p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(t)); if (p==n) break; m=p; &#125; for (int i=1,h=0;i&lt;=n;i++)&#123; if (h) h--; int j=sa[rk[i]-1]; while (s[i+h]==s[j+h]) h++; ht[rk[i]]=h; &#125;&#125;bool check(int mid)&#123; for (int i=2,tot=1;i&lt;=n;i++)&#123; if (ht[i]&lt;mid) tot=0; tot++; if (tot&gt;=K) return 1; &#125; return 0;&#125;int main()&#123; scanf(\"%d%d\",&amp;n,&amp;K); for (int i=1;i&lt;=n;i++) scanf(\"%d\",&amp;s[i]); make_sa(); int l=0,r=n,ans=0; while (l&lt;=r)&#123; int mid=l+r&gt;&gt;1; if (check(mid)) l=mid+1,ans=mid;else r=mid-1; &#125; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://oi.linkfqy.top/tags/后缀数组/"}]},{"title":"【后缀数组】BZOJ1031 [JSOI2007]字符加密Cipher","slug":"BZOJ1031","date":"2018-04-06T12:51:45.000Z","updated":"2018-04-06T12:57:10.000Z","comments":true,"path":"posts/BZOJ1031/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1031/","excerpt":"后缀数组模板题。","text":"后缀数组模板题。 题面在这里 显然把字符串接两倍直接搞就好了 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))const int maxn=400005;int n,m,sa[maxn];char s[maxn];int rk[maxn],t[maxn],buc[maxn];void get_sa()&#123; cl(buc,0); for (int i=1;i&lt;=n;i++) buc[rk[t[i]]]++; for (int i=1;i&lt;=m;i++) buc[i]+=buc[i-1]; for (int i=n;i&gt;=1;i--) sa[buc[rk[t[i]]]--]=t[i];&#125;void make_sa()&#123; m=128; for (int i=1;i&lt;=n;i++) rk[i]=s[i],t[i]=i; get_sa(); for (int k=1;k&lt;n;k&lt;&lt;=1)&#123; int p=0; for (int i=n-k+1;i&lt;=n;i++) t[++p]=i; for (int i=1;i&lt;=n;i++) if (sa[i]&gt;k) t[++p]=sa[i]-k; get_sa(); t[sa[1]]=p=1; for (int i=2;i&lt;=n;i++) if (rk[sa[i]]==rk[sa[i-1]]&amp;&amp;rk[sa[i]+k]==rk[sa[i-1]+k]) t[sa[i]]=p;else t[sa[i]]=++p; memcpy(rk,t,sizeof(t)); if (p==n) break; m=p; &#125;&#125;int main()&#123; scanf(\"%s\",s+1); n=strlen(s+1); for (int i=1;i&lt;=n;i++) s[n+i]=s[i];n+=n; make_sa(); for (int i=1;i&lt;=n;i++) if (sa[i]&lt;=(n&gt;&gt;1)) putchar(s[sa[i]+(n&gt;&gt;1)-1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"后缀数组","slug":"后缀数组","permalink":"http://oi.linkfqy.top/tags/后缀数组/"}]},{"title":"关于WQS二分的一点理解","slug":"WQS-divide","date":"2018-03-30T11:21:55.000Z","updated":"2018-03-31T13:21:00.000Z","comments":true,"path":"posts/WQS-divide/","link":"","permalink":"http://oi.linkfqy.top/posts/WQS-divide/","excerpt":"最近才学习了WQS二分，发现这是一个很有用的东西。","text":"最近才学习了WQS二分，发现这是一个很有用的东西。 大概是这样一类问题：决策\\(i\\)对答案有\\(w_i\\)贡献，求恰好做\\(k\\)次该类决策的最大答案 考虑不限制决策的次数，但每个决策除贡献外，都减去一个代价\\(cost\\) 这样通过调整\\(cost\\)的值，就能够控制决策的次数 WQS二分其实就是二分这个\\(cost\\)，使得最优解做不大于\\(k\\)次该类决策，且\\(cost\\)尽量大 设最优解做了\\(x\\)次该决策，定义\\(g(x)\\)为最优解（不减\\(cost\\)），\\(f(x)\\)为最优解 则有：\\(g(x)=kx+f(x)\\) \\(k\\)其实就是\\(cost\\) 你会发现这其实就是在二分\\(g(x)\\)的斜率，使该斜率对应的\\(x\\)满足题意 这样我们就得到了WQS二分的条件：原贡献关于决策次数的函数\\(g(x)\\)斜率单调（\\(g&#39;(x)\\)单调） 值得注意的是，最后得到的\\(cost\\)，对应决策次数不一定是\\(k\\)（\\(g‘(x)\\)某段水平） 但这并不影响答案，因为\\(g&#39;(x)=g&#39;(k)\\)意味着\\(f(x)=f(k)\\)，我们要的就是\\(f(k)\\) 推荐题目：BZOJ2654 tree、Codeforces 739E Gosha is hunting","categories":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://oi.linkfqy.top/categories/学习笔记/"}],"tags":[{"name":"WQS二分","slug":"WQS二分","permalink":"http://oi.linkfqy.top/tags/WQS二分/"}]},{"title":"【双层WQS二分】Codeforces 739E Gosha is hunting","slug":"CF739E","date":"2018-03-30T03:02:47.000Z","updated":"2018-03-30T03:11:18.000Z","comments":true,"path":"posts/CF739E/","link":"","permalink":"http://oi.linkfqy.top/posts/CF739E/","excerpt":"WQS二分第一题。","text":"WQS二分第一题。 WQS二分需要满足的条件是\\(g(x)\\)斜率单调 这题其实感性理解一下就可以了： 考虑限制Ultra Ball为\\(x\\)个，为了使收益最大，显然是选择贡献前x大的来使用Ultra Ball 这其实是对一个递减序列求前缀和，\\(g(x)\\)当然是斜率单调的啦 由于两种球都有个数限制，WQS二分里再套一个WQS二分就好了 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041#include&lt;cstdio&gt;#include&lt;cstring&gt;#define cl(x,y) memset(x,y,sizeof(x))#define ins(x,y) (x[i]=x[i-1]+y)const int maxn=100005;const double eps=1e-8;int n,A,B,num_a[maxn],num_b[maxn];double a[maxn],b[maxn],f[maxn];void work(double w1,double w2)&#123; f[0]=0;num_a[0]=num_b[0]=0; for (int i=1;i&lt;=n;i++)&#123; ins(f,0);ins(num_a,0);ins(num_b,0); if (f[i-1]+a[i]-w1&gt;f[i]) f[i]=f[i-1]+a[i]-w1,ins(num_a,1),ins(num_b,0); if (f[i-1]+b[i]-w2&gt;f[i]) f[i]=f[i-1]+b[i]-w2,ins(num_a,0),ins(num_b,1); if (f[i-1]+1-(1-a[i])*(1-b[i])-w1-w2&gt;f[i]) f[i]=f[i-1]+1-(1-a[i])*(1-b[i])-w1-w2, ins(num_a,1),ins(num_b,1); &#125;&#125;int main()&#123; while (scanf(\"%d%d%d\",&amp;n,&amp;A,&amp;B)==3)&#123; for (int i=1;i&lt;=n;i++) scanf(\"%lf\",&amp;a[i]); for (int i=1;i&lt;=n;i++) scanf(\"%lf\",&amp;b[i]); double l1=0,r1=1,l2=0,r2=1; while (r1-l1&gt;=eps)&#123; double mid1=(l1+r1)/2; l2=0,r2=1; while (r2-l2&gt;=eps)&#123; double mid2=(l2+r2)/2; if ((work(mid1,mid2),num_b[n])&gt;B) l2=mid2;else r2=mid2; &#125; if (work(mid1,r2),num_a[n]&gt;A) l1=mid1;else r1=mid1; &#125; work(r1,r2); printf(\"%.5lf\\n\",f[n]+r1*A+r2*B); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"Codeforces","slug":"Codeforces","permalink":"http://oi.linkfqy.top/tags/Codeforces/"},{"name":"WQS二分","slug":"WQS二分","permalink":"http://oi.linkfqy.top/tags/WQS二分/"}]},{"title":"【DP】BZOJ2298 [HAOI2011]problem a","slug":"BZOJ2298","date":"2018-03-20T02:59:54.000Z","updated":"2018-03-20T03:10:06.000Z","comments":true,"path":"posts/BZOJ2298/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2298/","excerpt":"","text":"题面在这里 首先吐槽一下题意表述不清…… 题目的意思是每个人说恰好有\\(a_i\\)个人排在前面，恰好\\(b_i\\)人排在后面 一开始把”有“理解为“存在”了，想了好久…… 那么就可以直接确定每个人的排名区间了 如果有两个区间相交但不重合，就可以判定至少一人说谎 问题就变成了最简单的区间覆盖问题了，区间的权值是相同区间的个数 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;cstdio&gt;#include&lt;algorithm&gt;#define mp make_pair#define X first#define Y secondusing namespace std;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=100005;int n,m,f[maxn];pair&lt;int,int&gt; a[maxn];int tot,lnk[maxn],nxt[maxn],son[maxn],w[maxn];inline void add(int x,int y,int z)&#123; z=min(z,x-y); son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;int main()&#123; n=red(); for (int i=1,x,y;i&lt;=n;i++)&#123; x=red(),y=red(); if (x+y+1&lt;=n) a[++m]=mp(x+1,n-y); &#125; sort(a+1,a+1+m); &#123; int x=1; for (int i=2;i&lt;=m;i++) if (a[i]==a[i-1]) x++;else add(a[i-1].Y,a[i-1].X-1,x),x=1; add(a[m].Y,a[m].X-1,x); &#125; f[0]=0; for (int i=1;i&lt;=n;i++)&#123; f[i]=f[i-1]; for (int j=lnk[i];j;j=nxt[j]) f[i]=max(f[i],f[son[j]]+w[j]); &#125; printf(\"%d\",n-f[n]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"DP","slug":"DP","permalink":"http://oi.linkfqy.top/tags/DP/"}]},{"title":"【AC自动机】HDU2222 Keywords Search","slug":"HDU2222","date":"2018-03-15T11:58:37.000Z","updated":"2018-03-15T12:13:06.000Z","comments":true,"path":"posts/HDU2222/","link":"","permalink":"http://oi.linkfqy.top/posts/HDU2222/","excerpt":"从文本中找出字典内单词的个数，AC自动机的经典应用","text":"从文本中找出字典内单词的个数，AC自动机的经典应用 题面在这里 没什么好说的，直接做就好了 可以加一个优化：记录\\(last(x)\\)表示节点\\(x\\)在\\(fail\\)链上的最近单词节点 这样就能保证复杂度了 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;cstdio&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;#define cl(x,y) memset(x,y,sizeof(x))using namespace std;const int maxn=1000005;int tst,n,fal[maxn],son[maxn][26],sum[maxn],lst[maxn],ans,rot=1,len=1;char s[maxn];inline void clear(int x)&#123; cl(son[x],0);sum[x]=fal[x]=0;&#125;void add_s(char *s)&#123; int x=rot; for (int i=0;s[i];i++)&#123; int c=s[i]-'a'; if (!son[x][c]) son[x][c]=++len,clear(len); x=son[x][c]; &#125; sum[x]++;&#125;int que[maxn];void make_fail()&#123; int hed=0,til=0; for (int c=0,u;c&lt;26;c++) if (u=son[rot][c]) que[++til]=u,fal[u]=lst[u]=rot; else son[rot][c]=rot; while (hed!=til)&#123; int x=que[++hed]; for (int c=0,u;c&lt;26;c++) if (u=son[x][c])&#123; que[++til]=u,fal[u]=son[fal[x]][c]; if (sum[fal[u]]) lst[u]=fal[u];else lst[u]=lst[fal[u]]; &#125; else son[x][c]=son[fal[x]][c]; &#125;&#125;void ask_s(char *s)&#123; for (int i=0,x=rot;s[i];i++)&#123; int c=s[i]-'a';x=son[x][c]; for (int p=x;p!=rot&amp;&amp;sum[p]&gt;=0;p=lst[p]) ans+=sum[p],sum[p]=-1; &#125;&#125;int main()&#123; scanf(\"%d\",&amp;tst); while (tst--)&#123; scanf(\"%d\",&amp;n); rot=len=1;ans=0; cl(son,0);cl(fal,0);cl(sum,0);cl(lst,0); while (n--)&#123; scanf(\"%s\",s); add_s(s); &#125; make_fail(); scanf(\"%s\",s); ask_s(s); printf(\"%d\\n\",ans); &#125; return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"HDU","slug":"HDU","permalink":"http://oi.linkfqy.top/tags/HDU/"},{"name":"AC自动机","slug":"AC自动机","permalink":"http://oi.linkfqy.top/tags/AC自动机/"}]},{"title":"【决策单调性DP】BZOJ2369 区间","slug":"BZOJ2369","date":"2018-03-11T12:45:43.000Z","updated":"2018-03-11T12:32:00.000Z","comments":true,"path":"posts/BZOJ2369/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2369/","excerpt":"","text":"题面在这里 可以发现，只选两个区间是最优的 因为选多个区间一定不如选其中最两端的两个区间 所以就可以DP了 之前一定要把被包含的区间处理掉（注意此处也要更新答案） 然后按左端点排序 有DP转移方程： \\[ f_i=Max\\{ |S_i \\cap S_j|\\times|S_i \\cup S_j| \\} \\] 考虑\\(p \\le k \\le i \\le j\\)四个区间 假设对于i来说k比p优，则： \\[ (r_i-l_k)(r_k-l_i)&gt;(r_i-l_p)(r_p-l_i) \\] 整理得： \\[ r_i(r_k-r_p)+l_i(l_k-l_p)&gt;l_kr_k-l_pr_p \\] 而\\(l_j\\ge l_i\\)，就有： \\[ r_j(r_k-r_p)+l_j(l_k-l_p)&gt;l_kr_k-l_pr_p \\] 即 \\[ (r_j-l_k)(r_k-l_j)&gt;(r_j-l_p)(r_p-l_j) \\] 所以这个DP满足决策单调性 然后整体二分搞就好了 示例程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=1000005;int n,m;ll f[maxn];struct data&#123; ll l,r; bool operator&lt;(const data&amp;b)const&#123; return l&lt;b.l||l==b.l&amp;&amp;r&gt;b.r; &#125;&#125;a[maxn],b[maxn];void divide(int l,int r,int ql,int qr)&#123; if (ql&gt;qr) return; int mid=ql+qr&gt;&gt;1; int pos=0,i=mid;ll w=0; for (int j=l;j&lt;=r&amp;&amp;j&lt;i;j++) if (a[i].l&lt;a[j].r&amp;&amp;w&lt;(a[i].r-a[j].l)*(a[j].r-a[i].l)) w=(a[i].r-a[j].l)*(a[j].r-a[i].l),pos=i; f[i]=w; if (!pos) divide(l,r,ql,mid-1),divide(l,r,mid+1,qr); else divide(l,pos,ql,mid-1),divide(pos,r,mid+1,qr);&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) b[i].l=red(),b[i].r=red(); sort(b+1,b+1+n); a[m=1]=b[1]; ll ans=0;int x=1,maxr=b[1].r; for (int i=2;i&lt;=n;i++) if (maxr&lt;b[i].r) a[++m]=b[i],x=i,maxr=b[i].r; else ans=max(ans,(b[x].r-b[x].l)*(b[i].r-b[i].l)); n=m; divide(1,n,1,n); for (int i=2;i&lt;=n;i++) ans=max(ans,f[i]); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"决策单调性","slug":"决策单调性","permalink":"http://oi.linkfqy.top/tags/决策单调性/"},{"name":"整体二分","slug":"整体二分","permalink":"http://oi.linkfqy.top/tags/整体二分/"}]},{"title":"【决策单调性DP】BZOJ2216 [Poi2011]Lightning Conductor","slug":"BZOJ2216","date":"2018-03-09T12:44:52.000Z","updated":"2018-03-09T13:34:28.000Z","comments":true,"path":"posts/BZOJ2216/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ2216/","excerpt":"决策单调性DP入门题","text":"决策单调性DP入门题 题面在这里 决策单调性第一题…… 移项可得： \\[ p \\ge Max\\{a_j +\\sqrt{|i-j|}\\} - a_i \\] 为了对于每个j都满足，要求\\(\\text{Max}\\) 正反都做一遍，就可以只考虑\\(j\\lt i\\)的情况，去绝对值 显然\\(\\sqrt{i-j}\\)是满足四边形不等式的，那么这个DP就有决策单调性 直接整体二分搞就好了 示例程序： 1234567891011121314151617181920212223242526272829303132333435363738#include&lt;cstdio&gt;#include&lt;cmath&gt;#include&lt;cstring&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005;int n,a[maxn],g[maxn],f[maxn];void Divide(int ql,int qr,int l,int r)&#123; if (ql&gt;qr) return; int mid=ql+qr&gt;&gt;1,p=0; double w=0; for (int i=l;i&lt;=mid&amp;&amp;i&lt;=r;i++) if (a[i]+sqrt(mid-i)&gt;w) w=a[i]+sqrt(mid-i),p=i; f[mid]=ceil(w); Divide(ql,mid-1,l,p);Divide(mid+1,qr,p,r);&#125;int main()&#123; n=red(); for (int i=1;i&lt;=n;i++) a[i]=red(); Divide(1,n,1,n); memcpy(g,f,sizeof(f)); memset(f,0,sizeof(f)); for (int i=1;i*2&lt;=n;i++) swap(a[i],a[n-i+1]); Divide(1,n,1,n); for (int i=1;i&lt;=n;i++) printf(\"%d\\n\",max(g[i],f[n-i+1])-a[n-i+1]); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"决策单调性","slug":"决策单调性","permalink":"http://oi.linkfqy.top/tags/决策单调性/"},{"name":"整体二分","slug":"整体二分","permalink":"http://oi.linkfqy.top/tags/整体二分/"}]},{"title":"BZOJ1057 [ZJOI2007]棋盘制作","slug":"BZOJ1057","date":"2018-03-01T07:37:33.000Z","updated":"2018-03-09T12:45:48.000Z","comments":true,"path":"posts/BZOJ1057/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1057/","excerpt":"","text":"题面在这里 直接把奇数位的格子反过来求最大子矩阵即可 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=2005;int n,m,ans1,ans2;bool a[maxn][maxn];int up[maxn],lft[maxn],rit[maxn];void work()&#123; for (int j=0;j&lt;=m+1;j++) up[j]=lft[j]=0,rit[j]=m+1; for (int i=1;i&lt;=n;i++)&#123; int lst=1; for (int j=1;j&lt;=m;j++) if (a[i][j]) up[j]=lft[j]=0,lst=j+1; else up[j]++,lft[j]=max(lst,lft[j]); lst=m; for (int j=m;j;j--) if (a[i][j]) rit[j]=m+1,lst=j-1; else&#123; rit[j]=min(lst,rit[j]); int h=up[j],w=rit[j]-lft[j]+1; ans1=max(ans1,min(h,w)*min(h,w)); ans2=max(ans2,h*w); &#125; &#125;&#125;int main()&#123; n=red(),m=red(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) a[i][j]=red()^((i+j)&amp;1); work(); for (int i=1;i&lt;=n;i++) for (int j=1;j&lt;=m;j++) a[i][j]^=1; work(); printf(\"%d\\n%d\",ans1,ans2); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"水题","slug":"水题","permalink":"http://oi.linkfqy.top/tags/水题/"}]},{"title":"【树形DP】BZOJ1060 [ZJOI2007]时态同步","slug":"BZOJ1060","date":"2018-02-28T14:05:50.000Z","updated":"2018-02-28T14:19:04.000Z","comments":true,"path":"posts/BZOJ1060/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ1060/","excerpt":"其实算不上树形DP……","text":"其实算不上树形DP…… 题面在这里 首先维护一个\\(f_i\\)表示\\(i\\)子树中到根最远的距离 尽量在上面使用道具，利用率最大，所以从上到下考虑 而且最终状态一定是：所有点到根的距离都等于原最大距离 假设已知\\(x\\)上面的路径已经使用了\\(c\\)次 则\\(x\\rightarrow fa\\)这条边上要使用的道具数为\\(f_{Root}-f_x-c\\) 那么所有儿子的\\(c\\)都为\\(f_{Root}-f_x\\) 示例程序： 12345678910111213141516171819202122232425262728293031323334353637383940#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=500005,maxe=1000005;int n,Root;ll ans,f[maxn];int son[maxe],nxt[maxe],lnk[maxn],w[maxe],tot;inline void add(int x,int y,int z)&#123; son[++tot]=y;nxt[tot]=lnk[x];lnk[x]=tot;w[tot]=z;&#125;void mf(int x,int fa,ll dst)&#123; f[x]=dst; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) mf(son[j],x,dst+w[j]),f[x]=max(f[x],f[son[j]]);&#125;void dfs(int x,int fa,ll c)&#123; ans+=f[Root]-f[x]-c; for (int j=lnk[x];j;j=nxt[j]) if (son[j]!=fa) dfs(son[j],x,f[Root]-f[x]);&#125;int main()&#123; n=red();Root=red(); for (int i=1,x,y,z;i&lt;n;i++) x=red(),y=red(),z=red(),add(x,y,z),add(y,x,z); mf(Root,0,0); dfs(Root,0,0); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"水题","slug":"水题","permalink":"http://oi.linkfqy.top/tags/水题/"},{"name":"树形DP","slug":"树形DP","permalink":"http://oi.linkfqy.top/tags/树形DP/"}]},{"title":"BZOJ5168 [HAOI2014]贴海报","slug":"BZOJ5168","date":"2018-02-28T02:24:17.000Z","updated":"2018-02-28T13:38:06.000Z","comments":true,"path":"posts/BZOJ5168/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ5168/","excerpt":"","text":"题面在这里 日常划水…… 示例程序： 12345678910111213141516171819202122232425262728293031323334353637#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;inline char nc()&#123; static char buf[100000],*p1=buf,*p2=buf; return p1==p2&amp;&amp;(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;&#125;inline int red()&#123; int res=0,f=1;char ch=nc(); while (ch&lt;'0'||'9'&lt;ch) &#123;if (ch=='-') f=-f;ch=nc();&#125; while ('0'&lt;=ch&amp;&amp;ch&lt;='9') res=res*10+ch-48,ch=nc(); return res*f;&#125;const int maxn=4005;int n,N,m,mm,b[maxn],wall[maxn],ans;struct data&#123; int l,r;&#125;a[maxn];bool vis[maxn];inline int ID(int x) &#123;return lower_bound(b+1,b+1+m,x)-b;&#125;int main()&#123; N=red();n=red(); for (int i=1;i&lt;=n;i++) b[++m]=a[i].l=red(),b[++m]=a[i].r=red(); sort(b+1,b+1+m);mm=m; for (int i=1;i&lt;m;i++) if (b[i+1]-b[i]&gt;1) b[++mm]=b[i]+1; sort(b+1,b+1+mm); m=unique(b+1,b+1+mm)-b-1; for (int i=1;i&lt;=n;i++)&#123; int s=ID(a[i].l),t=ID(a[i].r); for (int j=s;j&lt;=t;j++) wall[j]=i; &#125; for (int i=1;i&lt;=m;i++) vis[wall[i]]=1; for (int i=1;i&lt;=n;i++) ans+=vis[i]; printf(\"%d\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"水题","slug":"水题","permalink":"http://oi.linkfqy.top/tags/水题/"}]},{"title":"【树状数组】BZOJ3192 [JLOI2013]删除物品","slug":"BZOJ3192","date":"2018-02-27T03:30:47.000Z","updated":"2018-02-27T03:30:48.000Z","comments":true,"path":"posts/BZOJ3192/","link":"","permalink":"http://oi.linkfqy.top/posts/BZOJ3192/","excerpt":"非常巧妙的转化，简化了题目","text":"非常巧妙的转化，简化了题目 题面在这里 首先可以发现，无论怎么移动，所有元素的相对位置是不变的 所以可以把两个堆转化为一个序列（第一个堆倒置） 然后其实就是对临界指针的移动了 用树状数组维护每次移动过程经过多少没有被删除的元素 示例程序： 12345678910111213141516171819202122232425#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;typedef long long ll;#define abs_(x) ((x)&gt;0?(x):-(x))const int maxn=100005;int N,M,n,a[maxn],BIT[maxn];ll ans=0;pair&lt;int,int&gt; b[maxn];#define lowbit(x) ((x)&amp;-(x))inline void ist(int x,int w) &#123;for (int i=x;i&lt;=n;i+=lowbit(i)) BIT[i]+=w;&#125;inline int ask(int x) &#123;int res=0;for (int i=x;i;i-=lowbit(i)) res+=BIT[i];return res;&#125;int main()&#123; scanf(\"%d%d\",&amp;N,&amp;M); for (int i=N;i;i--) scanf(\"%d\",&amp;a[i]),b[++n]=make_pair(a[i],N-n+1); for (int i=1;i&lt;=M;i++) scanf(\"%d\",&amp;a[i+N]),b[++n]=make_pair(a[i+N],n); sort(b+1,b+1+n); for (int i=1;i&lt;=n;i++) ist(i,1); for (int t=n,i=N;t;t--) if (i&lt;b[t].second) ans+=ask(b[t].second-1)-ask(i),i=b[t].second-1,ist(b[t].second,-1); else ans+=ask(i)-ask(b[t].second),i=b[t].second,ist(b[t].second,-1); printf(\"%lld\",ans); return 0;&#125;","categories":[{"name":"题解","slug":"题解","permalink":"http://oi.linkfqy.top/categories/题解/"}],"tags":[{"name":"BZOJ","slug":"BZOJ","permalink":"http://oi.linkfqy.top/tags/BZOJ/"},{"name":"树状数组","slug":"树状数组","permalink":"http://oi.linkfqy.top/tags/树状数组/"}]},{"title":"你好，世界","slug":"Hello World","date":"2018-02-24T10:00:00.000Z","updated":"2018-02-24T10:01:16.000Z","comments":true,"path":"posts/Hello World/","link":"","permalink":"http://oi.linkfqy.top/posts/Hello World/","excerpt":"终于抛弃了CSDN博客。 不得不说，CSDN的体验越来越糟糕，最近一次改版后，连\\(\\LaTeX\\)公式都不能使用 折腾了半天，终于把新博客搭建好了","text":"终于抛弃了CSDN博客。 不得不说，CSDN的体验越来越糟糕，最近一次改版后，连\\(\\LaTeX\\)公式都不能使用 折腾了半天，终于把新博客搭建好了 测试标题 小标题 测试公式： \\[ \\begin{aligned} \\dot{x} &amp; = \\sigma(y-x) \\\\ \\dot{y} &amp; = \\rho x - y - xz \\\\ \\dot{z} &amp; = -\\beta z + xy \\end{aligned} \\] 删除线 加粗 斜体 一级列表 二级列表 三级列表 二级列表 12345#include&lt;cstdio&gt;int main()&#123; printf(\"Hello World\"); return 0;&#125;","categories":[{"name":"杂","slug":"杂","permalink":"http://oi.linkfqy.top/categories/杂/"}],"tags":[]}]}